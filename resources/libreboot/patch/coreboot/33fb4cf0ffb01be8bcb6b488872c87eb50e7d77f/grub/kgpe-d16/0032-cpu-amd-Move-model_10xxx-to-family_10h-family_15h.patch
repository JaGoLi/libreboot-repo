From a9c46688fdefebdf70848b4aba0021d747baee16 Mon Sep 17 00:00:00 2001
From: Timothy Pearson <tpearson@raptorengineeringinc.com>
Date: Fri, 16 Oct 2015 14:24:06 -0500
Subject: [PATCH 032/143] cpu/amd: Move model_10xxx to family_10h-family_15h

Change-Id: I34501d3fc68b71db7781dad11d5b883868932a60
Signed-off-by: Timothy Pearson <tpearson@raptorengineeringinc.com>
---
 src/cpu/amd/Kconfig                                |    2 +-
 src/cpu/amd/family_10h-family_15h/Kconfig          |   88 ++
 src/cpu/amd/family_10h-family_15h/Makefile.inc     |   14 +
 src/cpu/amd/family_10h-family_15h/defaults.h       |  479 +++++++++
 src/cpu/amd/family_10h-family_15h/fidvid.c         | 1048 ++++++++++++++++++++
 src/cpu/amd/family_10h-family_15h/init_cpus.c      |  968 ++++++++++++++++++
 .../amd/family_10h-family_15h/model_10xxx_init.c   |  165 +++
 .../amd/family_10h-family_15h/monotonic_timer.c    |   98 ++
 src/cpu/amd/family_10h-family_15h/powernow_acpi.c  |  311 ++++++
 src/cpu/amd/family_10h-family_15h/processor_name.c |  323 ++++++
 src/cpu/amd/family_10h-family_15h/ram_calc.c       |   54 +
 src/cpu/amd/family_10h-family_15h/ram_calc.h       |   25 +
 .../amd/family_10h-family_15h/update_microcode.c   |   71 ++
 src/cpu/amd/model_10xxx/Kconfig                    |   88 --
 src/cpu/amd/model_10xxx/Makefile.inc               |   14 -
 src/cpu/amd/model_10xxx/defaults.h                 |  479 ---------
 src/cpu/amd/model_10xxx/fidvid.c                   | 1048 --------------------
 src/cpu/amd/model_10xxx/init_cpus.c                |  968 ------------------
 src/cpu/amd/model_10xxx/model_10xxx_init.c         |  165 ---
 src/cpu/amd/model_10xxx/monotonic_timer.c          |   98 --
 src/cpu/amd/model_10xxx/powernow_acpi.c            |  311 ------
 src/cpu/amd/model_10xxx/processor_name.c           |  323 ------
 src/cpu/amd/model_10xxx/ram_calc.c                 |   54 -
 src/cpu/amd/model_10xxx/ram_calc.h                 |   25 -
 src/cpu/amd/model_10xxx/update_microcode.c         |   71 --
 src/cpu/amd/socket_AM2r2/Makefile.inc              |    2 +-
 src/cpu/amd/socket_AM3/Makefile.inc                |    2 +-
 src/cpu/amd/socket_ASB2/Makefile.inc               |    2 +-
 src/cpu/amd/socket_C32/Makefile.inc                |    2 +-
 src/cpu/amd/socket_F_1207/Makefile.inc             |    2 +-
 src/cpu/amd/socket_G34/Makefile.inc                |    2 +-
 src/mainboard/advansus/a785e-i/romstage.c          |    2 +-
 src/mainboard/amd/bimini_fam10/romstage.c          |    2 +-
 src/mainboard/amd/mahogany_fam10/romstage.c        |    2 +-
 .../amd/serengeti_cheetah_fam10/romstage.c         |    2 +-
 src/mainboard/amd/tilapia_fam10/romstage.c         |    2 +-
 src/mainboard/asus/kfsn4-dre/romstage.c            |    2 +-
 src/mainboard/asus/kgpe-d16/romstage.c             |    2 +-
 src/mainboard/asus/m4a78-em/romstage.c             |    2 +-
 src/mainboard/asus/m4a785-m/romstage.c             |    2 +-
 src/mainboard/asus/m5a88-v/romstage.c              |    2 +-
 src/mainboard/avalue/eax-785e/romstage.c           |    2 +-
 src/mainboard/gigabyte/ma785gm/romstage.c          |    2 +-
 src/mainboard/gigabyte/ma785gmt/romstage.c         |    2 +-
 src/mainboard/gigabyte/ma78gm/romstage.c           |    2 +-
 src/mainboard/hp/dl165_g6_fam10/romstage.c         |    2 +-
 src/mainboard/iei/kino-780am2-fam10/romstage.c     |    2 +-
 src/mainboard/jetway/pa78vm5/romstage.c            |    2 +-
 src/mainboard/msi/ms9652_fam10/romstage.c          |    2 +-
 src/mainboard/supermicro/h8dmr_fam10/romstage.c    |    2 +-
 src/mainboard/supermicro/h8qme_fam10/romstage.c    |    2 +-
 src/mainboard/supermicro/h8scm_fam10/romstage.c    |    2 +-
 src/mainboard/tyan/s2912_fam10/romstage.c          |    2 +-
 src/northbridge/amd/amdfam10/northbridge.c         |    2 +-
 54 files changed, 3674 insertions(+), 3674 deletions(-)
 create mode 100644 src/cpu/amd/family_10h-family_15h/Kconfig
 create mode 100644 src/cpu/amd/family_10h-family_15h/Makefile.inc
 create mode 100644 src/cpu/amd/family_10h-family_15h/defaults.h
 create mode 100644 src/cpu/amd/family_10h-family_15h/fidvid.c
 create mode 100644 src/cpu/amd/family_10h-family_15h/init_cpus.c
 create mode 100644 src/cpu/amd/family_10h-family_15h/model_10xxx_init.c
 create mode 100644 src/cpu/amd/family_10h-family_15h/monotonic_timer.c
 create mode 100644 src/cpu/amd/family_10h-family_15h/powernow_acpi.c
 create mode 100644 src/cpu/amd/family_10h-family_15h/processor_name.c
 create mode 100644 src/cpu/amd/family_10h-family_15h/ram_calc.c
 create mode 100644 src/cpu/amd/family_10h-family_15h/ram_calc.h
 create mode 100644 src/cpu/amd/family_10h-family_15h/update_microcode.c
 delete mode 100644 src/cpu/amd/model_10xxx/Kconfig
 delete mode 100644 src/cpu/amd/model_10xxx/Makefile.inc
 delete mode 100644 src/cpu/amd/model_10xxx/defaults.h
 delete mode 100644 src/cpu/amd/model_10xxx/fidvid.c
 delete mode 100644 src/cpu/amd/model_10xxx/init_cpus.c
 delete mode 100644 src/cpu/amd/model_10xxx/model_10xxx_init.c
 delete mode 100644 src/cpu/amd/model_10xxx/monotonic_timer.c
 delete mode 100644 src/cpu/amd/model_10xxx/powernow_acpi.c
 delete mode 100644 src/cpu/amd/model_10xxx/processor_name.c
 delete mode 100644 src/cpu/amd/model_10xxx/ram_calc.c
 delete mode 100644 src/cpu/amd/model_10xxx/ram_calc.h
 delete mode 100644 src/cpu/amd/model_10xxx/update_microcode.c

diff --git a/src/cpu/amd/Kconfig b/src/cpu/amd/Kconfig
index 3a02043..8abc984 100644
--- a/src/cpu/amd/Kconfig
+++ b/src/cpu/amd/Kconfig
@@ -12,7 +12,7 @@ source src/cpu/amd/socket_F_1207/Kconfig
 source src/cpu/amd/socket_S1G1/Kconfig
 
 source src/cpu/amd/model_fxx/Kconfig
-source src/cpu/amd/model_10xxx/Kconfig
+source src/cpu/amd/family_10h-family_15h/Kconfig
 source src/cpu/amd/geode_gx2/Kconfig
 source src/cpu/amd/geode_lx/Kconfig
 
diff --git a/src/cpu/amd/family_10h-family_15h/Kconfig b/src/cpu/amd/family_10h-family_15h/Kconfig
new file mode 100644
index 0000000..7c47e27
--- /dev/null
+++ b/src/cpu/amd/family_10h-family_15h/Kconfig
@@ -0,0 +1,88 @@
+config CPU_AMD_MODEL_10XXX
+	bool
+	select ARCH_BOOTBLOCK_X86_32
+	select ARCH_VERSTAGE_X86_32
+	select ARCH_ROMSTAGE_X86_32
+	select ARCH_RAMSTAGE_X86_32
+	select SSE
+	select SSE2
+	select MMCONF_SUPPORT_DEFAULT
+	select TSC_SYNC_LFENCE
+	select UDELAY_LAPIC
+	select HAVE_MONOTONIC_TIMER
+	select SUPPORT_CPU_UCODE_IN_CBFS
+	select CPU_MICROCODE_MULTIPLE_FILES
+
+if CPU_AMD_MODEL_10XXX
+
+config NUM_IPI_STARTS
+	int
+	default 1
+
+config CPU_ADDR_BITS
+	int
+	default 48
+
+config DCACHE_RAM_BASE
+	hex
+	default 0xc4000
+
+config DCACHE_RAM_SIZE
+	hex
+	default 0x0c000
+
+config DCACHE_BSP_STACK_SIZE
+	hex
+	default 0x2000
+
+config DCACHE_BSP_STACK_SLUSH
+	hex
+	default 0x1000
+
+config DCACHE_AP_STACK_SIZE
+	hex
+	default 0x400
+
+config UDELAY_IO
+	bool
+	default n
+
+config SET_FIDVID
+	bool
+	default y
+
+config MAX_PHYSICAL_CPUS
+	int
+	default 1
+
+config LIFT_BSP_APIC_ID
+	bool
+	default n
+
+if SET_FIDVID
+config SET_FIDVID_DEBUG
+	bool
+	default y
+
+config SET_FIDVID_STORE_AP_APICID_AT_FIRST
+	bool
+	default y
+
+config SET_FIDVID_CORE0_ONLY
+	bool
+	default n
+
+# 0: all cores
+# 1: core 0 only
+# 2: all but core 0
+config SET_FIDVID_CORE_RANGE
+	int
+	default 0
+
+endif	# SET_FIDVID
+
+config UDELAY_LAPIC_FIXED_FSB
+	int
+	default 200
+
+endif	# CPU_AMD_MODEL_10XXX
diff --git a/src/cpu/amd/family_10h-family_15h/Makefile.inc b/src/cpu/amd/family_10h-family_15h/Makefile.inc
new file mode 100644
index 0000000..5a81ab8
--- /dev/null
+++ b/src/cpu/amd/family_10h-family_15h/Makefile.inc
@@ -0,0 +1,14 @@
+romstage-y += ../../x86/mtrr/earlymtrr.c
+ramstage-y += model_10xxx_init.c
+ramstage-y += processor_name.c
+
+romstage-y += update_microcode.c
+romstage-y += ram_calc.c
+ramstage-y += ram_calc.c
+ramstage-y += monotonic_timer.c
+ramstage-$(CONFIG_HAVE_ACPI_TABLES) += powernow_acpi.c
+
+# Microcode for Family 10h, 11h, 12h, and 14h
+cbfs-files-$(CONFIG_CPU_MICROCODE_MULTIPLE_FILES) += microcode_amd.bin
+microcode_amd.bin-file := 3rdparty/blobs/cpu/amd/family_10h-family_14h/microcode_amd.bin
+microcode_amd.bin-type := microcode
diff --git a/src/cpu/amd/family_10h-family_15h/defaults.h b/src/cpu/amd/family_10h-family_15h/defaults.h
new file mode 100644
index 0000000..6fd1a7e
--- /dev/null
+++ b/src/cpu/amd/family_10h-family_15h/defaults.h
@@ -0,0 +1,479 @@
+/*
+ * This file is part of the coreboot project.
+ *
+ * Copyright (C) 2008 Advanced Micro Devices, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.
+ */
+
+#include <northbridge/amd/amdmct/amddefs.h>
+#include <cpu/amd/mtrr.h>
+
+/*
+ * Default MSR and errata settings.
+ */
+static const struct {
+	u32 msr;
+	u32 revision;
+	u32 platform;
+	u32 data_lo;
+	u32 data_hi;
+	u32 mask_lo;
+	u32 mask_hi;
+} fam10_msr_default[] = {
+	{ TOP_MEM2, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0x00000000, 0x00000000,
+	  0xFFFFFFFF, 0xFFFFFFFF },
+
+	{ SYSCFG, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  3 << 21, 0x00000000,
+	  3 << 21, 0x00000000 },	/* [MtrrTom2En]=1,[TOM2EnWB] = 1*/
+
+	{ HWCR, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  1 << 4, 0x00000000,
+	  1 << 4, 0x00000000 },		/* [INVD_WBINVD]=1 */
+
+	{ MC4_CTL_MASK, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0xF << 19, 0x00000000,
+	  0xF << 19, 0x00000000 },	/* [RtryHt[0..3]]=1 */
+
+	{ DC_CFG, AMD_FAM10_ALL, AMD_PTYPE_SVR,
+	  0x00000000, 0x00000004,
+	  0x00000000, 0x0000000C },	/* [REQ_CTR] = 1 for Server */
+
+	{ DC_CFG, AMD_DR_Bx, AMD_PTYPE_SVR,
+	  0x00000000, 0x00000000,
+	  0x00000000, 0x00000C00 },	/* Erratum 326 */
+
+	{ NB_CFG, AMD_FAM10_ALL, AMD_PTYPE_DC | AMD_PTYPE_MC,
+	  0x00000000, 1 << 22,
+	  0x00000000, 1 << 22 },	/* [ApicInitIDLo]=1 */
+
+	{ BU_CFG2, AMD_DR_Bx, AMD_PTYPE_ALL,
+	  1 << 29, 0x00000000,
+	  1 << 29, 0x00000000 },	/* For Bx Smash1GPages=1 */
+
+	{ DC_CFG, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  1 << 24, 0x00000000,
+	  1 << 24, 0x00000000 },	/* Erratum #261 [DIS_PIGGY_BACK_SCRUB]=1 */
+
+	{ LS_CFG, AMD_DR_GT_B0, AMD_PTYPE_ALL,
+	  0 << 1, 0x00000000,
+	  1 << 1, 0x00000000 },		/* IDX_MATCH_ALL=0 */
+
+	{ BU_CFG, AMD_DR_LT_B3, AMD_PTYPE_ALL,
+	  1 << 21, 0x00000000,
+	  1 << 21, 0x00000000 },	/* Erratum #254 DR B1 BU_CFG[21]=1 */
+
+	{ BU_CFG, AMD_DR_LT_B3, AMD_PTYPE_ALL,
+	  1 << 23, 0x00000000,
+	  1 << 23, 0x00000000 },	/* Erratum #309 BU_CFG[23]=1 */
+
+	/* CPUID_EXT_FEATURES */
+	{ CPUIDFEATURES, AMD_FAM10_ALL, AMD_PTYPE_DC | AMD_PTYPE_MC,
+	  1 << 28, 0x00000000,
+	  1 << 28, 0x00000000 },	/* [HyperThreadFeatEn]=1 */
+
+	{ CPUIDFEATURES, AMD_FAM10_ALL, AMD_PTYPE_DC,
+	  0x00000000, 1 << (33-32),
+	  0x00000000, 1 << (33-32) },	/* [ExtendedFeatEn]=1 */
+
+	{ BU_CFG2, AMD_DRBH_Cx, AMD_PTYPE_ALL,
+	  0x00000000, 1 << (35-32),
+	  0x00000000, 1 << (35-32) },	/* Erratum 343 (set to 0 after CAR, in post_cache_as_ram()/model_10xxx_init() )  */
+
+	{ OSVW_ID_Length, AMD_DR_Bx | AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL,
+	  0x00000004, 0x00000000,
+	  0x00000004, 0x00000000},	/* B0 or Above, OSVW_ID_Length is 0004h */
+
+	{ OSVW_Status, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_MC,
+	  0x0000000C, 0x00000000,
+	  0x0000000C, 0x00000000},	/* Cx and Dx multiple-link processor */
+
+	{ BU_CFG2, AMD_DR_Dx, AMD_PTYPE_ALL,
+	  0x00000000, 1 << (50-32),
+	  0x00000000, 1 << (50-32)},	/* D0 or Above, RdMmExtCfgQwEn*/
+
+	{ CPU_ID_EXT_FEATURES_MSR, AMD_DR_Dx, AMD_PTYPE_ALL,
+	  0x00000000, 1 << (51 - 32),
+	  0x00000000, 1 << (51 - 32)},	/* G34_PKG | C32_PKG | S1G4_PKG | ASB2_PKG */
+};
+
+
+/*
+ * Default PCI and errata settings.
+ */
+static const struct {
+	u8  function;
+	u16 offset;
+	u32 revision;
+	u32 platform;
+	u32 data;
+	u32 mask;
+} fam10_pci_default[] = {
+
+	/* Function 0 - HT Config */
+
+	{ 0, 0x68, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0x004E4800, 0x006E6800 },	/* [19:17] for 8bit APIC config,
+	  [14:13] BufPriRel = 2h [11] RspPassPW set,
+	  [22:21] DsNpReqLmt = 10b */
+
+	/* Errata 281 Workaround */
+	{ 0, 0x68, (AMD_DR_B0 | AMD_DR_B1),
+	  AMD_PTYPE_SVR, 0x00200000, 0x00600000 },	/* [22:21] DsNpReqLmt0 = 01b */
+
+	{ 0, 0x84, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0x00002000, 0x00002000 },	/* [13] LdtStopTriEn = 1 */
+
+	{ 0, 0xA4, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0x00002000, 0x00002000 },	/* [13] LdtStopTriEn = 1 */
+
+	{ 0, 0xC4, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0x00002000, 0x00002000 },	/* [13] LdtStopTriEn = 1 */
+
+	{ 0, 0xE4, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0x00002000, 0x00002000 },	/* [13] LdtStopTriEn = 1 */
+
+	/* Link Global Retry Control Register */
+	{ 0, 0x150, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0x00073900, 0x00073F00 },
+
+	/*  Errata 351
+	 * System software should program the Link Extended Control Registers[LS2En]
+	 * (F0x[18C:170][8]) to 0b for all links. System software should also
+	 * program Link Global Extended Control Register[ForceFullT0]
+	 * (F0x16C[15:13]) to 000b */
+
+	{ 0, 0x170, AMD_FAM10_ALL, AMD_PTYPE_ALL, /* Fix FAM10_ALL when fixed in rev guide */
+	  0x00000000, 0x00000100 },
+	{ 0, 0x174, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0x00000000, 0x00000100 },
+	{ 0, 0x178, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0x00000000, 0x00000100 },
+	{ 0, 0x17C, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0x00000000, 0x00000100 },
+	{ 0, 0x180, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0x00000000, 0x00000100 },
+	{ 0, 0x184, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0x00000000, 0x00000100 },
+	{ 0, 0x188, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0x00000000, 0x00000100 },
+	{ 0, 0x18C, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0x00000000, 0x00000100 },
+	{ 0, 0x170, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0x00000000, 0x00000100 },
+
+	/* Link Global Extended Control Register */
+	{ 0, 0x16C, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0x00000014, 0x0000003F },	/* [15:13] ForceFullT0 = 0b,
+								 * Set T0Time 14h per BKDG */
+
+
+	/* Function 1 - Map Init */
+
+	/* Before reading F1x114_x2 or F1x114_x3 software must
+	 * initialize the registers or NB Array MCA errors may
+	 * occur.  BIOS should initialize index 0h of F1x114_x2 and
+	 * F1x114_x3 to prevent reads from F1x114 from generating NB
+	 * Array MCA errors.  BKDG Doc #3116 Rev 1.07
+	 */
+
+	{ 1, 0x110, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0x20000000, 0xFFFFFFFF },	/* Select extended MMIO Base */
+
+	{ 1, 0x114, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0x00000000, 0xFFFFFFFF },	/* Clear map  */
+
+	{ 1, 0x110, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0x30000000, 0xFFFFFFFF },	/* Select extended MMIO Base */
+
+	{ 1, 0x114, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0x00000000, 0xFFFFFFFF },	/* Clear map  */
+
+	/* Function 2 - DRAM Controller */
+
+	/* Function 3 - Misc. Control */
+	{ 3, 0x40, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0x00000100, 0x00000100 },	/* [8] MstrAbrtEn */
+
+	{ 3, 0x44, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0x4A30005C, 0x4A30005C },	/* [30] SyncOnDramAdrParErrEn = 1,
+					   [27] NbMcaToMstCpuEn = 1,
+					   [25] DisPciCfgCpuErrRsp = 1,
+					   [21] SyncOnAnyErrEn = 1,
+					   [20] SyncOnWDTEn = 1,
+					   [6] CpuErrDis = 1,
+					   [4] SyncPktPropDis = 1,
+					   [3] SyncPktGenDis = 1,
+					   [2] SyncOnUcEccEn = 1 */
+
+	/* XBAR buffer settings */
+	{ 3, 0x6C, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0x00018052, 0x700780F7 },
+
+	/* Errata 281 Workaround */
+	{ 3, 0x6C, ( AMD_DR_B0 | AMD_DR_B1),
+	  AMD_PTYPE_SVR, 0x00010094, 0x700780F7 },
+
+	{ 3, 0x6C, AMD_FAM10_ALL, AMD_PTYPE_UMA,
+	  0x60018051, 0x700780F7 },
+
+	{ 3, 0x70, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0x00041153, 0x777777F7 },
+
+	{ 3, 0x70, AMD_FAM10_ALL, AMD_PTYPE_UMA,
+	  0x61221151, 0x777777F7 },
+
+	{ 3, 0x74, AMD_FAM10_ALL, AMD_PTYPE_UMA,
+	  0x00080101, 0x000F7777 },
+
+	{ 3, 0x7C, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0x00090914, 0x707FFF1F },
+
+	/* Errata 281 Workaround */
+	{ 3, 0x7C, ( AMD_DR_B0 | AMD_DR_B1),
+	 AMD_PTYPE_SVR, 0x00144514, 0x707FFF1F },
+
+	{ 3, 0x7C, AMD_FAM10_ALL, AMD_PTYPE_UMA,
+	  0x00070814, 0x007FFF1F },
+
+	{ 3, 0x140, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0x00800756, 0x00F3FFFF },
+
+	{ 3, 0x140, AMD_FAM10_ALL, AMD_PTYPE_UMA,
+	  0x00C37756, 0x00F3FFFF },
+
+	{ 3, 0x144, AMD_FAM10_ALL, AMD_PTYPE_UMA,
+	  0x00000036, 0x000000FF },
+
+	/* Errata 281 Workaround */
+	{ 3, 0x144, ( AMD_DR_B0 | AMD_DR_B1),
+	 AMD_PTYPE_SVR, 0x00000001, 0x0000000F },
+	 	/* [3:0] RspTok = 0001b */
+
+	{ 3, 0x148, AMD_FAM10_ALL, AMD_PTYPE_UMA,
+	  0x8000052A, 0xD5FFFFFF },
+
+	/* ACPI Power State Control Reg1 */
+	{ 3, 0x80, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0xE6002200, 0xFFFFFFFF },
+
+	/* ACPI Power State Control Reg2 */
+	{ 3, 0x84, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0xA0E641E6, 0xFFFFFFFF },
+
+	{ 3, 0xA0, AMD_FAM10_ALL, AMD_PTYPE_MOB | AMD_PTYPE_DSK,
+	  0x00000080, 0x00000080 },	/* [7] PSIVidEnable */
+
+	{ 3, 0xA0, AMD_DR_Bx, AMD_PTYPE_ALL,
+	  0x00002800, 0x000003800 },	/* [13:11] PllLockTime = 5 */
+
+	{ 3, 0xA0, (AMD_FAM10_ALL & ~(AMD_DR_Bx)), AMD_PTYPE_ALL,
+	  0x00000800, 0x000003800 },	/* [13:11] PllLockTime = 1 */
+
+	/* Reported Temp Control Register */
+	{ 3, 0xA4, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0x00000080, 0x00000080 },	/* [7] TempSlewDnEn = 1 */
+
+	/* Clock Power/Timing Control 0 Register */
+	{ 3, 0xD4, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0xC0000F00, 0xF0000F00 },	/*  [31] NbClkDivApplyAll = 1,
+		[30:28] NbClkDiv = 100b,[11:8] ClkRampHystSel = 1111b */
+
+	/* Clock Power/Timing Control 1 Register */
+	{ 3, 0xD8, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0x03000016, 0x0F000077 },	/* [6:4] VSRampTime = 1,
+		[2:0] VSSlamTime = 6, [27:24] ReConDel = 3 */
+
+
+	/* Clock Power/Timing Control 2 Register */
+	{ 3, 0xDC, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0x00005000, 0x00007000 },	/* [14:12] NbsynPtrAdj = 5 */
+
+
+	/* Extended NB MCA Config Register */
+	{ 3, 0x180, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0x007003E2, 0x007003E2 },	/* [22:20] = SyncFloodOn_Err = 7,
+					   [9] SyncOnUncNbAryEn = 1 ,
+					   [8] SyncOnProtEn = 1,
+					   [7] SyncFloodOnTgtAbtErr = 1,
+					   [6] SyncFloodOnDatErr = 1,
+					   [5] DisPciCfgCpuMstAbtRsp = 1,
+					   [1] SyncFloodOnUsPwDataErr = 1 */
+
+	/* errata 346 - Fam10 C2, C3
+	 *  System software should set F3x188[22] to 1b. */
+	{ 3, 0x188, AMD_DR_Cx, AMD_PTYPE_ALL,
+	  0x00400000, 0x00400000 },
+
+	/* L3 Control Register */
+	{ 3, 0x1B8, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0x00001000, 0x00001000 },	/* [12] = L3PrivReplEn */
+
+	/* IBS Control Register */
+	{ 3, 0x1CC, AMD_FAM10_ALL, AMD_PTYPE_ALL,
+	  0x00000100, 0x00000100 },	/* [8] = LvtOffsetVal */
+};
+
+
+/*
+ * Default HyperTransport Phy and errata settings.
+ */
+static const struct {
+	u16 htreg;	/* HT Phy Register index */
+	u32 revision;
+	u32 platform;
+	u32 linktype;
+	u32 data;
+	u32 mask;
+} fam10_htphy_default[] = {
+
+	/* Errata 344 - Fam10 C2/C3, D0/D1
+	 * System software should set bit 6 of F4x1[9C, 94, 8C, 84]_x[78:70, 68:60]. */
+	{ 0x60, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+	{ 0x61, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+	{ 0x62, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+	{ 0x63, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+	{ 0x64, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+	{ 0x65, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+	{ 0x66, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+	{ 0x67, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+	{ 0x68, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+
+	{ 0x70, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+	{ 0x71, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+	{ 0x72, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+	{ 0x73, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+	{ 0x74, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+	{ 0x75, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+	{ 0x76, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+	{ 0x77, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+	{ 0x78, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+
+	/* Errata 354 - Fam10 C2, C3
+	 * System software should set bit 6 of F4x1[9C,94,8C,84]_x[58:50, 48:40] for all links. */
+	{ 0x40, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+	{ 0x41, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+	{ 0x42, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+	{ 0x43, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+	{ 0x44, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+	{ 0x45, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+	{ 0x46, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+	{ 0x47, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+	{ 0x48, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+
+	{ 0x50, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+	{ 0x51, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+	{ 0x52, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+	{ 0x53, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+	{ 0x54, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+	{ 0x55, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+	{ 0x56, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+	{ 0x57, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+	{ 0x58, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00000040, 0x00000040 },
+
+	/* Errata 327 - Fam10 C2/C3, D0/D1
+	 * BIOS should set the Link Phy Impedance Register[RttCtl]
+	 * (F4x1[9C, 94, 8C, 84]_x[D0, C0][31:29]) to 010b and
+	 * Link Phy Impedance Register[RttIndex]
+	 * (F4x1[9C, 94, 8C, 84]_x[D0, C0][20:16]) to 00100b */
+	{ 0xC0, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x40040000, 0xe01F0000 },
+	{ 0xD0, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x40040000, 0xe01F0000 },
+
+	{ 0x520A,AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00004000, 0x00006000 },	/* HT_PHY_DLL_REG */
+
+	{ 0x530A, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00004000, 0x00006000 },	/* HT_PHY_DLL_REG */
+
+	{ 0x520A, AMD_DR_ALL, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00004400, 0x00006400 },	/* HT_PHY_DLL_REG */
+
+	{ 0x530A, AMD_DR_ALL, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x00004400, 0x00006400 },	/* HT_PHY_DLL_REG */
+
+	{ 0xCF, AMD_FAM10_ALL, AMD_PTYPE_ALL, HTPHY_LINKTYPE_HT3,
+	  0x00000000, 0x000000FF },	/* Provide clear setting for logical
+					   completeness */
+
+	{ 0xDF, AMD_FAM10_ALL, AMD_PTYPE_ALL, HTPHY_LINKTYPE_HT3,
+	  0x00000000, 0x000000FF },	/* Provide clear setting for logical
+					   completeness */
+
+	{ 0xCF, AMD_FAM10_ALL, AMD_PTYPE_ALL, HTPHY_LINKTYPE_HT1,
+	  0x0000006D, 0x000000FF },	/* HT_PHY_HT1_FIFO_PTR_OPT_VALUE */
+
+	{ 0xDF, AMD_FAM10_ALL, AMD_PTYPE_ALL,  HTPHY_LINKTYPE_HT1,
+	  0x0000006D, 0x000000FF }, 	/* HT_PHY_HT1_FIFO_PTR_OPT_VALUE */
+
+	/* Link Phy Receiver Loop Filter Registers */
+	{ 0xD1, AMD_FAM10_ALL, AMD_PTYPE_ALL, HTPHY_LINKTYPE_HT3,
+	  0x08040000, 0x3FFFC000 },	/* [29:22] LfcMax = 20h,
+					   [21:14] LfcMin = 10h */
+
+	{ 0xC1, AMD_FAM10_ALL, AMD_PTYPE_ALL, HTPHY_LINKTYPE_HT3,
+	  0x08040000, 0x3FFFC000 },	/* [29:22] LfcMax = 20h,
+					   [21:14] LfcMin = 10h */
+
+	{ 0xD1, AMD_FAM10_ALL, AMD_PTYPE_ALL, HTPHY_LINKTYPE_HT1,
+	  0x04020000, 0x3FFFC000 },	/* [29:22] LfcMax = 10h,
+					   [21:14] LfcMin = 08h */
+
+	{ 0xC1, AMD_FAM10_ALL, AMD_PTYPE_ALL, HTPHY_LINKTYPE_HT1,
+	  0x04020000, 0x3FFFC000 },	/* [29:22] LfcMax = 10h,
+					   [21:14] LfcMin = 08h */
+
+	{ 0xC0, AMD_FAM10_ALL, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
+	  0x40040000, 0xe01F0000 },	/* [31:29] RttCtl = 02h,
+								   [20:16] RttIndex = 04h */
+};
diff --git a/src/cpu/amd/family_10h-family_15h/fidvid.c b/src/cpu/amd/family_10h-family_15h/fidvid.c
new file mode 100644
index 0000000..5b1c581
--- /dev/null
+++ b/src/cpu/amd/family_10h-family_15h/fidvid.c
@@ -0,0 +1,1048 @@
+/*
+ * This file is part of the coreboot project.
+ *
+ * Copyright (C) 2007 Advanced Micro Devices, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.
+ */
+/*
+ * This file initializes the CPU cores for voltage and frequency settings
+ * in the different power states.
+ */
+/*
+
+checklist (functions are in this file if no source file named)
+Fam10 Bios and Kernel Development Guide #31116, rev 3.48, April 22, 2010
+
+2.4.2.6 Requirements for p-states
+
+1.- F3x[84:80] According to table 100 : prep_fid_change
+
+2.- COF/VID :
+     2.4.2.9.1 Steps 1,3-6 and warning for 2,7 if they apply
+               fixPsNbVidBeforeWR(...)
+     2.4.2.9.1 Step 8 enable_fid_change
+               We do this for all nodes, I don't understand BKDG 100% on
+               whether this is or isn't meant by "on the local
+               processor". Must be OK.
+     2.4.2.9.1 Steps 9-10 (repeat 1-7 and reset) romstage.c/init_cpus ?
+     2.4.2.9.1 Steps 11-12 init_fidvid_stage2
+     2.4.2.9.2 DualPlane PVI : Not supported, don't know how to detect,
+               needs specific circuitry.
+
+3.-  2.4.2.7 dualPlaneOnly(dev)
+
+4.-  2.4.2.8 applyBoostFIDOffset(dev)
+
+5.-  enableNbPState1(dev)
+
+6.- 2.4.1.7
+    a) UpdateSinglePlaneNbVid()
+    b) setVSRamp(), called from  prep_fid_change
+    c) prep_fid_change
+    d) improperly, for lack of voltage regulator details?,
+        F3xA0[PsiVidEn] in defaults.h
+        F3xA0[PsiVid] in init_cpus.c AMD_SetupPSIVID_d (before prep_fid_change)
+
+7.- TODO (Core Performance Boost is only available in revision E cpus, and we
+          don't seem to support those yet, at least they don't have any
+          constant in amddefs.h )
+
+8.- FIXME ? Transition to min Pstate according to 2.4.2.15.3 is required
+    by 2.4.2.6 after warm reset. But 2.4.2.15 states that it is not required
+    if the warm reset is issued by coreboot to update NbFid. So it is required
+    or not ? How can I tell who issued warm reset ?
+    Coreboot transitions to P0 instead, which is not recommended, and does
+    not follow 2.4.2.15.2 to do so.
+
+9.- TODO Requires information on current delivery capability
+    (depends on mainboard and maybe power supply ?). One might use a config
+    option with the maximum number of Amperes that the board can deliver to CPU.
+
+10.- [Multiprocessor] TODO 2.4.2.12
+     [Uniprocessor] FIXME ? We call setPStateMaxVal() in init_fidvid_stage2,
+     but not sure this is what is meant by "Determine the valid set of
+     P-states based on enabled P-states indicated
+     in MSRC001_00[68:64][PstateEn]" in 2.4.2.6-10
+
+11.- finalPstateChange() from init_fidvid_Stage2 (BKDG says just "may", anyway)
+
+12.- generate ACPI for p-states.
+     generated in powernow_acpi.c amd_generate_powernow()
+
+"must also be completed"
+
+a.-  PllLockTime set in ruleset in defaults.h
+     BKDG says set it "If MSRC001_00[68:64][CpuFid] is different between
+     any two enabled P-states", but since it does not say "only if"
+     I guess it is safe to do it always.
+
+b.-  prep_fid_change(...)
+
+ */
+
+#if CONFIG_SET_FIDVID
+
+#include <northbridge/amd/amdht/AsPsDefs.h>
+
+static inline void print_debug_fv(const char *str, u32 val)
+{
+#if CONFIG_SET_FIDVID_DEBUG
+	printk(BIOS_DEBUG, "%s%x\n", str, val);
+#endif
+}
+
+static inline void print_debug_fv_8(const char *str, u8 val)
+{
+#if CONFIG_SET_FIDVID_DEBUG
+	printk(BIOS_DEBUG, "%s%02x\n", str, val);
+#endif
+}
+
+static inline void print_debug_fv_64(const char *str, u32 val, u32 val2)
+{
+#if CONFIG_SET_FIDVID_DEBUG
+	printk(BIOS_DEBUG, "%s%x%x\n", str, val, val2);
+#endif
+}
+
+struct fidvid_st {
+	u32 common_fid;
+};
+
+static void enable_fid_change(u8 fid)
+{
+	u32 dword;
+	u32 nodes;
+	device_t dev;
+	int i;
+
+	nodes = get_nodes();
+
+	for (i = 0; i < nodes; i++) {
+		dev = NODE_PCI(i, 3);
+		dword = pci_read_config32(dev, 0xd4);
+		dword &= ~0x1F;
+		dword |= (u32) fid & 0x1F;
+		dword |= 1 << 5;	// enable
+		pci_write_config32(dev, 0xd4, dword);
+		printk(BIOS_DEBUG, "FID Change Node:%02x, F3xD4: %08x \n", i,
+		       dword);
+	}
+}
+
+static void applyBoostFIDOffset(  device_t dev ) {
+  // BKDG 2.4.2.8
+  // revision E only, but E is apparently not supported yet, therefore untested
+  if ((cpuid_edx(0x80000007) & CPB_MASK)
+      &&  ((cpuid_ecx(0x80000008) & NC_MASK) ==5) ) {
+      u32 core =  get_node_core_id_x().coreid;
+      u32 asymetricBoostThisCore = ((pci_read_config32(dev, 0x10C) >> (core*2))) & 3;
+      msr_t msr =  rdmsr(PS_REG_BASE);
+      u32 cpuFid = msr.lo & PS_CPU_FID_MASK;
+      cpuFid = cpuFid + asymetricBoostThisCore;
+      msr.lo &=   ~PS_CPU_FID_MASK;
+      msr.lo |= cpuFid ;
+      wrmsr(PS_REG_BASE , msr);
+
+  }
+}
+
+static void enableNbPState1( device_t dev ) {
+  u32 cpuRev =  mctGetLogicalCPUID(0xFF);
+  if (cpuRev & AMD_FAM10_C3) {
+    u32 nbPState = (pci_read_config32(dev, 0x1F0) & NB_PSTATE_MASK);
+    if ( nbPState){
+      u32 nbVid1 = (pci_read_config32(dev, 0x1F4) & NB_VID1_MASK) >> NB_VID1_SHIFT;
+      u32 i;
+      for (i = nbPState; i < NM_PS_REG; i++) {
+         msr_t msr =  rdmsr(PS_REG_BASE + i);
+         if (msr.hi &  PS_EN_MASK ) {
+            msr.hi |= NB_DID_M_ON;
+            msr.lo &= NB_VID_MASK_OFF;
+	    msr.lo |= ( nbVid1 << NB_VID_POS);
+	    wrmsr(PS_REG_BASE + i, msr);
+	 }
+      }
+    }
+  }
+}
+
+static u8 setPStateMaxVal( device_t dev ) {
+      u8 i,maxpstate=0;
+      for (i = 0; i < NM_PS_REG; i++) {
+         msr_t msr =  rdmsr(PS_REG_BASE + i);
+         if (msr.hi & PS_IDD_VALUE_MASK) {
+	   msr.hi |= PS_EN_MASK ;
+	     wrmsr(PS_REG_BASE + i, msr);
+	 }
+         if (msr.hi & PS_EN_MASK) {
+	   maxpstate = i;
+	 }
+      }
+      //FIXME: CPTC2 and HTC_REG should get max per node, not per core ?
+      u32 reg = pci_read_config32(dev, CPTC2);
+      reg &= PS_MAX_VAL_MASK;
+      reg |= (maxpstate << PS_MAX_VAL_POS);
+      pci_write_config32(dev, CPTC2,reg);
+      return maxpstate;
+}
+
+static void dualPlaneOnly(  device_t dev ) {
+  // BKDG 2.4.2.7
+
+  u32 cpuRev =  mctGetLogicalCPUID(0xFF);
+  if ((mctGetProcessorPackageType() ==  AMD_PKGTYPE_AM3_2r2)
+      && (cpuRev & AMD_DR_Cx)) { // should be rev C or rev E but there's no constant for E
+    if ( (pci_read_config32(dev, 0x1FC) & DUAL_PLANE_ONLY_MASK)
+	 && (pci_read_config32(dev, 0xA0) & PVI_MODE) ){
+      if (cpuid_edx(0x80000007) & CPB_MASK) {
+          // revision E only, but E is apparently not supported yet, therefore untested
+         msr_t minPstate = rdmsr(0xC0010065);
+         wrmsr(0xC0010065, rdmsr(0xC0010068) );
+         wrmsr(0xC0010068,minPstate);
+      } else {
+	 msr_t msr;
+         msr.lo=0; msr.hi=0;
+         wrmsr(0xC0010064, rdmsr(0xC0010068) );
+         wrmsr(0xC0010068, msr );
+      }
+
+      //FIXME: CPTC2 and HTC_REG should get max per node, not per core ?
+      u8 maxpstate = setPStateMaxVal(dev);
+
+      u32 reg = pci_read_config32(dev, HTC_REG);
+      reg &= HTC_PS_LMT_MASK;
+      reg |= (maxpstate << PS_LIMIT_POS);
+      pci_write_config32(dev, HTC_REG,reg);
+
+    }
+  }
+}
+
+static int vidTo100uV(u8 vid)
+{// returns voltage corresponding to vid in tenths of mV, i.e. hundreds of uV
+ // BKDG #31116 rev 3.48 2.4.1.6
+  int voltage;
+  if (vid >= 0x7c) {
+    voltage = 0;
+  } else {
+    voltage = (15500 - (125*vid));
+  }
+  return voltage;
+}
+
+static void setVSRamp(device_t dev) {
+	/* BKDG r31116 2010-04-22  2.4.1.7 step b F3xD8[VSRampTime]
+         * If this field accepts 8 values between 10 and 500 us why
+         * does page 324 say "BIOS should set this field to 001b."
+         * (20 us) ?
+         * Shouldn't it depend on the voltage regulators, mainboard
+         * or something ?
+         */
+        u32 dword;
+	dword = pci_read_config32(dev, 0xd8);
+	dword &= VSRAMP_MASK;
+	dword |= VSRAMP_VALUE;
+	pci_write_config32(dev, 0xd8, dword);
+}
+
+static void recalculateVsSlamTimeSettingOnCorePre(device_t dev)
+{
+	u8 pviModeFlag;
+	u8 highVoltageVid, lowVoltageVid, bValue;
+	u16 minimumSlamTime;
+	u16 vSlamTimes[7] = { 1000, 2000, 3000, 4000, 6000, 10000, 20000 };	/* Reg settings scaled by 100 */
+	u32 dtemp;
+	msr_t msr;
+
+	/* This function calculates the VsSlamTime using the range of possible
+	 * voltages instead of a hardcoded 200us.
+         * Note: his function is called only from prep_fid_change,
+         * and that from init_cpus.c finalize_node_setup()
+         * (after set AMD MSRs and init ht )
+	 */
+
+        /* BKDG r31116 2010-04-22  2.4.1.7 step b F3xD8[VSSlamTime] */
+	/* Calculate Slam Time
+	 * Vslam = (mobileCPU?0.2:0.4)us/mV * (Vp0 - (lowest out of Vpmin or Valt)) mV
+	 * In our case, we will scale the values by 100 to avoid
+	 * decimals.
+	 */
+
+	/* Determine if this is a PVI or SVI system */
+	dtemp = pci_read_config32(dev, 0xA0);
+
+	if (dtemp & PVI_MODE)
+		pviModeFlag = 1;
+	else
+		pviModeFlag = 0;
+
+	/* Get P0's voltage */
+        /* MSRC001_00[68:64] are not programmed yet when called from
+	   prep_fid_change, one might use F4x1[F0:E0] instead, but
+	   theoretically MSRC001_00[68:64] are equal to them after
+	   reset. */
+	msr = rdmsr(0xC0010064);
+	highVoltageVid = (u8) ((msr.lo >> PS_CPU_VID_SHFT) & 0x7F);
+        if (!(msr.hi & 0x80000000)) {
+  	    printk(BIOS_ERR,"P-state info in MSRC001_0064 is invalid !!!\n");
+            highVoltageVid = (u8) ((pci_read_config32(dev, 0x1E0)
+                                     >> PS_CPU_VID_SHFT) & 0x7F);
+	}
+
+	/* If SVI, we only care about CPU VID.
+	 * If PVI, determine the higher voltage b/t NB and CPU
+	 */
+	if (pviModeFlag) {
+		bValue = (u8) ((msr.lo >> PS_NB_VID_SHFT) & 0x7F);
+		if (highVoltageVid > bValue)
+			highVoltageVid = bValue;
+	}
+
+	/* Get PSmax's index */
+	msr = rdmsr(0xC0010061);
+	bValue = (u8) ((msr.lo >> PS_MAX_VAL_SHFT) & BIT_MASK_3);
+
+	/* Get PSmax's VID */
+	msr = rdmsr(0xC0010064 + bValue);
+	lowVoltageVid = (u8) ((msr.lo >> PS_CPU_VID_SHFT) & 0x7F);
+        if (!(msr.hi & 0x80000000)) {
+	    printk(BIOS_ERR,"P-state info in MSR%8x is invalid !!!\n",0xC0010064 + bValue);
+            lowVoltageVid = (u8) ((pci_read_config32(dev, 0x1E0+(bValue*4))
+                                     >> PS_CPU_VID_SHFT) & 0x7F);
+	}
+
+	/* If SVI, we only care about CPU VID.
+	 * If PVI, determine the higher voltage b/t NB and CPU
+         * BKDG 2.4.1.7 (a)
+ 	 */
+	if (pviModeFlag) {
+		bValue = (u8) ((msr.lo >> PS_NB_VID_SHFT) & 0x7F);
+		if (lowVoltageVid > bValue)
+			lowVoltageVid = bValue;
+	}
+
+	/* Get AltVID */
+	dtemp = pci_read_config32(dev, 0xDC);
+	bValue = (u8) (dtemp & BIT_MASK_7);
+
+	/* Use the VID with the lowest voltage (higher VID) */
+	if (lowVoltageVid < bValue)
+		lowVoltageVid = bValue;
+
+        u8 mobileFlag = get_platform_type() & AMD_PTYPE_MOB;
+	minimumSlamTime =  (mobileFlag?2:4) * (vidTo100uV(highVoltageVid) - vidTo100uV(lowVoltageVid)); /* * 0.01 us */
+
+
+	/* Now round up to nearest register setting.
+	 * Note that if we don't find a value, we
+	 * will fall through to a value of 7
+	 */
+	for (bValue = 0; bValue < 7; bValue++) {
+		if (minimumSlamTime <= vSlamTimes[bValue])
+			break;
+	}
+
+	/* Apply the value */
+	dtemp = pci_read_config32(dev, 0xD8);
+	dtemp &= VSSLAM_MASK;
+	dtemp |= bValue;
+	pci_write_config32(dev, 0xd8, dtemp);
+}
+
+static u32 nb_clk_did(int node, u32 cpuRev,u8 procPkg) {
+        u8 link0isGen3 = 0;
+        u8 offset;
+        if (AMD_CpuFindCapability(node, 0, &offset)) {
+	  link0isGen3 = (AMD_checkLinkType(node, 0, offset) & HTPHY_LINKTYPE_HT3 );
+	}
+        /* FIXME: NB_CLKDID should be 101b for AMD_DA_C2 in package
+           S1g3 in link Gen3 mode, but I don't know how to tell
+           package S1g3 from S1g4 */
+	if ((cpuRev & AMD_DA_C2) && (procPkg & AMD_PKGTYPE_S1gX)
+           && link0isGen3) {
+	  return 5 ; /* divide clk by 128*/
+        } else {
+	  return 4 ; /* divide clk by 16 */
+        }
+}
+
+
+static u32 power_up_down(int node, u8 procPkg) {
+       u32 dword=0;
+        /* from CPU rev guide #41322 rev 3.74 June 2010 Table 26 */
+        u8 singleLinkFlag = ((procPkg == AMD_PKGTYPE_AM3_2r2)
+                             || (procPkg == AMD_PKGTYPE_S1gX)
+                             || (procPkg == AMD_PKGTYPE_ASB2));
+
+        if (singleLinkFlag) {
+	  /*
+           * PowerStepUp=01000b - 50nS
+	   * PowerStepDown=01000b - 50ns
+	   */
+	  dword |= PW_STP_UP50 | PW_STP_DN50;
+	} else {
+          u32 dispRefModeEn = (pci_read_config32(NODE_PCI(node,0),0x68) >> 24) & 1;
+          u32 isocEn = 0;
+          int j;
+	  for(j=0 ; (j<4) && (!isocEn) ; j++ ) {
+	    u8 offset;
+	    if (AMD_CpuFindCapability(node, j, &offset)) {
+	      isocEn = (pci_read_config32(NODE_PCI(node,0),offset+4) >>12) & 1;
+	    }
+          }
+
+          if (dispRefModeEn || isocEn) {
+        	dword |= PW_STP_UP50 | PW_STP_DN50 ;
+          } else {
+		/* get number of cores for PowerStepUp & PowerStepDown in server
+		   1 core - 400nS  - 0000b
+		   2 cores - 200nS - 0010b
+		   3 cores - 133nS -> 100nS - 0011b
+		   4 cores - 100nS - 0011b
+		 */
+		switch (get_core_num_in_bsp(node)) {
+		case 0:
+			dword |= PW_STP_UP400 | PW_STP_DN400;
+			break;
+		case 1:
+		case 2:
+			dword |= PW_STP_UP200 | PW_STP_DN200;
+			break;
+		case 3:
+			dword |= PW_STP_UP100 | PW_STP_DN100;
+			break;
+		default:
+			dword |= PW_STP_UP100 | PW_STP_DN100;
+			break;
+		}
+	  }
+	}
+        return dword;
+}
+
+static void config_clk_power_ctrl_reg0(int node, u32 cpuRev, u8 procPkg) {
+       	device_t dev = NODE_PCI(node, 3);
+
+	/* Program fields in Clock Power/Control register0 (F3xD4) */
+
+	/* set F3xD4 Clock Power/Timing Control 0 Register
+	 * NbClkDidApplyAll=1b
+	 * NbClkDid=100b or 101b
+	 * PowerStepUp= "platform dependent"
+	 * PowerStepDown= "platform dependent"
+	 * LinkPllLink=01b
+	 * ClkRampHystCtl=HW default
+         * ClkRampHystSel=1111b
+	 */
+        u32 dword= pci_read_config32(dev, 0xd4);
+	dword &= CPTC0_MASK;
+        dword |= NB_CLKDID_ALL | LNK_PLL_LOCK | CLK_RAMP_HYST_SEL_VAL;
+        dword |= (nb_clk_did(node,cpuRev,procPkg) <<  NB_CLKDID_SHIFT);
+
+        dword |= power_up_down(node, procPkg);
+
+	pci_write_config32(dev, 0xd4, dword);
+
+}
+
+static void config_power_ctrl_misc_reg(device_t dev,u32 cpuRev, u8 procPkg) {
+	/* check PVI/SVI */
+	u32 dword = pci_read_config32(dev, 0xa0);
+
+	/* BKDG r31116 2010-04-22  2.4.1.7 step b F3xA0[VSSlamVidMod] */
+	/* PllLockTime and PsiVidEn set in ruleset in defaults.h */
+	if (dword & PVI_MODE) {	/* PVI */
+		/* set slamVidMode to 0 for PVI */
+		dword &= VID_SLAM_OFF ;
+	} else {	/* SVI */
+		/* set slamVidMode to 1 for SVI */
+		dword |= VID_SLAM_ON;
+	}
+        /* set the rest of A0 since we're at it... */
+
+	if (cpuRev & (AMD_DA_Cx | AMD_RB_C3 )) {
+		dword |= NB_PSTATE_FORCE_ON;
+	} // else should we clear it ?
+
+
+        if ((procPkg == AMD_PKGTYPE_G34) || (procPkg == AMD_PKGTYPE_C32) ) {
+		dword |= BP_INS_TRI_EN_ON ;
+	}
+
+	   /* TODO: look into C1E state and F3xA0[IdleExitEn]*/
+        #if CONFIG_SVI_HIGH_FREQ
+	if (cpuRev & AMD_FAM10_C3) {
+		dword |= SVI_HIGH_FREQ_ON;
+	}
+	#endif
+	pci_write_config32(dev, 0xa0, dword);
+}
+
+static void config_nb_syn_ptr_adj(device_t dev, u32 cpuRev) {
+	/* Note the following settings are additional from the ported
+	 * function setFidVidRegs()
+	 */
+        /* adjust FIFO between nb and core clocks to max allowed
+           values (min latency) */
+	u32 nbPstate = pci_read_config32(dev,0x1f0) & NB_PSTATE_MASK;
+        u8 nbSynPtrAdj;
+	if ((cpuRev & (AMD_DR_Bx|AMD_DA_Cx) )
+	    || ( (cpuRev & AMD_RB_C3) && (nbPstate!=0)))  {
+	  nbSynPtrAdj = 5;
+	} else {
+          nbSynPtrAdj = 6;
+	}
+
+	u32 dword = pci_read_config32(dev, 0xDc);
+        dword &= ~ NB_SYN_PTR_ADJ_MASK;
+	dword |= nbSynPtrAdj << NB_SYN_PTR_ADJ_POS;
+        /* NbsynPtrAdj set to 5 or 6 per BKDG (needs reset) */
+	pci_write_config32(dev, 0xdc, dword);
+}
+
+static void config_acpi_pwr_state_ctrl_regs(device_t dev, u32 cpuRev, u8 procPkg) {
+                /* step 1, chapter 2.4.2.6 of AMD Fam 10 BKDG #31116 Rev 3.48 22.4.2010 */
+        u32 dword;
+	u32 c1= 1;
+        if (cpuRev & (AMD_DR_Bx)) {
+            // will coreboot ever enable cache scrubbing ?
+            // if it does, will it be enough to check the current state
+            // or should we configure for what we'll set up later ?
+            dword = pci_read_config32(dev, 0x58);
+            u32 scrubbingCache = dword &
+	                        ( (0x1F << 16) // DCacheScrub
+		 	          | (0x1F << 8) ); // L2Scrub
+ 	    if (scrubbingCache) {
+	        c1 = 0x80;
+	    } else {
+	        c1 = 0xA0;
+	    }
+	} else { // rev C or later
+	    // same doubt as cache scrubbing: ok to check current state ?
+            dword = pci_read_config32(dev, 0xDC);
+            u32 cacheFlushOnHalt = dword & (7 << 16);
+            if (!cacheFlushOnHalt) {
+       	       c1 = 0x80;
+       	    }
+       	}
+       	dword = (c1 << 24) | (0xE641E6);
+	pci_write_config32(dev, 0x84, dword);
+
+
+        /* FIXME: BKDG Table 100 says if the link is at a Gen1
+frequency and the chipset does not support a 10us minimum LDTSTOP
+assertion time, then { If ASB2 && SVI then smaf001 = F6h else
+smaf001=87h. } else ...  I hardly know what it means or how to check
+it from here, so I bluntly assume it is false and code here the else,
+which is easier  */
+
+        u32 smaf001 = 0xE6;
+        if (cpuRev & AMD_DR_Bx ) {
+	    smaf001 = 0xA6;
+        } else {
+            #if CONFIG_SVI_HIGH_FREQ
+                if (cpuRev & (AMD_RB_C3 | AMD_DA_C3)) {
+		       smaf001 = 0xF6;
+                }
+            #endif
+        }
+        u32 fidvidChange = 0;
+        if (((cpuRev & AMD_DA_Cx) && (procPkg & AMD_PKGTYPE_S1gX))
+		    || (cpuRev & AMD_RB_C3) ) {
+                       fidvidChange=0x0B;
+        }
+	dword = (0xE6 << 24) | (fidvidChange << 16)
+                        | (smaf001 << 8) | 0x81;
+	pci_write_config32(dev, 0x80, dword);
+}
+
+static void prep_fid_change(void)
+{
+        u32 dword;
+	u32 nodes;
+	device_t dev;
+	int i;
+
+	/* This needs to be run before any Pstate changes are requested */
+
+	nodes = get_nodes();
+
+	for (i = 0; i < nodes; i++) {
+		printk(BIOS_DEBUG, "Prep FID/VID Node:%02x\n", i);
+		dev = NODE_PCI(i, 3);
+                u32 cpuRev = mctGetLogicalCPUID(0xFF) ;
+	        u8 procPkg =  mctGetProcessorPackageType();
+
+		setVSRamp(dev);
+		/* BKDG r31116 2010-04-22  2.4.1.7 step b F3xD8[VSSlamTime] */
+		/* Figure out the value for VsSlamTime and program it */
+		recalculateVsSlamTimeSettingOnCorePre(dev);
+
+		config_clk_power_ctrl_reg0(i,cpuRev,procPkg);
+
+                config_power_ctrl_misc_reg(dev,cpuRev,procPkg);
+		config_nb_syn_ptr_adj(dev,cpuRev);
+
+		config_acpi_pwr_state_ctrl_regs(dev,cpuRev,procPkg);
+
+		dword = pci_read_config32(dev, 0x80);
+		printk(BIOS_DEBUG, "  F3x80: %08x\n", dword);
+		dword = pci_read_config32(dev, 0x84);
+		printk(BIOS_DEBUG, "  F3x84: %08x\n", dword);
+		dword = pci_read_config32(dev, 0xD4);
+		printk(BIOS_DEBUG, "  F3xD4: %08x\n", dword);
+		dword = pci_read_config32(dev, 0xD8);
+		printk(BIOS_DEBUG, "  F3xD8: %08x\n", dword);
+		dword = pci_read_config32(dev, 0xDC);
+		printk(BIOS_DEBUG, "  F3xDC: %08x\n", dword);
+	}
+}
+
+static void waitCurrentPstate(u32 target_pstate){
+  msr_t initial_msr = rdmsr(TSC_MSR);
+  msr_t pstate_msr = rdmsr(CUR_PSTATE_MSR);
+  msr_t tsc_msr;
+  u8 timedout ;
+
+  /* paranoia ? I fear when we run fixPsNbVidBeforeWR we can enter a
+   * P1 that is a copy of P0, therefore has the same NB DID but the
+   * TSC will count twice per tick, so we have to wait for twice the
+   * count to achieve the desired timeout. But I'm likely to
+   * misunderstand this...
+   */
+  u32 corrected_timeout = (    (pstate_msr.lo==1)
+			    && (!(rdmsr(0xC0010065).lo & NB_DID_M_ON)) ) ?
+                          WAIT_PSTATE_TIMEOUT*2 : WAIT_PSTATE_TIMEOUT  ;
+  msr_t timeout;
+
+  timeout.lo = initial_msr.lo + corrected_timeout ;
+  timeout.hi = initial_msr.hi;
+  if ( (((u32)0xffffffff) - initial_msr.lo) < corrected_timeout ) {
+     timeout.hi++;
+  }
+
+  // assuming TSC ticks at 1.25 ns per tick (800 MHz)
+  do {
+      pstate_msr = rdmsr(CUR_PSTATE_MSR);
+      tsc_msr = rdmsr(TSC_MSR);
+      timedout = (tsc_msr.hi > timeout.hi)
+        	|| ((tsc_msr.hi == timeout.hi) && (tsc_msr.lo > timeout.lo ));
+  } while ( (pstate_msr.lo != target_pstate) && (! timedout) ) ;
+
+  if (pstate_msr.lo != target_pstate) {
+    msr_t limit_msr = rdmsr(0xc0010061);
+    printk(BIOS_ERR, "*** Time out waiting for P-state %01x. Current P-state %01x P-state current limit MSRC001_0061=%02x\n", target_pstate, pstate_msr.lo, limit_msr.lo);
+
+    do { // should we just go on instead ?
+      pstate_msr = rdmsr(CUR_PSTATE_MSR);
+    } while ( pstate_msr.lo != target_pstate  ) ;
+  }
+}
+
+static void set_pstate(u32 nonBoostedPState) {
+  	msr_t msr;
+
+	// Transition P0 for calling core.
+	msr = rdmsr(0xC0010062);
+
+	msr.lo = nonBoostedPState;
+	wrmsr(0xC0010062, msr);
+
+	/* Wait for P0 to set. */
+        waitCurrentPstate(nonBoostedPState);
+}
+
+
+
+
+static void UpdateSinglePlaneNbVid(void)
+{
+	u32 nbVid, cpuVid;
+	u8 i;
+	msr_t msr;
+
+	/* copy higher voltage (lower VID) of NBVID & CPUVID to both */
+	for (i = 0; i < 5; i++) {
+		msr = rdmsr(PS_REG_BASE + i);
+		nbVid = (msr.lo & PS_CPU_VID_M_ON) >> PS_CPU_VID_SHFT;
+		cpuVid = (msr.lo & PS_NB_VID_M_ON) >> PS_NB_VID_SHFT;
+
+		if (nbVid != cpuVid) {
+			if (nbVid > cpuVid)
+				nbVid = cpuVid;
+
+			msr.lo = msr.lo & PS_BOTH_VID_OFF;
+			msr.lo = msr.lo | (u32) ((nbVid) << PS_NB_VID_SHFT);
+			msr.lo = msr.lo | (u32) ((nbVid) << PS_CPU_VID_SHFT);
+			wrmsr(PS_REG_BASE + i, msr);
+		}
+	}
+}
+
+static void fixPsNbVidBeforeWR(u32 newNbVid, u32 coreid, u32 dev, u8 pviMode)
+ {
+ 	msr_t msr;
+ 	u8 startup_pstate;
+
+ 	/* This function sets NbVid before the warm reset.
+ 	 *       Get StartupPstate from MSRC001_0071.
+	 *       Read Pstate register pointed by [StartupPstate].
+ 	 *       and copy its content to P0 and P1 registers.
+ 	 *       Copy newNbVid to P0[NbVid].
+ 	 *       transition to P1 on all cores,
+ 	 *       then transition to P0 on core 0.
+ 	 *       Wait for MSRC001_0063[CurPstate] = 000b on core 0.
+         * see BKDG rev 3.48  2.4.2.9.1 BIOS NB COF and VID Configuration
+         *                              for SVI and Single-Plane PVI Systems
+ 	 */
+
+ 	msr = rdmsr(0xc0010071);
+	startup_pstate = (msr.hi >> (32 - 32)) & 0x07;
+
+	/* Copy startup pstate to P1 and P0 MSRs. Set the maxvid for
+	 * this node in P0.  Then transition to P1 for corex and P0
+	 * for core0.  These setting will be cleared by the warm reset
+	 */
+	msr = rdmsr(0xC0010064 + startup_pstate);
+	wrmsr(0xC0010065, msr);
+	wrmsr(0xC0010064, msr);
+
+        /* missing step 2 from BDKG , F3xDC[PstateMaxVal] =
+         * max(1,F3xDC[PstateMaxVal] ) because it would take
+         * synchronization between cores and we don't think
+         * PstatMaxVal is going to be 0 on cold reset anyway ?
+	 */
+        if ( ! (pci_read_config32(dev, 0xDC) & (~ PS_MAX_VAL_MASK)) ) {
+  	   printk(BIOS_ERR,"F3xDC[PstateMaxVal] is zero. Northbridge voltage setting will fail. fixPsNbVidBeforeWR in fidvid.c needs fixing. See AMD # 31116 rev 3.48 BKDG 2.4.2.9.1 \n");
+	};
+
+	msr.lo &= ~0xFE000000;	// clear nbvid
+	msr.lo |= (newNbVid << 25);
+	wrmsr(0xC0010064, msr);
+
+	if (pviMode) { /* single plane*/
+	  UpdateSinglePlaneNbVid();
+        }
+
+	// Transition to P1 for all APs and P0 for core0.
+        set_pstate(1);
+
+	if (coreid == 0) {
+             set_pstate(0);
+ 	}
+
+	/* missing step 7 (restore PstateMax to 0 if needed) because
+	 * we skipped step 2
+	 */
+
+}
+
+static u32 needs_NB_COF_VID_update(void)
+{
+	u8 nb_cof_vid_update;
+	u8 nodes;
+	u8 i;
+
+	/* If any node has nb_cof_vid_update set all nodes need an update. */
+	nodes = get_nodes();
+	nb_cof_vid_update = 0;
+	for (i = 0; i < nodes; i++) {
+                u32 cpuRev = mctGetLogicalCPUID(i) ;
+                u32 nbCofVidUpdateDefined = (cpuRev & (AMD_FAM10_LT_D));
+		if (nbCofVidUpdateDefined
+                    && (pci_read_config32(NODE_PCI(i, 3), 0x1FC)
+                        & NB_COF_VID_UPDATE_MASK)) {
+			nb_cof_vid_update = 1;
+			break;
+		}
+	}
+	return nb_cof_vid_update;
+}
+
+static u32 init_fidvid_core(u32 nodeid, u32 coreid)
+{
+	device_t dev;
+	u32 vid_max;
+	u32 fid_max = 0;
+	u8 nb_cof_vid_update = needs_NB_COF_VID_update();
+	u8 pvimode;
+	u32 reg1fc;
+
+	/* Steps 1-6 of BIOS NB COF and VID Configuration
+	 * for SVI and Single-Plane PVI Systems. BKDG 2.4.2.9 #31116 rev 3.48
+	 */
+
+	dev = NODE_PCI(nodeid, 3);
+	pvimode = pci_read_config32(dev, PW_CTL_MISC) & PVI_MODE;
+	reg1fc = pci_read_config32(dev, 0x1FC);
+
+	if (nb_cof_vid_update) {
+                vid_max = (reg1fc &  SINGLE_PLANE_NB_VID_MASK ) >>  SINGLE_PLANE_NB_VID_SHIFT ;
+	        fid_max = (reg1fc &  SINGLE_PLANE_NB_FID_MASK ) >>  SINGLE_PLANE_NB_FID_SHIFT ;
+
+	        if (!pvimode) { /* SVI, dual power plane */
+         		vid_max = vid_max - ((reg1fc &  DUAL_PLANE_NB_VID_OFF_MASK ) >>  DUAL_PLANE_NB_VID_SHIFT );
+			fid_max = fid_max +  ((reg1fc &  DUAL_PLANE_NB_FID_OFF_MASK ) >>  DUAL_PLANE_NB_FID_SHIFT );
+		}
+		/* write newNbVid to P-state Reg's NbVid always if NbVidUpdatedAll=1 */
+		fixPsNbVidBeforeWR(vid_max, coreid,dev,pvimode);
+
+		/* fid setup is handled by the BSP at the end. */
+
+	} else {	/* ! nb_cof_vid_update */
+		/* Use max values */
+		if (pvimode)
+			UpdateSinglePlaneNbVid();
+	}
+
+	return ((nb_cof_vid_update << 16) | (fid_max << 8));
+
+}
+
+static void init_fidvid_ap(u32 apicid, u32 nodeid, u32 coreid)
+{
+	u32 send;
+
+	printk(BIOS_DEBUG, "FIDVID on AP: %02x\n", apicid);
+
+        send = init_fidvid_core(nodeid,coreid);
+	send |= (apicid << 24);	// ap apicid
+
+	// Send signal to BSP about this AP max fid
+	// This also indicates this AP is ready for warm reset (if required).
+	lapic_write(LAPIC_MSG_REG, send | F10_APSTATE_RESET);
+}
+
+static u32 calc_common_fid(u32 fid_packed, u32 fid_packed_new)
+{
+	u32 fidmax;
+	u32 fidmax_new;
+
+	fidmax = (fid_packed >> 8) & 0xFF;
+
+	fidmax_new = (fid_packed_new >> 8) & 0xFF;
+
+	if (fidmax > fidmax_new) {
+		fidmax = fidmax_new;
+	}
+
+	fid_packed &= 0xFF << 16;
+	fid_packed |= (fidmax << 8);
+	fid_packed |= fid_packed_new & (0xFF << 16);	// set nb_cof_vid_update
+
+	return fid_packed;
+}
+
+static void init_fidvid_bsp_stage1(u32 ap_apicid, void *gp)
+{
+	u32 readback = 0;
+	u32 timeout = 1;
+
+	struct fidvid_st *fvp = gp;
+	int loop;
+
+	print_debug_fv("Wait for AP stage 1: ap_apicid = ", ap_apicid);
+
+	loop = 100000;
+	while (--loop > 0) {
+		if (lapic_remote_read(ap_apicid, LAPIC_MSG_REG, &readback) != 0)
+			continue;
+		if ((readback & 0x3f) == 1) {
+			timeout = 0;
+			break;	/* target ap is in stage 1 */
+		}
+	}
+
+	if (timeout) {
+		printk(BIOS_DEBUG, "%s: timed out reading from ap %02x\n",
+		       __func__, ap_apicid);
+		return;
+	}
+
+	print_debug_fv("\treadback = ", readback);
+
+	fvp->common_fid = calc_common_fid(fvp->common_fid, readback);
+
+	print_debug_fv("\tcommon_fid(packed) = ", fvp->common_fid);
+
+}
+
+static void fixPsNbVidAfterWR(u32 newNbVid, u8 NbVidUpdatedAll,u8 pviMode)
+{
+	msr_t msr;
+	u8 i;
+	u8 StartupPstate;
+
+	/* BKDG 2.4.2.9.1 11-12
+         * This function copies newNbVid to NbVid bits in P-state
+	 * Registers[4:0] if its NbDid bit=0, and IddValue!=0 in case of
+	 * NbVidUpdatedAll =0 or copies newNbVid to NbVid bits in
+	 * P-state Registers[4:0] if its IddValue!=0 in case of
+	 * NbVidUpdatedAll=1. Then transition to StartPstate.
+	 */
+
+	/* write newNbVid to P-state Reg's NbVid if its NbDid=0 */
+	for (i = 0; i < 5; i++) {
+		msr = rdmsr(0xC0010064 + i);
+		/*  NbDid (bit 22 of P-state Reg) == 0  or NbVidUpdatedAll = 1 */
+		if (   (msr.hi & PS_IDD_VALUE_MASK)
+                    && (msr.hi & PS_EN_MASK)
+                    &&(((msr.lo & PS_NB_DID_MASK) == 0) || NbVidUpdatedAll)) {
+			msr.lo &= PS_NB_VID_M_OFF;
+			msr.lo |= (newNbVid & 0x7F) << PS_NB_VID_SHFT;
+			wrmsr(0xC0010064 + i, msr);
+		}
+	}
+
+        /* Not documented. Would overwrite Nb_Vids just copied
+         * should we just update cpu_vid or nothing at all ?
+	 */
+	if (pviMode) { //single plane
+            UpdateSinglePlaneNbVid();
+	}
+	/* For each core in the system, transition all cores to StartupPstate */
+	msr = rdmsr(0xC0010071);
+	StartupPstate = msr.hi & 0x07;
+
+	/* Set and wait for StartupPstate to set. */
+        set_pstate(StartupPstate);
+
+}
+
+static void finalPstateChange(void)
+{
+	/* Enable P0 on all cores for best performance.
+	 * Linux can slow them down later if need be.
+	 * It is safe since they will be in C1 halt
+	 * most of the time anyway.
+	 */
+	set_pstate(0);
+}
+
+static void init_fidvid_stage2(u32 apicid, u32 nodeid)
+{
+	msr_t msr;
+	device_t dev;
+	u32 reg1fc;
+	u32 dtemp;
+	u32 nbvid;
+	u8 nb_cof_vid_update = needs_NB_COF_VID_update();
+	u8 NbVidUpdateAll;
+	u8 pvimode;
+
+	/* After warm reset finish the fid/vid setup for all cores. */
+
+	/* If any node has nb_cof_vid_update set all nodes need an update. */
+
+	dev = NODE_PCI(nodeid, 3);
+	pvimode = (pci_read_config32(dev, 0xA0) >> 8) & 1;
+	reg1fc = pci_read_config32(dev, 0x1FC);
+	nbvid = (reg1fc >> 7) & 0x7F;
+	NbVidUpdateAll = (reg1fc >> 1) & 1;
+
+	if (nb_cof_vid_update) {
+		if (!pvimode) {	/* SVI */
+			nbvid = nbvid - ((reg1fc >> 17) & 0x1F);
+		}
+		/* write newNbVid to P-state Reg's NbVid if its NbDid=0 */
+		fixPsNbVidAfterWR(nbvid, NbVidUpdateAll,pvimode);
+ 	} else {		/* !nb_cof_vid_update */
+		if (pvimode)
+			UpdateSinglePlaneNbVid();
+	}
+	dtemp = pci_read_config32(dev, 0xA0);
+	dtemp &= PLLLOCK_OFF;
+	dtemp |= PLLLOCK_DFT_L;
+	pci_write_config32(dev, 0xA0, dtemp);
+
+        dualPlaneOnly(dev);
+        applyBoostFIDOffset(dev);
+        enableNbPState1(dev);
+
+	finalPstateChange();
+
+	/* Set TSC to tick at the P0 ndfid rate */
+	msr = rdmsr(HWCR);
+	msr.lo |= 1 << 24;
+	wrmsr(HWCR, msr);
+}
+
+
+#if CONFIG_SET_FIDVID_STORE_AP_APICID_AT_FIRST
+struct ap_apicid_st {
+	u32 num;
+	// it could use 256 bytes for 64 node quad core system
+	u8 apicid[NODE_NUMS * 4];
+};
+
+static void store_ap_apicid(unsigned ap_apicid, void *gp)
+{
+	struct ap_apicid_st *p = gp;
+
+	p->apicid[p->num++] = ap_apicid;
+
+}
+#endif
+
+
+static int init_fidvid_bsp(u32 bsp_apicid, u32 nodes)
+{
+#if CONFIG_SET_FIDVID_STORE_AP_APICID_AT_FIRST
+	struct ap_apicid_st ap_apicidx;
+	u32 i;
+#endif
+	struct fidvid_st fv;
+
+	printk(BIOS_DEBUG, "FIDVID on BSP, APIC_id: %02x\n", bsp_apicid);
+
+	/* Steps 1-6 of BIOS NB COF and VID Configuration
+	 * for SVI and Single-Plane PVI Systems.
+	 */
+
+	fv.common_fid = init_fidvid_core(0,0);
+
+	print_debug_fv("BSP fid = ", fv.common_fid);
+
+#if CONFIG_SET_FIDVID_STORE_AP_APICID_AT_FIRST && !CONFIG_SET_FIDVID_CORE0_ONLY
+	/* For all APs (We know the APIC ID of all APs even when the APIC ID
+	   is lifted) remote read from AP LAPIC_MSG_REG about max fid.
+	   Then calculate the common max fid that can be used for all
+	   APs and BSP */
+	ap_apicidx.num = 0;
+
+	for_each_ap(bsp_apicid, CONFIG_SET_FIDVID_CORE_RANGE, store_ap_apicid, &ap_apicidx);
+
+	for (i = 0; i < ap_apicidx.num; i++) {
+		init_fidvid_bsp_stage1(ap_apicidx.apicid[i], &fv);
+	}
+#else
+	for_each_ap(bsp_apicid, CONFIG_SET_FIDVID_CORE0_ONLY, init_fidvid_bsp_stage1, &fv);
+#endif
+
+	print_debug_fv("common_fid = ", fv.common_fid);
+
+	if (fv.common_fid & (1 << 16)) {	/* check nb_cof_vid_update */
+
+		// Enable the common fid and other settings.
+		enable_fid_change((fv.common_fid >> 8) & 0x1F);
+
+		// nbfid change need warm reset, so reset at first
+		return 1;
+	}
+
+	return 0;		// No FID/VID changes. Don't reset
+}
+#endif
diff --git a/src/cpu/amd/family_10h-family_15h/init_cpus.c b/src/cpu/amd/family_10h-family_15h/init_cpus.c
new file mode 100644
index 0000000..8de6d25
--- /dev/null
+++ b/src/cpu/amd/family_10h-family_15h/init_cpus.c
@@ -0,0 +1,968 @@
+/*
+ * This file is part of the coreboot project.
+ *
+ * Copyright (C) 2007-2008 Advanced Micro Devices, Inc.
+ * Copyright (C) 2015 Timothy Pearson <tpearson@raptorengineeringinc.com>, Raptor Engineering
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.
+ */
+
+#include "cpu/amd/car/post_cache_as_ram.c"
+#include "defaults.h"
+#include <stdlib.h>
+#include <cpu/x86/lapic.h>
+#include <cpu/x86/mtrr.h>
+#include <northbridge/amd/amdfam10/amdfam10.h>
+#include <northbridge/amd/amdht/AsPsDefs.h>
+#include <northbridge/amd/amdht/porting.h>
+
+#include <northbridge/amd/amdfam10/raminit_amdmct.c>
+#include <reset.h>
+
+static void prep_fid_change(void);
+static void init_fidvid_stage2(u32 apicid, u32 nodeid);
+void cpuSetAMDMSR(void);
+
+#if CONFIG_PCI_IO_CFG_EXT
+static void set_EnableCf8ExtCfg(void)
+{
+	// set the NB_CFG[46]=1;
+	msr_t msr;
+	msr = rdmsr(NB_CFG_MSR);
+	// EnableCf8ExtCfg: We need that to access CONFIG_PCI_IO_CFG_EXT 4K range
+	msr.hi |= (1 << (46 - 32));
+	wrmsr(NB_CFG_MSR, msr);
+}
+#else
+static void set_EnableCf8ExtCfg(void) { }
+#endif
+
+
+typedef void (*process_ap_t) (u32 apicid, void *gp);
+
+//core_range = 0 : all cores
+//core range = 1 : core 0 only
+//core range = 2 : cores other than core0
+
+static void for_each_ap(u32 bsp_apicid, u32 core_range, process_ap_t process_ap,
+			void *gp)
+{
+	// here assume the OS don't change our apicid
+	u32 ap_apicid;
+
+	u32 nodes;
+	u32 siblings;
+	u32 disable_siblings;
+	u32 cores_found;
+	u32 nb_cfg_54;
+	int i, j;
+	u32 ApicIdCoreIdSize;
+	uint8_t rev_gte_d = 0;
+	uint8_t dual_node = 0;
+	uint32_t f3xe8;
+
+	/* get_nodes define in ht_wrapper.c */
+	nodes = get_nodes();
+
+	if (!CONFIG_LOGICAL_CPUS ||
+	    read_option(multi_core, 0) != 0) {	// 0 means multi core
+		disable_siblings = 1;
+	} else {
+		disable_siblings = 0;
+	}
+
+	/* Assume that all node are same stepping, otherwise we can use use
+	   nb_cfg_54 from bsp for all nodes */
+	nb_cfg_54 = read_nb_cfg_54();
+	f3xe8 = pci_read_config32(NODE_PCI(0, 3), 0xe8);
+
+	if (cpuid_eax(0x80000001) >= 0x8)
+		/* Revision D or later */
+		rev_gte_d = 1;
+
+	if (rev_gte_d)
+		 /* Check for dual node capability */
+		if (f3xe8 & 0x20000000)
+			dual_node = 1;
+
+	ApicIdCoreIdSize = (cpuid_ecx(0x80000008) >> 12 & 0xf);
+	if (ApicIdCoreIdSize) {
+		siblings = ((1 << ApicIdCoreIdSize) - 1);
+	} else {
+		siblings = 3;	//quad core
+	}
+
+	for (i = 0; i < nodes; i++) {
+		cores_found = get_core_num_in_bsp(i);
+		if (siblings > cores_found)
+			siblings = cores_found;
+
+		u32 jstart, jend;
+
+		if (core_range == 2) {
+			jstart = 1;
+		} else {
+			jstart = 0;
+		}
+
+		if (disable_siblings || (core_range == 1)) {
+			jend = 0;
+		} else {
+			jend = cores_found;
+		}
+
+		for (j = jstart; j <= jend; j++) {
+			if (dual_node) {
+				ap_apicid = 0;
+				if (nb_cfg_54) {
+					ap_apicid |= ((i >> 1) & 0x3) << 4;			/* Node ID */
+					ap_apicid |= ((i & 0x1) * (siblings + 1)) + j;		/* Core ID */
+				} else {
+					ap_apicid |= i & 0x3;					/* Node ID */
+					ap_apicid |= (((i & 0x1) * (siblings + 1)) + j) << 4;	/* Core ID */
+				}
+			} else {
+				ap_apicid =
+				i * (nb_cfg_54 ? (siblings + 1) : 1) +
+				j * (nb_cfg_54 ? 1 : 64);
+			}
+
+
+#if CONFIG_ENABLE_APIC_EXT_ID && (CONFIG_APIC_ID_OFFSET > 0)
+#if !CONFIG_LIFT_BSP_APIC_ID
+			if ((i != 0) || (j != 0))	/* except bsp */
+#endif
+				ap_apicid += CONFIG_APIC_ID_OFFSET;
+#endif
+
+			if (ap_apicid == bsp_apicid)
+				continue;
+
+			process_ap(ap_apicid, gp);
+
+		}
+	}
+}
+
+static inline int lapic_remote_read(int apicid, int reg, u32 *pvalue)
+{
+	int timeout;
+	u32 status;
+	int result;
+	lapic_wait_icr_idle();
+	lapic_write(LAPIC_ICR2, SET_LAPIC_DEST_FIELD(apicid));
+	lapic_write(LAPIC_ICR, LAPIC_DM_REMRD | (reg >> 4));
+
+/* Extra busy check compared to lapic.h */
+	timeout = 0;
+	do {
+		status = lapic_read(LAPIC_ICR) & LAPIC_ICR_BUSY;
+	} while (status == LAPIC_ICR_BUSY && timeout++ < 1000);
+
+	timeout = 0;
+	do {
+		status = lapic_read(LAPIC_ICR) & LAPIC_ICR_RR_MASK;
+	} while (status == LAPIC_ICR_RR_INPROG && timeout++ < 1000);
+
+	result = -1;
+
+	if (status == LAPIC_ICR_RR_VALID) {
+		*pvalue = lapic_read(LAPIC_RRR);
+		result = 0;
+	}
+	return result;
+}
+
+#if CONFIG_SET_FIDVID
+static void init_fidvid_ap(u32 apicid, u32 nodeid, u32 coreid);
+#endif
+
+static inline __attribute__ ((always_inline))
+void print_apicid_nodeid_coreid(u32 apicid, struct node_core_id id,
+				const char *str)
+{
+	printk(BIOS_DEBUG,
+	       "%s --- { APICID = %02x NODEID = %02x COREID = %02x} ---\n", str,
+	       apicid, id.nodeid, id.coreid);
+}
+
+static u32 wait_cpu_state(u32 apicid, u32 state)
+{
+	u32 readback = 0;
+	u32 timeout = 1;
+	int loop = 4000000;
+	while (--loop > 0) {
+		if (lapic_remote_read(apicid, LAPIC_MSG_REG, &readback) != 0)
+			continue;
+		if ((readback & 0x3f) == state || (readback & 0x3f) == F10_APSTATE_RESET) {
+			timeout = 0;
+			break;	//target cpu is in stage started
+		}
+	}
+	if (timeout) {
+		if (readback) {
+			timeout = readback;
+		}
+	}
+
+	return timeout;
+}
+
+static void wait_ap_started(u32 ap_apicid, void *gp)
+{
+	u32 timeout;
+	timeout = wait_cpu_state(ap_apicid, F10_APSTATE_STARTED);
+	printk(BIOS_DEBUG, "* AP %02x", ap_apicid);
+	if (timeout) {
+		printk(BIOS_DEBUG, " timed out:%08x\n", timeout);
+	} else {
+		printk(BIOS_DEBUG, "started\n");
+	}
+}
+
+void wait_all_other_cores_started(u32 bsp_apicid)
+{
+	// all aps other than core0
+	printk(BIOS_DEBUG, "started ap apicid: ");
+	for_each_ap(bsp_apicid, 2, wait_ap_started, (void *)0);
+	printk(BIOS_DEBUG, "\n");
+}
+
+void allow_all_aps_stop(u32 bsp_apicid)
+{
+	/* Called by the BSP to indicate AP can stop */
+
+	/* FIXME Do APs use this? */
+
+	// allow aps to stop use 6 bits for state
+	lapic_write(LAPIC_MSG_REG, (bsp_apicid << 24) | F10_APSTATE_STOPPED);
+}
+
+static void enable_apic_ext_id(u32 node)
+{
+	u32 val;
+
+	val = pci_read_config32(NODE_HT(node), 0x68);
+	val |= (HTTC_APIC_EXT_SPUR | HTTC_APIC_EXT_ID | HTTC_APIC_EXT_BRD_CST);
+	pci_write_config32(NODE_HT(node), 0x68, val);
+}
+
+static void STOP_CAR_AND_CPU(void)
+{
+	msr_t msr;
+
+	/* Disable L2 IC to L3 connection (Only for CAR) */
+	msr = rdmsr(BU_CFG2);
+	msr.lo &= ~(1 << ClLinesToNbDis);
+	wrmsr(BU_CFG2, msr);
+
+	disable_cache_as_ram();	// inline
+	/* stop all cores except node0/core0 the bsp .... */
+	stop_this_cpu();
+}
+
+static u32 init_cpus(u32 cpu_init_detectedx, struct sys_info *sysinfo)
+{
+	u32 bsp_apicid = 0;
+	u32 apicid;
+	struct node_core_id id;
+
+	/* Please refer to the calculations and explaination in cache_as_ram.inc before modifying these values */
+	uint32_t max_ap_stack_region_size = CONFIG_MAX_CPUS * CONFIG_DCACHE_AP_STACK_SIZE;
+	uint32_t max_bsp_stack_region_size = CONFIG_DCACHE_BSP_STACK_SIZE + CONFIG_DCACHE_BSP_STACK_SLUSH;
+	uint32_t bsp_stack_region_upper_boundary = CONFIG_DCACHE_RAM_BASE + CONFIG_DCACHE_RAM_SIZE;
+	uint32_t bsp_stack_region_lower_boundary = bsp_stack_region_upper_boundary - max_bsp_stack_region_size;
+	void * lower_stack_region_boundary = (void*)(bsp_stack_region_lower_boundary - max_ap_stack_region_size);
+	if (((void*)(sysinfo + 1)) > lower_stack_region_boundary)
+		printk(BIOS_WARNING,
+			"sysinfo extends into stack region (sysinfo range: [%p,%p] lower stack region boundary: %p)\n",
+			sysinfo, sysinfo + 1, lower_stack_region_boundary);
+
+	/*
+	 * already set early mtrr in cache_as_ram.inc
+	 */
+
+	/* that is from initial apicid, we need nodeid and coreid
+	   later */
+	id = get_node_core_id_x();
+
+	/* NB_CFG MSR is shared between cores, so we need make sure
+	   core0 is done at first --- use wait_all_core0_started  */
+	if (id.coreid == 0) {
+		set_apicid_cpuid_lo();	/* only set it on core0 */
+		set_EnableCf8ExtCfg();	/* only set it on core0 */
+#if CONFIG_ENABLE_APIC_EXT_ID
+		enable_apic_ext_id(id.nodeid);
+#endif
+	}
+
+	enable_lapic();
+
+#if CONFIG_ENABLE_APIC_EXT_ID && (CONFIG_APIC_ID_OFFSET > 0)
+	u32 initial_apicid = get_initial_apicid();
+
+#if !CONFIG_LIFT_BSP_APIC_ID
+	if (initial_apicid != 0)	// other than bsp
+#endif
+	{
+		/* use initial apic id to lift it */
+		u32 dword = lapic_read(LAPIC_ID);
+		dword &= ~(0xff << 24);
+		dword |=
+		    (((initial_apicid + CONFIG_APIC_ID_OFFSET) & 0xff) << 24);
+
+		lapic_write(LAPIC_ID, dword);
+	}
+#if CONFIG_LIFT_BSP_APIC_ID
+	bsp_apicid += CONFIG_APIC_ID_OFFSET;
+#endif
+
+#endif
+
+	/* get the apicid, it may be lifted already */
+	apicid = lapicid();
+
+	// show our apicid, nodeid, and coreid
+	if (id.coreid == 0) {
+		if (id.nodeid != 0)	//all core0 except bsp
+			print_apicid_nodeid_coreid(apicid, id, " core0: ");
+	} else {		//all other cores
+		print_apicid_nodeid_coreid(apicid, id, " corex: ");
+	}
+
+	if (cpu_init_detectedx) {
+		print_apicid_nodeid_coreid(apicid, id,
+					   "\n\n\nINIT detected from ");
+		printk(BIOS_DEBUG, "\nIssuing SOFT_RESET...\n");
+		soft_reset();
+	}
+
+	if (id.coreid == 0) {
+		if (!(warm_reset_detect(id.nodeid)))	//FIXME: INIT is checked above but check for more resets?
+			distinguish_cpu_resets(id.nodeid);	// Also indicates we are started
+	}
+	// Mark the core as started.
+	lapic_write(LAPIC_MSG_REG, (apicid << 24) | F10_APSTATE_STARTED);
+
+	if (apicid != bsp_apicid) {
+		/* Setup each AP's cores MSRs.
+		 * This happens after HTinit.
+		 * The BSP runs this code in it's own path.
+		 */
+		update_microcode(cpuid_eax(1));
+
+		cpuSetAMDMSR();
+
+#if CONFIG_SET_FIDVID
+#if CONFIG_LOGICAL_CPUS && CONFIG_SET_FIDVID_CORE0_ONLY
+		// Run on all AP for proper FID/VID setup.
+		if (id.coreid == 0)	// only need set fid for core0
+#endif
+		{
+			// check warm(bios) reset to call stage2 otherwise do stage1
+			if (warm_reset_detect(id.nodeid)) {
+				printk(BIOS_DEBUG,
+				       "init_fidvid_stage2 apicid: %02x\n",
+				       apicid);
+				init_fidvid_stage2(apicid, id.nodeid);
+			} else {
+				printk(BIOS_DEBUG,
+				       "init_fidvid_ap(stage1) apicid: %02x\n",
+				       apicid);
+				init_fidvid_ap(apicid, id.nodeid, id.coreid);
+			}
+		}
+#endif
+
+		/* AP is ready, configure MTRRs and go to sleep */
+		set_var_mtrr(0, 0x00000000, CONFIG_RAMTOP, MTRR_TYPE_WRBACK);
+
+		STOP_CAR_AND_CPU();
+
+		printk(BIOS_DEBUG,
+		       "\nAP %02x should be halted but you are reading this....\n",
+		       apicid);
+	}
+
+	return bsp_apicid;
+}
+
+static u32 is_core0_started(u32 nodeid)
+{
+	u32 htic;
+	device_t device;
+	device = NODE_PCI(nodeid, 0);
+	htic = pci_read_config32(device, HT_INIT_CONTROL);
+	htic &= HTIC_ColdR_Detect;
+	return htic;
+}
+
+void wait_all_core0_started(void)
+{
+	/* When core0 is started, it will distingush_cpu_resets
+	 * So wait for that to finish */
+	u32 i;
+	u32 nodes = get_nodes();
+
+	printk(BIOS_DEBUG, "core0 started: ");
+	for (i = 1; i < nodes; i++) {	// skip bsp, because it is running on bsp
+		while (!is_core0_started(i)) {
+		}
+		printk(BIOS_DEBUG, " %02x", i);
+	}
+	printk(BIOS_DEBUG, "\n");
+}
+
+#if CONFIG_MAX_PHYSICAL_CPUS > 1
+/**
+ * void start_node(u32 node)
+ *
+ *  start the core0 in node, so it can generate HT packet to feature code.
+ *
+ * This function starts the AP nodes core0s. wait_all_core0_started() in
+ * romstage.c waits for all the AP to be finished before continuing
+ * system init.
+ */
+static void start_node(u8 node)
+{
+	u32 val;
+
+	/* Enable routing table */
+	printk(BIOS_DEBUG, "Start node %02x", node);
+
+#if CONFIG_NORTHBRIDGE_AMD_AMDFAM10
+	/* For FAM10 support, we need to set Dram base/limit for the new node */
+	pci_write_config32(NODE_MP(node), 0x44, 0);
+	pci_write_config32(NODE_MP(node), 0x40, 3);
+#endif
+
+	/* Allow APs to make requests (ROM fetch) */
+	val = pci_read_config32(NODE_HT(node), 0x6c);
+	val &= ~(1 << 1);
+	pci_write_config32(NODE_HT(node), 0x6c, val);
+
+	printk(BIOS_DEBUG, " done.\n");
+}
+
+/**
+ * static void setup_remote_node(u32 node)
+ *
+ * Copy the BSP Address Map to each AP.
+ */
+static void setup_remote_node(u8 node)
+{
+	/* There registers can be used with F1x114_x Address Map at the
+	   same time, So must set them even 32 node */
+	static const u16 pci_reg[] = {
+		/* DRAM Base/Limits Registers */
+		0x44, 0x4c, 0x54, 0x5c, 0x64, 0x6c, 0x74, 0x7c,
+		0x40, 0x48, 0x50, 0x58, 0x60, 0x68, 0x70, 0x78,
+		0x144, 0x14c, 0x154, 0x15c, 0x164, 0x16c, 0x174, 0x17c,
+		0x140, 0x148, 0x150, 0x158, 0x160, 0x168, 0x170, 0x178,
+		/* MMIO Base/Limits Registers */
+		0x84, 0x8c, 0x94, 0x9c, 0xa4, 0xac, 0xb4, 0xbc,
+		0x80, 0x88, 0x90, 0x98, 0xa0, 0xa8, 0xb0, 0xb8,
+		/* IO Base/Limits Registers */
+		0xc4, 0xcc, 0xd4, 0xdc,
+		0xc0, 0xc8, 0xd0, 0xd8,
+		/* Configuration Map Registers */
+		0xe0, 0xe4, 0xe8, 0xec,
+	};
+	u16 i;
+
+	printk(BIOS_DEBUG, "setup_remote_node: %02x", node);
+
+	/* copy the default resource map from node 0 */
+	for (i = 0; i < ARRAY_SIZE(pci_reg); i++) {
+		u32 value;
+		u16 reg;
+		reg = pci_reg[i];
+		value = pci_read_config32(NODE_MP(0), reg);
+		pci_write_config32(NODE_MP(node), reg, value);
+
+	}
+	printk(BIOS_DEBUG, " done\n");
+}
+#endif				/* CONFIG_MAX_PHYSICAL_CPUS > 1 */
+
+static void AMD_Errata281(u8 node, u32 revision, u32 platform)
+{
+	/* Workaround for Transaction Scheduling Conflict in
+	 * Northbridge Cross Bar.  Implement XCS Token adjustment
+	 * for ganged links.  Also, perform fix up for the mixed
+	 * revision case.
+	 */
+
+	u32 reg, val;
+	u8 i;
+	u8 mixed = 0;
+	u8 nodes = get_nodes();
+
+	if (platform & AMD_PTYPE_SVR) {
+		/* For each node we need to check for a "broken" node */
+		if (!(revision & (AMD_DR_B0 | AMD_DR_B1))) {
+			for (i = 0; i < nodes; i++) {
+				if (mctGetLogicalCPUID(i) &
+				    (AMD_DR_B0 | AMD_DR_B1)) {
+					mixed = 1;
+					break;
+				}
+			}
+		}
+
+		if ((revision & (AMD_DR_B0 | AMD_DR_B1)) || mixed) {
+
+			/* F0X68[22:21] DsNpReqLmt0 = 01b */
+			val = pci_read_config32(NODE_PCI(node, 0), 0x68);
+			val &= ~0x00600000;
+			val |= 0x00200000;
+			pci_write_config32(NODE_PCI(node, 0), 0x68, val);
+
+			/* F3X6C */
+			val = pci_read_config32(NODE_PCI(node, 3), 0x6C);
+			val &= ~0x700780F7;
+			val |= 0x00010094;
+			pci_write_config32(NODE_PCI(node, 3), 0x6C, val);
+
+			/* F3X7C */
+			val = pci_read_config32(NODE_PCI(node, 3), 0x7C);
+			val &= ~0x707FFF1F;
+			val |= 0x00144514;
+			pci_write_config32(NODE_PCI(node, 3), 0x7C, val);
+
+			/* F3X144[3:0] RspTok = 0001b */
+			val = pci_read_config32(NODE_PCI(node, 3), 0x144);
+			val &= ~0x0000000F;
+			val |= 0x00000001;
+			pci_write_config32(NODE_PCI(node, 3), 0x144, val);
+
+			for (i = 0; i < 3; i++) {
+				reg = 0x148 + (i * 4);
+				val = pci_read_config32(NODE_PCI(node, 3), reg);
+				val &= ~0x000000FF;
+				val |= 0x000000DB;
+				pci_write_config32(NODE_PCI(node, 3), reg, val);
+			}
+		}
+	}
+}
+
+static void AMD_Errata298(void)
+{
+	/* Workaround for L2 Eviction May Occur during operation to
+	 * set Accessed or dirty bit.
+	 */
+
+	msr_t msr;
+	u8 i;
+	u8 affectedRev = 0;
+	u8 nodes = get_nodes();
+
+	/* For each core we need to check for a "broken" node */
+	for (i = 0; i < nodes; i++) {
+		if (mctGetLogicalCPUID(i) & (AMD_DR_B0 | AMD_DR_B1 | AMD_DR_B2)) {
+			affectedRev = 1;
+			break;
+		}
+	}
+
+	if (affectedRev) {
+		msr = rdmsr(HWCR);
+		msr.lo |= 0x08;	/* Set TlbCacheDis bit[3] */
+		wrmsr(HWCR, msr);
+
+		msr = rdmsr(BU_CFG);
+		msr.lo |= 0x02;	/* Set TlbForceMemTypeUc bit[1] */
+		wrmsr(BU_CFG, msr);
+
+		msr = rdmsr(OSVW_ID_Length);
+		msr.lo |= 0x01;	/* OS Visible Workaround - MSR */
+		wrmsr(OSVW_ID_Length, msr);
+
+		msr = rdmsr(OSVW_Status);
+		msr.lo |= 0x01;	/* OS Visible Workaround - MSR */
+		wrmsr(OSVW_Status, msr);
+	}
+
+	if (!affectedRev && (mctGetLogicalCPUID(0xFF) & AMD_DR_B3)) {
+		msr = rdmsr(OSVW_ID_Length);
+		msr.lo |= 0x01;	/* OS Visible Workaround - MSR */
+		wrmsr(OSVW_ID_Length, msr);
+
+	}
+}
+
+static u32 get_platform_type(void)
+{
+	u32 ret = 0;
+
+	switch (SYSTEM_TYPE) {
+	case 1:
+		ret |= AMD_PTYPE_DSK;
+		break;
+	case 2:
+		ret |= AMD_PTYPE_MOB;
+		break;
+	case 0:
+		ret |= AMD_PTYPE_SVR;
+		break;
+	default:
+		break;
+	}
+
+	/* FIXME: add UMA support. */
+
+	/* All Fam10 are multi core */
+	ret |= AMD_PTYPE_MC;
+
+	return ret;
+}
+
+static void AMD_SetupPSIVID_d(u32 platform_type, u8 node)
+{
+	u32 dword;
+	int i;
+	msr_t msr;
+
+	if (platform_type & (AMD_PTYPE_MOB | AMD_PTYPE_DSK)) {
+
+		/* The following code sets the PSIVID to the lowest support P state
+		 * assuming that the VID for the lowest power state is below
+		 * the VDD voltage regulator threshold. (This also assumes that there
+		 * is a Pstate lower than P0)
+		 */
+
+		for (i = 4; i >= 0; i--) {
+			msr = rdmsr(PS_REG_BASE + i);
+			/*  Pstate valid? */
+			if (msr.hi & PS_EN_MASK) {
+				dword = pci_read_config32(NODE_PCI(i, 3), 0xA0);
+				dword &= ~0x7F;
+				dword |= (msr.lo >> 9) & 0x7F;
+				pci_write_config32(NODE_PCI(i, 3), 0xA0, dword);
+				break;
+			}
+		}
+	}
+}
+
+/**
+ * AMD_CpuFindCapability - Traverse PCI capability list to find host HT links.
+ *  HT Phy operations are not valid on links that aren't present, so this
+ *  prevents invalid accesses.
+ *
+ * Returns the offset of the link register.
+ */
+static BOOL AMD_CpuFindCapability(u8 node, u8 cap_count, u8 * offset)
+{
+	u32 reg;
+	u32 val;
+
+	/* get start of CPU HT Host Capabilities */
+	val = pci_read_config32(NODE_PCI(node, 0), 0x34);
+	val &= 0xFF;		//reg offset of first link
+
+	cap_count++;
+
+	/* Traverse through the capabilities. */
+	do {
+		reg = pci_read_config32(NODE_PCI(node, 0), val);
+		/* Is the capability block a HyperTransport capability block? */
+		if ((reg & 0xFF) == 0x08) {
+			/* Is the HT capability block an HT Host Capability? */
+			if ((reg & 0xE0000000) == (1 << 29))
+				cap_count--;
+		}
+
+		if (cap_count)
+			val = (reg >> 8) & 0xFF;	//update reg offset
+	} while (cap_count && val);
+
+	*offset = (u8) val;
+
+	/* If requested capability found val != 0 */
+	if (!cap_count)
+		return TRUE;
+	else
+		return FALSE;
+}
+
+/**
+ * AMD_checkLinkType - Compare desired link characteristics using a logical
+ *     link type mask.
+ *
+ * Returns the link characteristic mask.
+ */
+static u32 AMD_checkLinkType(u8 node, u8 link, u8 regoff)
+{
+	u32 val;
+	u32 linktype = 0;
+
+	/* Check connect, init and coherency */
+	val = pci_read_config32(NODE_PCI(node, 0), regoff + 0x18);
+	val &= 0x1F;
+
+	if (val == 3)
+		linktype |= HTPHY_LINKTYPE_COHERENT;
+
+	if (val == 7)
+		linktype |= HTPHY_LINKTYPE_NONCOHERENT;
+
+	if (linktype) {
+		/* Check gen3 */
+		val = pci_read_config32(NODE_PCI(node, 0), regoff + 0x08);
+
+		if (((val >> 8) & 0x0F) > 6)
+			linktype |= HTPHY_LINKTYPE_HT3;
+		else
+			linktype |= HTPHY_LINKTYPE_HT1;
+
+		/* Check ganged */
+		val = pci_read_config32(NODE_PCI(node, 0), (link << 2) + 0x170);
+
+		if (val & 1)
+			linktype |= HTPHY_LINKTYPE_GANGED;
+		else
+			linktype |= HTPHY_LINKTYPE_UNGANGED;
+	}
+	return linktype;
+}
+
+/**
+ * AMD_SetHtPhyRegister - Use the HT link's HT Phy portal registers to update
+ *   a phy setting for that link.
+ */
+static void AMD_SetHtPhyRegister(u8 node, u8 link, u8 entry)
+{
+	u32 phyReg;
+	u32 phyBase;
+	u32 val;
+
+	/* Determine this link's portal */
+	if (link > 3)
+		link -= 4;
+
+	phyBase = ((u32) link << 3) | 0x180;
+
+	/* Get the portal control register's initial value
+	 * and update it to access the desired phy register
+	 */
+	phyReg = pci_read_config32(NODE_PCI(node, 4), phyBase);
+
+	if (fam10_htphy_default[entry].htreg > 0x1FF) {
+		phyReg &= ~HTPHY_DIRECT_OFFSET_MASK;
+		phyReg |= HTPHY_DIRECT_MAP;
+	} else {
+		phyReg &= ~HTPHY_OFFSET_MASK;
+	}
+
+	/* Now get the current phy register data
+	 * LinkPhyDone = 0, LinkPhyWrite = 0 is a read
+	 */
+	phyReg |= fam10_htphy_default[entry].htreg;
+	pci_write_config32(NODE_PCI(node, 4), phyBase, phyReg);
+
+	do {
+		val = pci_read_config32(NODE_PCI(node, 4), phyBase);
+	} while (!(val & HTPHY_IS_COMPLETE_MASK));
+
+	/* Now we have the phy register data, apply the change */
+	val = pci_read_config32(NODE_PCI(node, 4), phyBase + 4);
+	val &= ~fam10_htphy_default[entry].mask;
+	val |= fam10_htphy_default[entry].data;
+	pci_write_config32(NODE_PCI(node, 4), phyBase + 4, val);
+
+	/* write it through the portal to the phy
+	 * LinkPhyDone = 0, LinkPhyWrite = 1 is a write
+	 */
+	phyReg |= HTPHY_WRITE_CMD;
+	pci_write_config32(NODE_PCI(node, 4), phyBase, phyReg);
+
+	do {
+		val = pci_read_config32(NODE_PCI(node, 4), phyBase);
+	} while (!(val & HTPHY_IS_COMPLETE_MASK));
+}
+
+void cpuSetAMDMSR(void)
+{
+	/* This routine loads the CPU with default settings in fam10_msr_default
+	 * table . It must be run after Cache-As-RAM has been enabled, and
+	 * Hypertransport initialization has taken place.  Also note
+	 * that it is run on the current processor only, and only for the current
+	 * processor core.
+	 */
+	msr_t msr;
+	u8 i;
+	u32 revision, platform;
+
+	printk(BIOS_DEBUG, "cpuSetAMDMSR ");
+
+	revision = mctGetLogicalCPUID(0xFF);
+	platform = get_platform_type();
+
+	for (i = 0; i < ARRAY_SIZE(fam10_msr_default); i++) {
+		if ((fam10_msr_default[i].revision & revision) &&
+		    (fam10_msr_default[i].platform & platform)) {
+			msr = rdmsr(fam10_msr_default[i].msr);
+			msr.hi &= ~fam10_msr_default[i].mask_hi;
+			msr.hi |= fam10_msr_default[i].data_hi;
+			msr.lo &= ~fam10_msr_default[i].mask_lo;
+			msr.lo |= fam10_msr_default[i].data_lo;
+			wrmsr(fam10_msr_default[i].msr, msr);
+		}
+	}
+	AMD_Errata298();
+
+	printk(BIOS_DEBUG, " done\n");
+}
+
+static void cpuSetAMDPCI(u8 node)
+{
+	/* This routine loads the CPU with default settings in fam10_pci_default
+	 * table . It must be run after Cache-As-RAM has been enabled, and
+	 * Hypertransport initialization has taken place.  Also note
+	 * that it is run for the first core on each node
+	 */
+	u8 i, j;
+	u32 revision, platform;
+	u32 val;
+	u8 offset;
+
+	printk(BIOS_DEBUG, "cpuSetAMDPCI %02d", node);
+
+	revision = mctGetLogicalCPUID(node);
+	platform = get_platform_type();
+
+	AMD_SetupPSIVID_d(platform, node);	/* Set PSIVID offset which is not table driven */
+
+	for (i = 0; i < ARRAY_SIZE(fam10_pci_default); i++) {
+		if ((fam10_pci_default[i].revision & revision) &&
+		    (fam10_pci_default[i].platform & platform)) {
+			val = pci_read_config32(NODE_PCI(node,
+							 fam10_pci_default[i].
+							 function),
+						fam10_pci_default[i].offset);
+			val &= ~fam10_pci_default[i].mask;
+			val |= fam10_pci_default[i].data;
+			pci_write_config32(NODE_PCI(node,
+						    fam10_pci_default[i].
+						    function),
+					   fam10_pci_default[i].offset, val);
+		}
+	}
+
+	for (i = 0; i < ARRAY_SIZE(fam10_htphy_default); i++) {
+		if ((fam10_htphy_default[i].revision & revision) &&
+		    (fam10_htphy_default[i].platform & platform)) {
+			/* HT Phy settings either apply to both sublinks or have
+			 * separate registers for sublink zero and one, so there
+			 * will be two table entries. So, here we only loop
+			 * through the sublink zeros in function zero.
+			 */
+			for (j = 0; j < 4; j++) {
+				if (AMD_CpuFindCapability(node, j, &offset)) {
+					if (AMD_checkLinkType(node, j, offset)
+					    & fam10_htphy_default[i].linktype) {
+						AMD_SetHtPhyRegister(node, j,
+								     i);
+					}
+				} else {
+					/* No more capabilities,
+					 * link not present
+					 */
+					break;
+				}
+			}
+		}
+	}
+
+	/* FIXME: add UMA support and programXbarToSriReg(); */
+
+	AMD_Errata281(node, revision, platform);
+
+	/* FIXME: if the dct phy doesn't init correct it needs to reset.
+	   if (revision & (AMD_DR_B2 | AMD_DR_B3))
+	   dctPhyDiag(); */
+
+	printk(BIOS_DEBUG, " done\n");
+}
+
+#ifdef UNUSED_CODE
+static void cpuInitializeMCA(void)
+{
+	/* Clears Machine Check Architecture (MCA) registers, which power on
+	 * containing unknown data, on currently running processor.
+	 * This routine should only be executed on initial power on (cold boot),
+	 * not across a warm reset because valid data is present at that time.
+	 */
+
+	msr_t msr;
+	u32 reg;
+	u8 i;
+
+	if (cpuid_edx(1) & 0x4080) {	/* MCE and MCA (edx[7] and edx[14]) */
+		msr = rdmsr(MCG_CAP);
+		if (msr.lo & MCG_CTL_P) {	/* MCG_CTL_P bit is set? */
+			msr.lo &= 0xFF;
+			msr.lo--;
+			msr.lo <<= 2;	/* multiply the count by 4 */
+			reg = MC0_STA + msr.lo;
+			msr.lo = msr.hi = 0;
+			for (i = 0; i < 4; i++) {
+				wrmsr(reg, msr);
+				reg -= 4;	/* Touch status regs for each bank */
+			}
+		}
+	}
+}
+#endif
+
+/**
+ * finalize_node_setup()
+ *
+ * Do any additional post HT init
+ *
+ */
+static void finalize_node_setup(struct sys_info *sysinfo)
+{
+	u8 i;
+	u8 nodes = get_nodes();
+	u32 reg;
+
+	/* read Node0 F0_0x64 bit [8:10] to find out SbLink # */
+	reg = pci_read_config32(NODE_HT(0), 0x64);
+	sysinfo->sblk = (reg >> 8) & 7;
+	sysinfo->sbbusn = 0;
+	sysinfo->nodes = nodes;
+	sysinfo->sbdn = get_sbdn(sysinfo->sbbusn);
+
+	for (i = 0; i < nodes; i++) {
+		cpuSetAMDPCI(i);
+	}
+
+#if CONFIG_SET_FIDVID
+	// Prep each node for FID/VID setup.
+	prep_fid_change();
+#endif
+
+#if CONFIG_MAX_PHYSICAL_CPUS > 1
+	/* Skip the BSP, start at node 1 */
+	for (i = 1; i < nodes; i++) {
+		setup_remote_node(i);
+		start_node(i);
+	}
+#endif
+}
+
+#include "fidvid.c"
diff --git a/src/cpu/amd/family_10h-family_15h/model_10xxx_init.c b/src/cpu/amd/family_10h-family_15h/model_10xxx_init.c
new file mode 100644
index 0000000..b942c1a
--- /dev/null
+++ b/src/cpu/amd/family_10h-family_15h/model_10xxx_init.c
@@ -0,0 +1,165 @@
+/*
+ * This file is part of the coreboot project.
+ *
+ * Copyright (C) 2007 Advanced Micro Devices, Inc.
+ * Copyright (C) 2015 Timothy Pearson <tpearson@raptorengineeringinc.com>, Raptor Engineering
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.
+ */
+
+#include <console/console.h>
+#include <cpu/x86/msr.h>
+#include <cpu/amd/mtrr.h>
+#include <device/device.h>
+#include <device/pci.h>
+#include <string.h>
+#include <cpu/x86/msr.h>
+#include <cpu/x86/smm.h>
+#include <cpu/x86/pae.h>
+#include <pc80/mc146818rtc.h>
+#include <cpu/x86/lapic.h>
+#include "northbridge/amd/amdfam10/amdfam10.h"
+#include <cpu/amd/model_10xxx_rev.h>
+#include <cpu/cpu.h>
+#include <cpu/x86/cache.h>
+#include <cpu/x86/mtrr.h>
+#include <cpu/amd/multicore.h>
+#include <cpu/amd/model_10xxx_msr.h>
+
+#define MCI_STATUS 0x401
+
+static void model_10xxx_init(device_t dev)
+{
+	u8 i;
+	msr_t msr;
+	struct node_core_id id;
+#if CONFIG_LOGICAL_CPUS
+	u32 siblings;
+#endif
+
+	id = get_node_core_id(read_nb_cfg_54());	/* nb_cfg_54 can not be set */
+	printk(BIOS_DEBUG, "nodeid = %02d, coreid = %02d\n", id.nodeid, id.coreid);
+
+	/* Turn on caching if we haven't already */
+	x86_enable_cache();
+	amd_setup_mtrrs();
+	x86_mtrr_check();
+
+	disable_cache();
+
+	/* zero the machine check error status registers */
+	msr.lo = 0;
+	msr.hi = 0;
+	for (i = 0; i < 5; i++) {
+		wrmsr(MCI_STATUS + (i * 4), msr);
+	}
+
+	enable_cache();
+
+	/* Enable the local cpu apics */
+	setup_lapic();
+
+	/* Set the processor name string */
+	init_processor_name();
+
+#if CONFIG_LOGICAL_CPUS
+	siblings = cpuid_ecx(0x80000008) & 0xff;
+
+	if (siblings > 0) {
+		msr = rdmsr_amd(CPU_ID_FEATURES_MSR);
+		msr.lo |= 1 << 28;
+		wrmsr_amd(CPU_ID_FEATURES_MSR, msr);
+
+		msr = rdmsr_amd(CPU_ID_EXT_FEATURES_MSR);
+		msr.hi |= 1 << (33 - 32);
+		wrmsr_amd(CPU_ID_EXT_FEATURES_MSR, msr);
+	}
+	printk(BIOS_DEBUG, "siblings = %02d, ", siblings);
+#endif
+
+	/* DisableCf8ExtCfg */
+	msr = rdmsr(NB_CFG_MSR);
+	msr.hi &= ~(1 << (46 - 32));
+	wrmsr(NB_CFG_MSR, msr);
+
+	msr = rdmsr(BU_CFG2_MSR);
+	/* Clear ClLinesToNbDis */
+	msr.lo &= ~(1 << 15);
+	/* Clear bit 35 as per Erratum 343 */
+	msr.hi &= ~(1 << (35-32));
+	wrmsr(BU_CFG2_MSR, msr);
+
+	if (IS_ENABLED(CONFIG_HAVE_SMI_HANDLER)) {
+		printk(BIOS_DEBUG, "Initializing SMM ASeg memory\n");
+
+		/* Set SMM base address for this CPU */
+		msr = rdmsr(SMM_BASE_MSR);
+		msr.lo = SMM_BASE - (lapicid() * 0x400);
+		wrmsr(SMM_BASE_MSR, msr);
+
+		/* Enable the SMM memory window */
+		msr = rdmsr(SMM_MASK_MSR);
+		msr.lo |= (1 << 0); /* Enable ASEG SMRAM Range */
+		wrmsr(SMM_MASK_MSR, msr);
+	} else {
+		printk(BIOS_DEBUG, "Disabling SMM ASeg memory\n");
+
+		/* Set SMM base address for this CPU */
+		msr = rdmsr(SMM_BASE_MSR);
+		msr.lo = SMM_BASE - (lapicid() * 0x400);
+		wrmsr(SMM_BASE_MSR, msr);
+
+		/* Disable the SMM memory window */
+		msr.hi = 0x0;
+		msr.lo = 0x0;
+		wrmsr(SMM_MASK_MSR, msr);
+	}
+
+	/* Set SMMLOCK to avoid exploits messing with SMM */
+	msr = rdmsr(HWCR_MSR);
+	msr.lo |= (1 << 0);
+	wrmsr(HWCR_MSR, msr);
+
+}
+
+static struct device_operations cpu_dev_ops = {
+	.init = model_10xxx_init,
+};
+
+static struct cpu_device_id cpu_table[] = {
+//AMD_GH_SUPPORT
+	{ X86_VENDOR_AMD, 0x100f00 },		/* SH-F0 L1 */
+	{ X86_VENDOR_AMD, 0x100f10 },		/* M2 */
+	{ X86_VENDOR_AMD, 0x100f20 },		/* S1g1 */
+	{ X86_VENDOR_AMD, 0x100f21 },
+	{ X86_VENDOR_AMD, 0x100f2A },
+	{ X86_VENDOR_AMD, 0x100f22 },
+	{ X86_VENDOR_AMD, 0x100f23 },
+	{ X86_VENDOR_AMD, 0x100f40 },		/* RB-C0 */
+	{ X86_VENDOR_AMD, 0x100F42 },           /* RB-C2 */
+	{ X86_VENDOR_AMD, 0x100F43 },           /* RB-C3 */
+	{ X86_VENDOR_AMD, 0x100F52 },           /* BL-C2 */
+	{ X86_VENDOR_AMD, 0x100F62 },           /* DA-C2 */
+	{ X86_VENDOR_AMD, 0x100F63 },           /* DA-C3 */
+	{ X86_VENDOR_AMD, 0x100F80 },           /* HY-D0 */
+	{ X86_VENDOR_AMD, 0x100F81 },           /* HY-D1 */
+	{ X86_VENDOR_AMD, 0x100F91 },           /* HY-D1 */
+	{ X86_VENDOR_AMD, 0x100FA0 },           /* PH-E0 */
+	{ 0, 0 },
+};
+
+static const struct cpu_driver model_10xxx __cpu_driver = {
+	.ops      = &cpu_dev_ops,
+	.id_table = cpu_table,
+};
diff --git a/src/cpu/amd/family_10h-family_15h/monotonic_timer.c b/src/cpu/amd/family_10h-family_15h/monotonic_timer.c
new file mode 100644
index 0000000..8c02fd1
--- /dev/null
+++ b/src/cpu/amd/family_10h-family_15h/monotonic_timer.c
@@ -0,0 +1,98 @@
+/*
+ * This file is part of the coreboot project.
+ *
+ * Copyright (C) 2015 Timothy Pearson <tpearson@raptorengineeringinc.com>, Raptor Engineering
+ * Copyright (C) 2013 Google, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.
+ */
+#include <stdint.h>
+#include <arch/cpu.h>
+#include <cpu/x86/msr.h>
+#include <timer.h>
+#include <device/pci.h>
+#include <device/pci_ids.h>
+
+#include <northbridge/amd/amdht/AsPsDefs.h>
+#include <cpu/amd/model_10xxx_msr.h>
+
+static struct monotonic_counter {
+	int initialized;
+	uint32_t core_frequency;
+	struct mono_time time;
+	uint64_t last_value;
+} mono_counter;
+
+static inline uint64_t read_counter_msr(void)
+{
+	msr_t counter_msr;
+
+	counter_msr = rdmsr(TSC_MSR);
+
+	return ((uint64_t)counter_msr.hi << 32) | (uint64_t)counter_msr.lo;
+}
+
+static void init_timer(void)
+{
+	uint8_t model;
+	uint32_t cpuid_fms;
+	uint8_t cpufid;
+	uint8_t cpudid;
+	uint8_t boost_capable = 0;
+
+	/* Get CPU model */
+	cpuid_fms = cpuid_eax(0x80000001);
+	model = ((cpuid_fms & 0xf0000) >> 16) | ((cpuid_fms & 0xf0) >> 4);
+
+	/* Get boost capability */
+	if ((model == 0x8) || (model == 0x9)) {	/* revision D */
+		boost_capable = (pci_read_config32(dev_find_slot(0, PCI_DEVFN(0x18, 4)), 0x15c) & 0x4) >> 2;
+	}
+
+	/* Set up TSC (BKDG v3.62 section 2.9.4)*/
+	msr_t msr = rdmsr(HWCR_MSR);
+	msr.lo |= 0x1000000;
+	wrmsr(HWCR_MSR, msr);
+
+	/* Get core Pstate 0 frequency in MHz */
+	msr = rdmsr(0xC0010064 + boost_capable);
+	cpufid = (msr.lo & 0x3f);
+	cpudid = (msr.lo & 0x1c0) >> 6;
+	mono_counter.core_frequency = (100 * (cpufid + 0x10)) / (0x01 << cpudid);
+
+	mono_counter.last_value = read_counter_msr();
+	mono_counter.initialized = 1;
+}
+
+void timer_monotonic_get(struct mono_time *mt)
+{
+	uint64_t current_tick;
+	uint32_t usecs_elapsed = 0;
+
+	if (!mono_counter.initialized)
+		init_timer();
+
+	current_tick = read_counter_msr();
+	if (mono_counter.core_frequency != 0)
+		usecs_elapsed = (current_tick - mono_counter.last_value) / mono_counter.core_frequency;
+
+	/* Update current time and tick values only if a full tick occurred. */
+	if (usecs_elapsed) {
+		mono_time_add_usecs(&mono_counter.time, usecs_elapsed);
+		mono_counter.last_value = current_tick;
+	}
+
+	/* Save result. */
+	*mt = mono_counter.time;
+}
diff --git a/src/cpu/amd/family_10h-family_15h/powernow_acpi.c b/src/cpu/amd/family_10h-family_15h/powernow_acpi.c
new file mode 100644
index 0000000..98ef08a
--- /dev/null
+++ b/src/cpu/amd/family_10h-family_15h/powernow_acpi.c
@@ -0,0 +1,311 @@
+/*
+ * This file is part of the coreboot project.
+ *
+ * Copyright (C) 2007-2008 Advanced Micro Devices, Inc.
+ * Copyright (C) 2009 Rudolf Marek <r.marek@assembler.cz>
+ * Copyright (C) 2015 Timothy Pearson <tpearson@raptorengineeringinc.com>, Raptor Engineering
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.
+ */
+
+#include <console/console.h>
+#include <stdint.h>
+#include <cpu/x86/msr.h>
+#include <arch/acpigen.h>
+#include <cpu/amd/powernow.h>
+#include <device/pci.h>
+#include <device/pci_ids.h>
+#include <cpu/x86/msr.h>
+#include <cpu/amd/mtrr.h>
+#include <cpu/amd/amdfam10_sysconf.h>
+#include <arch/cpu.h>
+#include <northbridge/amd/amdht/AsPsDefs.h>
+#include <northbridge/amd/amdmct/mct/mct.h>
+#include <northbridge/amd/amdmct/amddefs.h>
+
+static void write_pstates_for_core(u8 pstate_num, u16 *pstate_feq, u32 *pstate_power,
+				u32 *pstate_latency, u32 *pstate_control,
+				u32 *pstate_status, int coreID,
+				u32 pcontrol_blk, u8 plen, u8 onlyBSP,
+				uint8_t single_link)
+{
+	int i;
+	struct cpuid_result cpuid1;
+
+	if ((onlyBSP) && (coreID != 0)) {
+	    plen = 0;
+	    pcontrol_blk = 0;
+	}
+
+	acpigen_write_processor(coreID, pcontrol_blk, plen);
+	acpigen_write_empty_PCT();
+	acpigen_write_name("_PSS");
+
+	/* add later to total sum */
+	acpigen_write_package(pstate_num);
+
+	for (i = 0;i < pstate_num; i++)
+		acpigen_write_PSS_package(pstate_feq[i],
+					  pstate_power[i],
+					  pstate_latency[i],
+					  pstate_latency[i],
+					  pstate_control[i],
+					  pstate_status[i]);
+
+	/* update the package size */
+	acpigen_pop_len();
+
+	/* Write PPC object */
+	acpigen_write_PPC(pstate_num);
+
+	/* Write PSD indicating coordination type */
+	if ((single_link) && (mctGetLogicalCPUID(0) & AMD_DR_GT_Bx)) {
+		/* Revision C or greater single-link processor */
+		cpuid1 = cpuid(0x80000008);
+		acpigen_write_PSD_package(0, (cpuid1.ecx & 0xff) + 1, SW_ALL);
+	}
+	else {
+		/* Find the local APIC ID for the specified core ID */
+		struct device* cpu;
+		int cpu_index = 0;
+		for (cpu = all_devices; cpu; cpu = cpu->next) {
+			if ((cpu->path.type != DEVICE_PATH_APIC) ||
+				(cpu->bus->dev->path.type != DEVICE_PATH_CPU_CLUSTER))
+				continue;
+			if (!cpu->enabled)
+				continue;
+			if (cpu_index == coreID)
+				break;
+			cpu_index++;
+		}
+
+		if (cpu)
+			acpigen_write_PSD_package(cpu->path.apic.apic_id, 1, SW_ANY);
+	}
+
+	/* patch the whole Processor token length */
+	acpigen_pop_len();
+}
+
+/*
+* For details of this algorithm, please refer to the BDKG 3.62 page 69
+*
+* WARNING: The core count algorithm below assumes that all processors
+* are identical, with the same number of active cores.  While the BKDG
+* states the BIOS must enforce this coreboot does not currently do so.
+* As a result it is possible that this code may break if an illegal
+* processor combination is installed.  If it does break please fix the
+* code in the proper locations!
+*/
+void amd_generate_powernow(u32 pcontrol_blk, u8 plen, u8 onlyBSP)
+{
+	u8 processor_brand[49];
+	u32 *v;
+	struct cpuid_result cpuid1;
+
+	u16 Pstate_feq[10];
+	u32 Pstate_power[10];
+	u32 Pstate_latency[10];
+	u32 Pstate_control[10];
+	u32 Pstate_status[10];
+	u8 Pstate_num;
+	u8 cmp_cap;
+	u8 index;
+	msr_t msr;
+
+	/* Get the Processor Brand String using cpuid(0x8000000x) command x=2,3,4 */
+	cpuid1 = cpuid(0x80000002);
+	v = (u32 *) processor_brand;
+	v[0] = cpuid1.eax;
+	v[1] = cpuid1.ebx;
+	v[2] = cpuid1.ecx;
+	v[3] = cpuid1.edx;
+	cpuid1 = cpuid(0x80000003);
+	v[4] = cpuid1.eax;
+	v[5] = cpuid1.ebx;
+	v[6] = cpuid1.ecx;
+	v[7] = cpuid1.edx;
+	cpuid1 = cpuid(0x80000004);
+	v[8] = cpuid1.eax;
+	v[9] = cpuid1.ebx;
+	v[10] = cpuid1.ecx;
+	v[11] = cpuid1.edx;
+	processor_brand[48] = 0;
+	printk(BIOS_INFO, "processor_brand=%s\n", processor_brand);
+
+	uint32_t dtemp;
+	uint8_t node_index;
+	uint8_t node_count;
+	uint8_t cores_per_node;
+	uint8_t total_core_count;
+
+	/*
+	 * Based on the CPU socket type,cmp_cap and pwr_lmt , get the power limit.
+	 * socket_type : 0x10 SocketF; 0x11 AM2/ASB1 ; 0x12 S1G1
+	 * cmp_cap : 0x0 SingleCore ; 0x1 DualCore ; 0x2 TripleCore ; 0x3 QuadCore ; 0x4 QuintupleCore ; 0x5 HexCore
+	 */
+	printk(BIOS_INFO, "Pstates algorithm ...\n");
+	/* Get number of cores */
+	dtemp = pci_read_config32(dev_find_slot(0, PCI_DEVFN(0x18, 3)), 0xE8);
+	cmp_cap = (dtemp & 0x3000) >> 12;
+	if (mctGetLogicalCPUID(0) & AMD_FAM10_REV_D)	/* revision D */
+		cmp_cap |= (dtemp & 0x8000) >> 13;
+	/* Get number of nodes */
+	dtemp = pci_read_config32(dev_find_slot(0, PCI_DEVFN(0x18, 0)), 0x60);
+	node_count = ((dtemp & 0x70) >> 4) + 1;
+	cores_per_node = cmp_cap + 1;
+
+	/* Compute total number of cores installed in system */
+	total_core_count = cores_per_node * node_count;
+
+	Pstate_num = 0;
+
+	/* See if the CPUID(0x80000007) returned EDX[7]==1b */
+	cpuid1 = cpuid(0x80000007);
+	if ((cpuid1.edx & 0x80) != 0x80) {
+		printk(BIOS_INFO, "No valid set of P-states\n");
+		return;
+	}
+
+	uint8_t pviModeFlag;
+	uint8_t Pstate_max;
+	uint8_t cpufid;
+	uint8_t cpudid;
+	uint8_t cpuvid;
+	uint8_t cpuidd;
+	uint8_t cpuidv;
+	uint8_t power_step_up;
+	uint8_t power_step_down;
+	uint8_t pll_lock_time;
+	uint32_t expanded_cpuidv;
+	uint32_t core_frequency;
+	uint32_t core_power;
+	uint32_t core_latency;
+	uint32_t core_voltage;	/* multiplied by 10000 */
+	uint8_t single_link;
+
+	/* Determine if this is a PVI or SVI system */
+	dtemp = pci_read_config32(dev_find_slot(0, PCI_DEVFN(0x18, 3)), 0xA0);
+
+	if (dtemp & PVI_MODE)
+		pviModeFlag = 1;
+	else
+		pviModeFlag = 0;
+
+	/* Get PSmax's index */
+	msr = rdmsr(0xC0010061);
+	Pstate_max = (uint8_t) ((msr.lo >> PS_MAX_VAL_SHFT) & BIT_MASK_3);
+
+	/* Determine if all enabled Pstates have the same fidvid */
+	uint8_t i;
+	uint8_t cpufid_prev = (rdmsr(0xC0010064).lo & 0x3f);
+	uint8_t all_enabled_cores_have_same_cpufid = 1;
+	for (i = 1; i < Pstate_max; i++) {
+		cpufid = rdmsr(0xC0010064 + i).lo & 0x3f;
+		if (cpufid != cpufid_prev) {
+			all_enabled_cores_have_same_cpufid = 0;
+			break;
+		}
+	}
+
+	/* Populate tables with all Pstate information */
+	for (Pstate_num = 0; Pstate_num < Pstate_max; Pstate_num++) {
+		/* Get power state information */
+		msr = rdmsr(0xC0010064 + Pstate_num);
+		cpufid = (msr.lo & 0x3f);
+		cpudid = (msr.lo & 0x1c0) >> 6;
+		cpuvid = (msr.lo & 0xfe00) >> 9;
+		cpuidd = (msr.hi & 0xff);
+		cpuidv = (msr.hi & 0x300) >> 8;
+		core_frequency = (100 * (cpufid + 0x10)) / (0x01 << cpudid);
+		if (pviModeFlag) {
+			if (cpuvid >= 0x20) {
+				core_voltage = 7625 - (((cpuvid - 0x20) * 10000) / 80);
+			}
+			else {
+				core_voltage = 15500 - ((cpuvid * 10000) / 40);
+			}
+		}
+		else {
+			cpuvid = cpuvid & 0x7f;
+			if (cpuvid >= 0x7c)
+				core_voltage = 0;
+			else
+				core_voltage = 15500 - ((cpuvid * 10000) / 80);
+		}
+		switch (cpuidv) {
+			case 0x0:
+				expanded_cpuidv = 1;
+				break;
+			case 0x1:
+				expanded_cpuidv = 10;
+				break;
+			case 0x2:
+				expanded_cpuidv = 100;
+				break;
+			case 0x3:
+				expanded_cpuidv = 1000;
+				break;
+			default:
+				printk(BIOS_ERR, "%s:%s:%d: Invalid cpuidv, "
+					"not generating pstate tables.\n",
+					__FILE__, __func__, __LINE__);
+				return;
+		}
+		core_power = (core_voltage * cpuidd) / (expanded_cpuidv * 10);
+
+		/* Calculate transition latency */
+		dtemp = pci_read_config32(dev_find_slot(0, PCI_DEVFN(0x18, 3)), 0xD4);
+		power_step_up = (dtemp & 0xf000000) >> 24;
+		power_step_down = (dtemp & 0xf00000) >> 20;
+		dtemp = pci_read_config32(dev_find_slot(0, PCI_DEVFN(0x18, 3)), 0xA0);
+		pll_lock_time = (dtemp & 0x3800) >> 11;
+		if (all_enabled_cores_have_same_cpufid)
+			core_latency = ((12 * power_step_down) + power_step_up) / 1000;
+		else
+			core_latency = (12 * (power_step_down + power_step_up) / 1000)
+						 + pll_lock_time;
+
+		Pstate_feq[Pstate_num] = core_frequency;
+		Pstate_power[Pstate_num] = core_power;
+		Pstate_latency[Pstate_num] = core_latency;
+		Pstate_control[Pstate_num] = Pstate_num;
+		Pstate_status[Pstate_num] = Pstate_num;
+	}
+
+	/* Print Pstate frequency, power, and latency */
+	for (index = 0; index < Pstate_num; index++) {
+		printk(BIOS_INFO, "Pstate_freq[%d] = %dMHz\t", index,
+			    Pstate_feq[index]);
+		printk(BIOS_INFO, "Pstate_power[%d] = %dmw\n", index,
+			    Pstate_power[index]);
+		printk(BIOS_INFO, "Pstate_latency[%d] = %dus\n", index,
+			    Pstate_latency[index]);
+	}
+
+	char pscope[] = "\\_PR";
+
+	acpigen_write_scope(pscope);
+	for (index = 0; index < total_core_count; index++) {
+		/* Determine if this is a single-link processor */
+		node_index = 0x18 + (index / cores_per_node);
+		dtemp = pci_read_config32(dev_find_slot(0, PCI_DEVFN(node_index, 0)), 0x80);
+		single_link = !!(((dtemp & 0xff00) >> 8) == 0);
+
+		write_pstates_for_core(Pstate_num, Pstate_feq, Pstate_power,
+				Pstate_latency, Pstate_control, Pstate_status,
+				index, pcontrol_blk, plen, onlyBSP, single_link);
+	}
+	acpigen_pop_len();
+}
diff --git a/src/cpu/amd/family_10h-family_15h/processor_name.c b/src/cpu/amd/family_10h-family_15h/processor_name.c
new file mode 100644
index 0000000..12c45c9
--- /dev/null
+++ b/src/cpu/amd/family_10h-family_15h/processor_name.c
@@ -0,0 +1,323 @@
+/*
+ * This file is part of the coreboot project.
+ *
+ * Copyright (C) 2007 Advanced Micro Devices, Inc.
+ * Copyright (C) 2008 Peter Stuge
+ * Copyright (C) 2010 Marc Jones <marcj303@gmail.com>
+ * Copyright (C) 2015 Timothy Pearson <tpearson@raptorengineeringinc.com>, Raptor Engineering
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.
+ */
+
+/*
+ * This code sets the Processor Name String for AMD64 CPUs.
+ *
+ * Revision Guide for AMD Family 10h Processors
+ * Publication # 41322 Revision: 3.17 Issue Date: February 2008
+ */
+
+#include <console/console.h>
+#include <string.h>
+#include <cpu/x86/msr.h>
+#include <cpu/amd/mtrr.h>
+#include <cpu/cpu.h>
+#include <cpu/amd/model_10xxx_rev.h>
+
+/* The maximum length of CPU names is 48 bytes, including the final NULL byte.
+ * If you change these names your BIOS will _NOT_ pass the AMD validation and
+ * your mainboard will not be posted on the AMD Recommended Motherboard Website
+ */
+
+struct str_s {
+	u8 Pg;
+	u8 NC;
+	u8 String;
+	char const *value;
+};
+
+
+static const struct str_s String1_socket_F[] = {
+	{0x00, 0x01, 0x00, "Dual-Core AMD Opteron(tm) Processor 83"},
+	{0x00, 0x01, 0x01, "Dual-Core AMD Opteron(tm) Processor 23"},
+	{0x00, 0x03, 0x00, "Quad-Core AMD Opteron(tm) Processor 83"},
+	{0x00, 0x03, 0x01, "Quad-Core AMD Opteron(tm) Processor 23"},
+	{0x00, 0x05, 0x00, "Six-Core AMD Opteron(tm) Processor 84"},
+	{0x00, 0x05, 0x01, "Six-Core AMD Opteron(tm) Processor 24"},
+	{0x00, 0x03, 0x02, "Embedded AMD Opteron(tm) Processor 83"},
+	{0x00, 0x03, 0x03, "Embedded AMD Opteron(tm) Processor 23"},
+	{0x00, 0x03, 0x04, "Embedded AMD Opteron(tm) Processor 13"},
+	{0x00, 0x03, 0x05, "AMD Phenom(tm) FX-"},
+	{0x01, 0x01, 0x01, "Embedded AMD Opteron(tm) Processor"},
+	{0, 0, 0, NULL}
+};
+
+static const struct str_s String2_socket_F[] = {
+	{0x00, 0xFF, 0x02, " EE"},
+	{0x00, 0xFF, 0x0A, " SE"},
+	{0x00, 0xFF, 0x0B, " HE"},
+	{0x00, 0xFF, 0x0C, " EE"},
+	{0x00, 0xFF, 0x0D, " Quad-Core Processor"},
+	{0x00, 0xFF, 0x0F, ""},
+	{0x01, 0x01, 0x01, "GF HE"},
+	{0, 0, 0, NULL}
+};
+
+
+static const struct str_s String1_socket_AM2[] = {
+	{0x00, 0x00, 0x00, "AMD Athlon(tm) Processor LE-"},
+	{0x00, 0x00, 0x01, "AMD Sempron(tm) Processor LE-"},
+	{0x00, 0x00, 0x02, "AMD Sempron(tm) 1"},
+	{0x00, 0x00, 0x03, "AMD Athlon(tm) II 1"},
+	{0x00, 0x01, 0x00, "Dual-Core AMD Opteron(tm) Processor 13"},
+	{0x00, 0x01, 0x01, "AMD Athlon(tm)"},
+	{0x00, 0x01, 0x03, "AMD Athlon(tm) II X2 2"},
+	{0x00, 0x01, 0x04, "AMD Athlon(tm) II X2 B"},
+	{0x00, 0x01, 0x05, "AMD Athlon(tm) II X2"},
+	{0x00, 0x01, 0x07, "AMD Phenom(tm) II X2 5"},
+	{0x00, 0x01, 0x0A, "AMD Phenom(tm) II X2"},
+	{0x00, 0x01, 0x0B, "AMD Phenom(tm) II X2 B"},
+	{0x00, 0x02, 0x00, "AMD Phenom(tm)"},
+	{0x00, 0x02, 0x03, "AMD Phenom(tm) II X3 B"},
+	{0x00, 0x02, 0x04, "AMD Phenom(tm) II X3"},
+	{0x00, 0x02, 0x07, "AMD Athlon(tm) II X3 4"},
+	{0x00, 0x02, 0x08, "AMD Phenom(tm) II X3 7"},
+	{0x00, 0x02, 0x0A, "AMD Athlon(tm) II X3"},
+	{0x00, 0x03, 0x00, "Quad-Core AMD Opteron(tm) Processor 13"},
+	{0x00, 0x03, 0x01, "AMD Phenom(tm) FX-"},
+	{0x00, 0x03, 0x02, "AMD Phenom(tm)"},
+	{0x00, 0x03, 0x03, "AMD Phenom(tm) II X4 9"},
+	{0x00, 0x03, 0x04, "AMD Phenom(tm) II X4 8"},
+	{0x00, 0x03, 0x07, "AMD Phenom(tm) II X4 B"},
+	{0x00, 0x03, 0x08, "AMD Phenom(tm) II X4"},
+	{0x00, 0x03, 0x0A, "AMD Athlon(tm) II X4 6"},
+	{0x00, 0x03, 0x0F, "AMD Athlon(tm) II X4"},
+	{0, 0, 0, NULL}
+};
+
+static const struct str_s String2_socket_AM2[] = {
+	{0x00, 0x00, 0x00, "00"},
+	{0x00, 0x00, 0x01, "10"},
+	{0x00, 0x00, 0x02, "20"},
+	{0x00, 0x00, 0x03, "30"},
+	{0x00, 0x00, 0x04, "40"},
+	{0x00, 0x00, 0x05, "50"},
+	{0x00, 0x00, 0x06, "60"},
+	{0x00, 0x00, 0x07, "70"},
+	{0x00, 0x00, 0x08, "80"},
+	{0x00, 0x00, 0x09, "90"},
+	{0x00, 0x00, 0x09, " Processor"},
+	{0x00, 0x00, 0x09, "u Processor"},
+	{0x00, 0x01, 0x00, "00 Dual-Core Processor"},
+	{0x00, 0x01, 0x01, "00e Dual-Core Processor"},
+	{0x00, 0x01, 0x02, "00B Dual-Core Processor"},
+	{0x00, 0x01, 0x03, "50 Dual-Core Processor"},
+	{0x00, 0x01, 0x04, "50e Dual-Core Processor"},
+	{0x00, 0x01, 0x05, "50B Dual-Core Processor"},
+	{0x00, 0x01, 0x06, " Processor"},
+	{0x00, 0x01, 0x07, "e Processor"},
+	{0x00, 0x01, 0x09, "0 Processor"},
+	{0x00, 0x01, 0x0A, "0e Processor"},
+	{0x00, 0x01, 0x0B, "u Processor"},
+	{0x00, 0x02, 0x00, "00 Triple-Core Processor"},
+	{0x00, 0x02, 0x01, "00e Triple-Core Processor"},
+	{0x00, 0x02, 0x02, "00B Triple-Core Processor"},
+	{0x00, 0x02, 0x03, "50 Triple-Core Processor"},
+	{0x00, 0x02, 0x04, "50e Triple-Core Processor"},
+	{0x00, 0x02, 0x05, "50B Triple-Core Processor"},
+	{0x00, 0x02, 0x06, " Processor"},
+	{0x00, 0x02, 0x07, "e Processor"},
+	{0x00, 0x02, 0x09, "0e Processor"},
+	{0x00, 0x02, 0x0A, "0 Processor"},
+	{0x00, 0x03, 0x00, "00 Quad-Core Processor"},
+	{0x00, 0x03, 0x01, "00e Quad-Core Processor"},
+	{0x00, 0x03, 0x02, "00B Quad-Core Processor"},
+	{0x00, 0x03, 0x03, "50 Quad-Core Processor"},
+	{0x00, 0x03, 0x04, "50e Quad-Core Processor"},
+	{0x00, 0x03, 0x05, "50B Quad-Core Processor"},
+	{0x00, 0x03, 0x06, " Processor"},
+	{0x00, 0x03, 0x07, "e Processor"},
+	{0x00, 0x03, 0x09, "0e Processor"},
+	{0x00, 0x03, 0x0A, " SE"},
+	{0x00, 0x03, 0x0B, " HE"},
+	{0x00, 0x03, 0x0C, " EE"},
+	{0x00, 0x03, 0x0D, " Quad-Core Processor"},
+	{0x00, 0x03, 0x0E, "0 Processor"},
+	{0x00, 0xFF, 0x0F, ""},
+	{0, 0, 0, NULL}
+};
+
+static const struct str_s String1_socket_G34[] = {
+	{0x00, 0x07, 0x00, "AMD Opteron(tm) Processor 61"},
+	{0x00, 0x0B, 0x00, "AMD Opteron(tm) Processor 61"},
+	{0x01, 0x07, 0x01, "Embedded AMD Opteron(tm) Processor "},
+	{0, 0, 0, NULL}
+};
+
+static const struct str_s String2_socket_G34[] = {
+	{0x00, 0x07, 0x00, " HE"},
+	{0x00, 0x07, 0x01, " SE"},
+	{0x00, 0x0B, 0x00, " HE"},
+	{0x00, 0x0B, 0x01, " SE"},
+	{0x00, 0x0B, 0x0F, ""},
+	{0x01, 0x07, 0x01, " QS"},
+	{0x01, 0x07, 0x02, " KS"},
+	{0, 0, 0, NULL}
+};
+
+static const struct str_s String1_socket_C32[] = {
+	{0x00, 0x03, 0x00, "AMD Opteron(tm) Processor 41"},
+	{0x00, 0x05, 0x00, "AMD Opteron(tm) Processor 41"},
+	{0x01, 0x03, 0x01, "Embedded AMD Opteron(tm) Processor "},
+	{0x01, 0x05, 0x01, "Embedded AMD Opteron(tm) Processor "},
+	{0, 0, 0, NULL}
+};
+
+static const struct str_s String2_socket_C32[] = {
+	{0x00, 0x03, 0x00, " HE"},
+	{0x00, 0x03, 0x01, " EE"},
+	{0x00, 0x05, 0x00, " HE"},
+	{0x00, 0x05, 0x01, " EE"},
+	{0x01, 0x03, 0x01, "QS HE"},
+	{0x01, 0x03, 0x02, "LE HE"},
+	{0x01, 0x05, 0x01, "KX HE"},
+	{0x01, 0x05, 0x02, "GL EE"},
+	{0, 0, 0, NULL}
+};
+
+const char *unknown = "AMD Processor model unknown";
+const char *unknown2 = " type unknown";
+const char *sample = "AMD Engineering Sample";
+const char *thermal = "AMD Thermal Test Kit";
+
+
+static int strcpymax(char *dst, const char *src, int buflen)
+{
+	int i;
+	for (i = 0; i < buflen && src[i]; i++)
+		dst[i] = src[i];
+	if (i >= buflen)
+		i--;
+	dst[i] = 0;
+	return i;
+}
+
+
+int init_processor_name(void)
+{
+	/* variable names taken from fam10 revision guide for clarity */
+	u32 BrandId;	/* CPUID Fn8000_0001_EBX */
+	u8 String1;	/* BrandID[14:11] */
+	u8 String2;	/* BrandID[3:0] */
+	u8 Model;	/* BrandID[10:4] */
+	u8 Pg;		/* BrandID[15] */
+	u8 PkgTyp;	/* BrandID[31:28] */
+	u8 NC;		/* CPUID Fn8000_0008_ECX */
+	const char *processor_name_string = unknown;
+	char program_string[48];
+	u32 *p_program_string = (u32 *)program_string;
+	msr_t msr;
+	int i, j = 0, str2_checkNC = 1;
+	const struct str_s *str, *str2;
+
+
+	/* Find out which CPU brand it is */
+	BrandId = cpuid_ebx(0x80000001);
+	String1 = (u8)((BrandId >> 11) & 0x0F);
+	String2 = (u8)((BrandId >> 0) & 0x0F);
+	Model = (u8)((BrandId >> 4) & 0x7F);
+	Pg = (u8)((BrandId >> 15) & 0x01);
+	PkgTyp = (u8)((BrandId >> 28) & 0x0F);
+	NC = (u8)(cpuid_ecx(0x80000008) & 0xFF);
+
+	/* null the string */
+	memset(program_string, 0, sizeof(program_string));
+
+	if (!Model) {
+		processor_name_string = Pg ? thermal : sample;
+		goto done;
+	}
+
+	switch (PkgTyp) {
+	case 0:		/* F1207 */
+		str = String1_socket_F;
+		str2 = String2_socket_F;
+		str2_checkNC = 0;
+		break;
+	case 1:		/* AM2 */
+		str = String1_socket_AM2;
+		str2 = String2_socket_AM2;
+		break;
+	case 3:		/* G34 */
+		str = String1_socket_G34;
+		str2 = String2_socket_G34;
+		str2_checkNC = 0;
+		break;
+	case 5:		/* C32 */
+		str = String1_socket_C32;
+		str2 = String2_socket_C32;
+		break;
+	default:
+		goto done;
+	}
+
+	/* String1 */
+	for (i = 0; str[i].value; i++) {
+		if ((str[i].Pg == Pg) &&
+		    (str[i].NC == NC) &&
+		    (str[i].String == String1)) {
+			processor_name_string = str[i].value;
+			break;
+		}
+	}
+
+	if (!str[i].value)
+		goto done;
+
+	j = strcpymax(program_string, processor_name_string,
+		      sizeof(program_string));
+
+	/* Translate Model from 01-99 to ASCII and put it on the end.
+	 * Numbers less than 10 should include a leading zero, e.g., 09.*/
+	if (Model < 100 && j < sizeof(program_string) - 2) {
+		program_string[j++] = (Model / 10) + '0';
+		program_string[j++] = (Model % 10) + '0';
+	}
+
+	processor_name_string = unknown2;
+
+	/* String 2 */
+	for(i = 0; str2[i].value; i++) {
+		if ((str2[i].Pg == Pg) &&
+		    ((str2[i].NC == NC) || !str2_checkNC) &&
+		    (str2[i].String == String2)) {
+			processor_name_string = str2[i].value;
+			break;
+		}
+	}
+
+
+done:
+	strcpymax(&program_string[j], processor_name_string,
+		  sizeof(program_string) - j);
+
+	printk(BIOS_DEBUG, "CPU model: %s\n", program_string);
+
+	for (i = 0; i < 6; i++) {
+		msr.lo = p_program_string[(2 * i) + 0];
+		msr.hi = p_program_string[(2 * i) + 1];
+		wrmsr_amd(0xC0010030 + i, msr);
+	}
+
+	return 0;
+}
diff --git a/src/cpu/amd/family_10h-family_15h/ram_calc.c b/src/cpu/amd/family_10h-family_15h/ram_calc.c
new file mode 100644
index 0000000..46ccdbd
--- /dev/null
+++ b/src/cpu/amd/family_10h-family_15h/ram_calc.c
@@ -0,0 +1,54 @@
+/*
+ * This file is part of the coreboot project.
+ *
+ * Copyright (C) 2015 Timothy Pearson <tpearson@raptorengineeringinc.com>, Raptor Engineering
+ * Copyright (C) 2007 Advanced Micro Devices, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.
+ */
+
+#include <cpu/cpu.h>
+#include <cpu/x86/msr.h>
+#include <cpu/amd/mtrr.h>
+
+#include <cbmem.h>
+
+#include "ram_calc.h"
+
+#if !IS_ENABLED(CONFIG_LATE_CBMEM_INIT)
+uint64_t get_uma_memory_size(uint64_t topmem)
+{
+	uint64_t uma_size = 0;
+	if (IS_ENABLED(CONFIG_GFXUMA)) {
+		/* refer to UMA Size Consideration in 780 BDG. */
+		if (topmem >= 0x40000000)	/* 1GB and above system memory */
+			uma_size = 0x10000000;	/* 256M recommended UMA */
+
+		else if (topmem >= 0x20000000)	/* 512M - 1023M system memory */
+			uma_size = 0x8000000;	/* 128M recommended UMA */
+
+		else if (topmem >= 0x10000000)	/* 256M - 511M system memory */
+			uma_size = 0x4000000;	/* 64M recommended UMA */
+	}
+
+	return uma_size;
+}
+
+void *cbmem_top(void)
+{
+	uint32_t topmem = rdmsr(TOP_MEM).lo;
+
+	return (void *) topmem - get_uma_memory_size(topmem);
+}
+#endif
diff --git a/src/cpu/amd/family_10h-family_15h/ram_calc.h b/src/cpu/amd/family_10h-family_15h/ram_calc.h
new file mode 100644
index 0000000..61da328
--- /dev/null
+++ b/src/cpu/amd/family_10h-family_15h/ram_calc.h
@@ -0,0 +1,25 @@
+/*
+ * This file is part of the coreboot project.
+ *
+ * Copyright (C) 2015 Timothy Pearson <tpearson@raptorengineeringinc.com>, Raptor Engineering
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.
+ */
+
+#ifndef _AMD_MODEL_10XXX_RAM_CALC_H_
+#define _AMD_MODEL_10XXX_RAM_CALC_H_
+
+uint64_t get_uma_memory_size(uint64_t topmem);
+
+#endif
diff --git a/src/cpu/amd/family_10h-family_15h/update_microcode.c b/src/cpu/amd/family_10h-family_15h/update_microcode.c
new file mode 100644
index 0000000..51aca35
--- /dev/null
+++ b/src/cpu/amd/family_10h-family_15h/update_microcode.c
@@ -0,0 +1,71 @@
+/*
+ * This file is part of the coreboot project.
+ *
+ * Copyright (C) 2015 Timothy Pearson <tpearson@raptorengineeringinc.com>, Raptor Engineering
+ * Copyright (C) 2007 Advanced Micro Devices, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.
+ */
+
+#include <stdint.h>
+#include <cpu/amd/microcode.h>
+
+struct id_mapping {
+        uint32_t orig_id;
+        uint16_t new_id;
+};
+
+static u16 get_equivalent_processor_rev_id(u32 orig_id) {
+	static const struct id_mapping id_mapping_table[] = {
+		{ 0x100f00, 0x1000 },
+		{ 0x100f01, 0x1000 },
+		{ 0x100f02, 0x1000 },
+		{ 0x100f20, 0x1020 },
+		{ 0x100f21, 0x1020 }, /* DR-B1 */
+		{ 0x100f2A, 0x1020 }, /* DR-BA */
+		{ 0x100f22, 0x1022 }, /* DR-B2 */
+		{ 0x100f23, 0x1022 }, /* DR-B3 */
+		{ 0x100f42, 0x1041 }, /* RB-C2 */
+		{ 0x100f43, 0x1043 }, /* RB-C3 */
+		{ 0x100f52, 0x1041 }, /* BL-C2 */
+		{ 0x100f62, 0x1062 }, /* DA-C2 */
+		{ 0x100f63, 0x1043 }, /* DA-C3 */
+		{ 0x100f81, 0x1081 }, /* HY-D1 */
+		{ 0x100fa0, 0x10A0 }, /* PH-E0 */
+
+		/* Array terminator */
+		{ 0xffffff, 0x0000 },
+	};
+
+	u32 new_id;
+	int i;
+
+	new_id = 0;
+
+	for (i = 0; id_mapping_table[i].orig_id != 0xffffff; i++) {
+		if (id_mapping_table[i].orig_id == orig_id) {
+			new_id = id_mapping_table[i].new_id;
+			break;
+		}
+	}
+
+	return new_id;
+
+}
+
+void update_microcode(u32 cpu_deviceid)
+{
+	u32 equivalent_processor_rev_id = get_equivalent_processor_rev_id(cpu_deviceid);
+	amd_update_microcode_from_cbfs(equivalent_processor_rev_id);
+}
diff --git a/src/cpu/amd/model_10xxx/Kconfig b/src/cpu/amd/model_10xxx/Kconfig
deleted file mode 100644
index 7c47e27..0000000
--- a/src/cpu/amd/model_10xxx/Kconfig
+++ /dev/null
@@ -1,88 +0,0 @@
-config CPU_AMD_MODEL_10XXX
-	bool
-	select ARCH_BOOTBLOCK_X86_32
-	select ARCH_VERSTAGE_X86_32
-	select ARCH_ROMSTAGE_X86_32
-	select ARCH_RAMSTAGE_X86_32
-	select SSE
-	select SSE2
-	select MMCONF_SUPPORT_DEFAULT
-	select TSC_SYNC_LFENCE
-	select UDELAY_LAPIC
-	select HAVE_MONOTONIC_TIMER
-	select SUPPORT_CPU_UCODE_IN_CBFS
-	select CPU_MICROCODE_MULTIPLE_FILES
-
-if CPU_AMD_MODEL_10XXX
-
-config NUM_IPI_STARTS
-	int
-	default 1
-
-config CPU_ADDR_BITS
-	int
-	default 48
-
-config DCACHE_RAM_BASE
-	hex
-	default 0xc4000
-
-config DCACHE_RAM_SIZE
-	hex
-	default 0x0c000
-
-config DCACHE_BSP_STACK_SIZE
-	hex
-	default 0x2000
-
-config DCACHE_BSP_STACK_SLUSH
-	hex
-	default 0x1000
-
-config DCACHE_AP_STACK_SIZE
-	hex
-	default 0x400
-
-config UDELAY_IO
-	bool
-	default n
-
-config SET_FIDVID
-	bool
-	default y
-
-config MAX_PHYSICAL_CPUS
-	int
-	default 1
-
-config LIFT_BSP_APIC_ID
-	bool
-	default n
-
-if SET_FIDVID
-config SET_FIDVID_DEBUG
-	bool
-	default y
-
-config SET_FIDVID_STORE_AP_APICID_AT_FIRST
-	bool
-	default y
-
-config SET_FIDVID_CORE0_ONLY
-	bool
-	default n
-
-# 0: all cores
-# 1: core 0 only
-# 2: all but core 0
-config SET_FIDVID_CORE_RANGE
-	int
-	default 0
-
-endif	# SET_FIDVID
-
-config UDELAY_LAPIC_FIXED_FSB
-	int
-	default 200
-
-endif	# CPU_AMD_MODEL_10XXX
diff --git a/src/cpu/amd/model_10xxx/Makefile.inc b/src/cpu/amd/model_10xxx/Makefile.inc
deleted file mode 100644
index 5a81ab8..0000000
--- a/src/cpu/amd/model_10xxx/Makefile.inc
+++ /dev/null
@@ -1,14 +0,0 @@
-romstage-y += ../../x86/mtrr/earlymtrr.c
-ramstage-y += model_10xxx_init.c
-ramstage-y += processor_name.c
-
-romstage-y += update_microcode.c
-romstage-y += ram_calc.c
-ramstage-y += ram_calc.c
-ramstage-y += monotonic_timer.c
-ramstage-$(CONFIG_HAVE_ACPI_TABLES) += powernow_acpi.c
-
-# Microcode for Family 10h, 11h, 12h, and 14h
-cbfs-files-$(CONFIG_CPU_MICROCODE_MULTIPLE_FILES) += microcode_amd.bin
-microcode_amd.bin-file := 3rdparty/blobs/cpu/amd/family_10h-family_14h/microcode_amd.bin
-microcode_amd.bin-type := microcode
diff --git a/src/cpu/amd/model_10xxx/defaults.h b/src/cpu/amd/model_10xxx/defaults.h
deleted file mode 100644
index 6fd1a7e..0000000
--- a/src/cpu/amd/model_10xxx/defaults.h
+++ /dev/null
@@ -1,479 +0,0 @@
-/*
- * This file is part of the coreboot project.
- *
- * Copyright (C) 2008 Advanced Micro Devices, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc.
- */
-
-#include <northbridge/amd/amdmct/amddefs.h>
-#include <cpu/amd/mtrr.h>
-
-/*
- * Default MSR and errata settings.
- */
-static const struct {
-	u32 msr;
-	u32 revision;
-	u32 platform;
-	u32 data_lo;
-	u32 data_hi;
-	u32 mask_lo;
-	u32 mask_hi;
-} fam10_msr_default[] = {
-	{ TOP_MEM2, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0x00000000, 0x00000000,
-	  0xFFFFFFFF, 0xFFFFFFFF },
-
-	{ SYSCFG, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  3 << 21, 0x00000000,
-	  3 << 21, 0x00000000 },	/* [MtrrTom2En]=1,[TOM2EnWB] = 1*/
-
-	{ HWCR, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  1 << 4, 0x00000000,
-	  1 << 4, 0x00000000 },		/* [INVD_WBINVD]=1 */
-
-	{ MC4_CTL_MASK, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0xF << 19, 0x00000000,
-	  0xF << 19, 0x00000000 },	/* [RtryHt[0..3]]=1 */
-
-	{ DC_CFG, AMD_FAM10_ALL, AMD_PTYPE_SVR,
-	  0x00000000, 0x00000004,
-	  0x00000000, 0x0000000C },	/* [REQ_CTR] = 1 for Server */
-
-	{ DC_CFG, AMD_DR_Bx, AMD_PTYPE_SVR,
-	  0x00000000, 0x00000000,
-	  0x00000000, 0x00000C00 },	/* Erratum 326 */
-
-	{ NB_CFG, AMD_FAM10_ALL, AMD_PTYPE_DC | AMD_PTYPE_MC,
-	  0x00000000, 1 << 22,
-	  0x00000000, 1 << 22 },	/* [ApicInitIDLo]=1 */
-
-	{ BU_CFG2, AMD_DR_Bx, AMD_PTYPE_ALL,
-	  1 << 29, 0x00000000,
-	  1 << 29, 0x00000000 },	/* For Bx Smash1GPages=1 */
-
-	{ DC_CFG, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  1 << 24, 0x00000000,
-	  1 << 24, 0x00000000 },	/* Erratum #261 [DIS_PIGGY_BACK_SCRUB]=1 */
-
-	{ LS_CFG, AMD_DR_GT_B0, AMD_PTYPE_ALL,
-	  0 << 1, 0x00000000,
-	  1 << 1, 0x00000000 },		/* IDX_MATCH_ALL=0 */
-
-	{ BU_CFG, AMD_DR_LT_B3, AMD_PTYPE_ALL,
-	  1 << 21, 0x00000000,
-	  1 << 21, 0x00000000 },	/* Erratum #254 DR B1 BU_CFG[21]=1 */
-
-	{ BU_CFG, AMD_DR_LT_B3, AMD_PTYPE_ALL,
-	  1 << 23, 0x00000000,
-	  1 << 23, 0x00000000 },	/* Erratum #309 BU_CFG[23]=1 */
-
-	/* CPUID_EXT_FEATURES */
-	{ CPUIDFEATURES, AMD_FAM10_ALL, AMD_PTYPE_DC | AMD_PTYPE_MC,
-	  1 << 28, 0x00000000,
-	  1 << 28, 0x00000000 },	/* [HyperThreadFeatEn]=1 */
-
-	{ CPUIDFEATURES, AMD_FAM10_ALL, AMD_PTYPE_DC,
-	  0x00000000, 1 << (33-32),
-	  0x00000000, 1 << (33-32) },	/* [ExtendedFeatEn]=1 */
-
-	{ BU_CFG2, AMD_DRBH_Cx, AMD_PTYPE_ALL,
-	  0x00000000, 1 << (35-32),
-	  0x00000000, 1 << (35-32) },	/* Erratum 343 (set to 0 after CAR, in post_cache_as_ram()/model_10xxx_init() )  */
-
-	{ OSVW_ID_Length, AMD_DR_Bx | AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL,
-	  0x00000004, 0x00000000,
-	  0x00000004, 0x00000000},	/* B0 or Above, OSVW_ID_Length is 0004h */
-
-	{ OSVW_Status, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_MC,
-	  0x0000000C, 0x00000000,
-	  0x0000000C, 0x00000000},	/* Cx and Dx multiple-link processor */
-
-	{ BU_CFG2, AMD_DR_Dx, AMD_PTYPE_ALL,
-	  0x00000000, 1 << (50-32),
-	  0x00000000, 1 << (50-32)},	/* D0 or Above, RdMmExtCfgQwEn*/
-
-	{ CPU_ID_EXT_FEATURES_MSR, AMD_DR_Dx, AMD_PTYPE_ALL,
-	  0x00000000, 1 << (51 - 32),
-	  0x00000000, 1 << (51 - 32)},	/* G34_PKG | C32_PKG | S1G4_PKG | ASB2_PKG */
-};
-
-
-/*
- * Default PCI and errata settings.
- */
-static const struct {
-	u8  function;
-	u16 offset;
-	u32 revision;
-	u32 platform;
-	u32 data;
-	u32 mask;
-} fam10_pci_default[] = {
-
-	/* Function 0 - HT Config */
-
-	{ 0, 0x68, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0x004E4800, 0x006E6800 },	/* [19:17] for 8bit APIC config,
-	  [14:13] BufPriRel = 2h [11] RspPassPW set,
-	  [22:21] DsNpReqLmt = 10b */
-
-	/* Errata 281 Workaround */
-	{ 0, 0x68, (AMD_DR_B0 | AMD_DR_B1),
-	  AMD_PTYPE_SVR, 0x00200000, 0x00600000 },	/* [22:21] DsNpReqLmt0 = 01b */
-
-	{ 0, 0x84, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0x00002000, 0x00002000 },	/* [13] LdtStopTriEn = 1 */
-
-	{ 0, 0xA4, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0x00002000, 0x00002000 },	/* [13] LdtStopTriEn = 1 */
-
-	{ 0, 0xC4, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0x00002000, 0x00002000 },	/* [13] LdtStopTriEn = 1 */
-
-	{ 0, 0xE4, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0x00002000, 0x00002000 },	/* [13] LdtStopTriEn = 1 */
-
-	/* Link Global Retry Control Register */
-	{ 0, 0x150, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0x00073900, 0x00073F00 },
-
-	/*  Errata 351
-	 * System software should program the Link Extended Control Registers[LS2En]
-	 * (F0x[18C:170][8]) to 0b for all links. System software should also
-	 * program Link Global Extended Control Register[ForceFullT0]
-	 * (F0x16C[15:13]) to 000b */
-
-	{ 0, 0x170, AMD_FAM10_ALL, AMD_PTYPE_ALL, /* Fix FAM10_ALL when fixed in rev guide */
-	  0x00000000, 0x00000100 },
-	{ 0, 0x174, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0x00000000, 0x00000100 },
-	{ 0, 0x178, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0x00000000, 0x00000100 },
-	{ 0, 0x17C, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0x00000000, 0x00000100 },
-	{ 0, 0x180, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0x00000000, 0x00000100 },
-	{ 0, 0x184, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0x00000000, 0x00000100 },
-	{ 0, 0x188, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0x00000000, 0x00000100 },
-	{ 0, 0x18C, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0x00000000, 0x00000100 },
-	{ 0, 0x170, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0x00000000, 0x00000100 },
-
-	/* Link Global Extended Control Register */
-	{ 0, 0x16C, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0x00000014, 0x0000003F },	/* [15:13] ForceFullT0 = 0b,
-								 * Set T0Time 14h per BKDG */
-
-
-	/* Function 1 - Map Init */
-
-	/* Before reading F1x114_x2 or F1x114_x3 software must
-	 * initialize the registers or NB Array MCA errors may
-	 * occur.  BIOS should initialize index 0h of F1x114_x2 and
-	 * F1x114_x3 to prevent reads from F1x114 from generating NB
-	 * Array MCA errors.  BKDG Doc #3116 Rev 1.07
-	 */
-
-	{ 1, 0x110, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0x20000000, 0xFFFFFFFF },	/* Select extended MMIO Base */
-
-	{ 1, 0x114, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0x00000000, 0xFFFFFFFF },	/* Clear map  */
-
-	{ 1, 0x110, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0x30000000, 0xFFFFFFFF },	/* Select extended MMIO Base */
-
-	{ 1, 0x114, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0x00000000, 0xFFFFFFFF },	/* Clear map  */
-
-	/* Function 2 - DRAM Controller */
-
-	/* Function 3 - Misc. Control */
-	{ 3, 0x40, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0x00000100, 0x00000100 },	/* [8] MstrAbrtEn */
-
-	{ 3, 0x44, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0x4A30005C, 0x4A30005C },	/* [30] SyncOnDramAdrParErrEn = 1,
-					   [27] NbMcaToMstCpuEn = 1,
-					   [25] DisPciCfgCpuErrRsp = 1,
-					   [21] SyncOnAnyErrEn = 1,
-					   [20] SyncOnWDTEn = 1,
-					   [6] CpuErrDis = 1,
-					   [4] SyncPktPropDis = 1,
-					   [3] SyncPktGenDis = 1,
-					   [2] SyncOnUcEccEn = 1 */
-
-	/* XBAR buffer settings */
-	{ 3, 0x6C, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0x00018052, 0x700780F7 },
-
-	/* Errata 281 Workaround */
-	{ 3, 0x6C, ( AMD_DR_B0 | AMD_DR_B1),
-	  AMD_PTYPE_SVR, 0x00010094, 0x700780F7 },
-
-	{ 3, 0x6C, AMD_FAM10_ALL, AMD_PTYPE_UMA,
-	  0x60018051, 0x700780F7 },
-
-	{ 3, 0x70, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0x00041153, 0x777777F7 },
-
-	{ 3, 0x70, AMD_FAM10_ALL, AMD_PTYPE_UMA,
-	  0x61221151, 0x777777F7 },
-
-	{ 3, 0x74, AMD_FAM10_ALL, AMD_PTYPE_UMA,
-	  0x00080101, 0x000F7777 },
-
-	{ 3, 0x7C, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0x00090914, 0x707FFF1F },
-
-	/* Errata 281 Workaround */
-	{ 3, 0x7C, ( AMD_DR_B0 | AMD_DR_B1),
-	 AMD_PTYPE_SVR, 0x00144514, 0x707FFF1F },
-
-	{ 3, 0x7C, AMD_FAM10_ALL, AMD_PTYPE_UMA,
-	  0x00070814, 0x007FFF1F },
-
-	{ 3, 0x140, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0x00800756, 0x00F3FFFF },
-
-	{ 3, 0x140, AMD_FAM10_ALL, AMD_PTYPE_UMA,
-	  0x00C37756, 0x00F3FFFF },
-
-	{ 3, 0x144, AMD_FAM10_ALL, AMD_PTYPE_UMA,
-	  0x00000036, 0x000000FF },
-
-	/* Errata 281 Workaround */
-	{ 3, 0x144, ( AMD_DR_B0 | AMD_DR_B1),
-	 AMD_PTYPE_SVR, 0x00000001, 0x0000000F },
-	 	/* [3:0] RspTok = 0001b */
-
-	{ 3, 0x148, AMD_FAM10_ALL, AMD_PTYPE_UMA,
-	  0x8000052A, 0xD5FFFFFF },
-
-	/* ACPI Power State Control Reg1 */
-	{ 3, 0x80, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0xE6002200, 0xFFFFFFFF },
-
-	/* ACPI Power State Control Reg2 */
-	{ 3, 0x84, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0xA0E641E6, 0xFFFFFFFF },
-
-	{ 3, 0xA0, AMD_FAM10_ALL, AMD_PTYPE_MOB | AMD_PTYPE_DSK,
-	  0x00000080, 0x00000080 },	/* [7] PSIVidEnable */
-
-	{ 3, 0xA0, AMD_DR_Bx, AMD_PTYPE_ALL,
-	  0x00002800, 0x000003800 },	/* [13:11] PllLockTime = 5 */
-
-	{ 3, 0xA0, (AMD_FAM10_ALL & ~(AMD_DR_Bx)), AMD_PTYPE_ALL,
-	  0x00000800, 0x000003800 },	/* [13:11] PllLockTime = 1 */
-
-	/* Reported Temp Control Register */
-	{ 3, 0xA4, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0x00000080, 0x00000080 },	/* [7] TempSlewDnEn = 1 */
-
-	/* Clock Power/Timing Control 0 Register */
-	{ 3, 0xD4, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0xC0000F00, 0xF0000F00 },	/*  [31] NbClkDivApplyAll = 1,
-		[30:28] NbClkDiv = 100b,[11:8] ClkRampHystSel = 1111b */
-
-	/* Clock Power/Timing Control 1 Register */
-	{ 3, 0xD8, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0x03000016, 0x0F000077 },	/* [6:4] VSRampTime = 1,
-		[2:0] VSSlamTime = 6, [27:24] ReConDel = 3 */
-
-
-	/* Clock Power/Timing Control 2 Register */
-	{ 3, 0xDC, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0x00005000, 0x00007000 },	/* [14:12] NbsynPtrAdj = 5 */
-
-
-	/* Extended NB MCA Config Register */
-	{ 3, 0x180, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0x007003E2, 0x007003E2 },	/* [22:20] = SyncFloodOn_Err = 7,
-					   [9] SyncOnUncNbAryEn = 1 ,
-					   [8] SyncOnProtEn = 1,
-					   [7] SyncFloodOnTgtAbtErr = 1,
-					   [6] SyncFloodOnDatErr = 1,
-					   [5] DisPciCfgCpuMstAbtRsp = 1,
-					   [1] SyncFloodOnUsPwDataErr = 1 */
-
-	/* errata 346 - Fam10 C2, C3
-	 *  System software should set F3x188[22] to 1b. */
-	{ 3, 0x188, AMD_DR_Cx, AMD_PTYPE_ALL,
-	  0x00400000, 0x00400000 },
-
-	/* L3 Control Register */
-	{ 3, 0x1B8, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0x00001000, 0x00001000 },	/* [12] = L3PrivReplEn */
-
-	/* IBS Control Register */
-	{ 3, 0x1CC, AMD_FAM10_ALL, AMD_PTYPE_ALL,
-	  0x00000100, 0x00000100 },	/* [8] = LvtOffsetVal */
-};
-
-
-/*
- * Default HyperTransport Phy and errata settings.
- */
-static const struct {
-	u16 htreg;	/* HT Phy Register index */
-	u32 revision;
-	u32 platform;
-	u32 linktype;
-	u32 data;
-	u32 mask;
-} fam10_htphy_default[] = {
-
-	/* Errata 344 - Fam10 C2/C3, D0/D1
-	 * System software should set bit 6 of F4x1[9C, 94, 8C, 84]_x[78:70, 68:60]. */
-	{ 0x60, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-	{ 0x61, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-	{ 0x62, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-	{ 0x63, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-	{ 0x64, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-	{ 0x65, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-	{ 0x66, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-	{ 0x67, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-	{ 0x68, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-
-	{ 0x70, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-	{ 0x71, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-	{ 0x72, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-	{ 0x73, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-	{ 0x74, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-	{ 0x75, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-	{ 0x76, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-	{ 0x77, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-	{ 0x78, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-
-	/* Errata 354 - Fam10 C2, C3
-	 * System software should set bit 6 of F4x1[9C,94,8C,84]_x[58:50, 48:40] for all links. */
-	{ 0x40, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-	{ 0x41, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-	{ 0x42, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-	{ 0x43, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-	{ 0x44, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-	{ 0x45, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-	{ 0x46, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-	{ 0x47, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-	{ 0x48, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-
-	{ 0x50, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-	{ 0x51, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-	{ 0x52, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-	{ 0x53, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-	{ 0x54, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-	{ 0x55, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-	{ 0x56, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-	{ 0x57, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-	{ 0x58, AMD_DR_Cx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00000040, 0x00000040 },
-
-	/* Errata 327 - Fam10 C2/C3, D0/D1
-	 * BIOS should set the Link Phy Impedance Register[RttCtl]
-	 * (F4x1[9C, 94, 8C, 84]_x[D0, C0][31:29]) to 010b and
-	 * Link Phy Impedance Register[RttIndex]
-	 * (F4x1[9C, 94, 8C, 84]_x[D0, C0][20:16]) to 00100b */
-	{ 0xC0, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x40040000, 0xe01F0000 },
-	{ 0xD0, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x40040000, 0xe01F0000 },
-
-	{ 0x520A,AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00004000, 0x00006000 },	/* HT_PHY_DLL_REG */
-
-	{ 0x530A, AMD_DR_Cx | AMD_DR_Dx, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00004000, 0x00006000 },	/* HT_PHY_DLL_REG */
-
-	{ 0x520A, AMD_DR_ALL, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00004400, 0x00006400 },	/* HT_PHY_DLL_REG */
-
-	{ 0x530A, AMD_DR_ALL, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x00004400, 0x00006400 },	/* HT_PHY_DLL_REG */
-
-	{ 0xCF, AMD_FAM10_ALL, AMD_PTYPE_ALL, HTPHY_LINKTYPE_HT3,
-	  0x00000000, 0x000000FF },	/* Provide clear setting for logical
-					   completeness */
-
-	{ 0xDF, AMD_FAM10_ALL, AMD_PTYPE_ALL, HTPHY_LINKTYPE_HT3,
-	  0x00000000, 0x000000FF },	/* Provide clear setting for logical
-					   completeness */
-
-	{ 0xCF, AMD_FAM10_ALL, AMD_PTYPE_ALL, HTPHY_LINKTYPE_HT1,
-	  0x0000006D, 0x000000FF },	/* HT_PHY_HT1_FIFO_PTR_OPT_VALUE */
-
-	{ 0xDF, AMD_FAM10_ALL, AMD_PTYPE_ALL,  HTPHY_LINKTYPE_HT1,
-	  0x0000006D, 0x000000FF }, 	/* HT_PHY_HT1_FIFO_PTR_OPT_VALUE */
-
-	/* Link Phy Receiver Loop Filter Registers */
-	{ 0xD1, AMD_FAM10_ALL, AMD_PTYPE_ALL, HTPHY_LINKTYPE_HT3,
-	  0x08040000, 0x3FFFC000 },	/* [29:22] LfcMax = 20h,
-					   [21:14] LfcMin = 10h */
-
-	{ 0xC1, AMD_FAM10_ALL, AMD_PTYPE_ALL, HTPHY_LINKTYPE_HT3,
-	  0x08040000, 0x3FFFC000 },	/* [29:22] LfcMax = 20h,
-					   [21:14] LfcMin = 10h */
-
-	{ 0xD1, AMD_FAM10_ALL, AMD_PTYPE_ALL, HTPHY_LINKTYPE_HT1,
-	  0x04020000, 0x3FFFC000 },	/* [29:22] LfcMax = 10h,
-					   [21:14] LfcMin = 08h */
-
-	{ 0xC1, AMD_FAM10_ALL, AMD_PTYPE_ALL, HTPHY_LINKTYPE_HT1,
-	  0x04020000, 0x3FFFC000 },	/* [29:22] LfcMax = 10h,
-					   [21:14] LfcMin = 08h */
-
-	{ 0xC0, AMD_FAM10_ALL, AMD_PTYPE_ALL, HTPHY_LINKTYPE_ALL,
-	  0x40040000, 0xe01F0000 },	/* [31:29] RttCtl = 02h,
-								   [20:16] RttIndex = 04h */
-};
diff --git a/src/cpu/amd/model_10xxx/fidvid.c b/src/cpu/amd/model_10xxx/fidvid.c
deleted file mode 100644
index 5b1c581..0000000
--- a/src/cpu/amd/model_10xxx/fidvid.c
+++ /dev/null
@@ -1,1048 +0,0 @@
-/*
- * This file is part of the coreboot project.
- *
- * Copyright (C) 2007 Advanced Micro Devices, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc.
- */
-/*
- * This file initializes the CPU cores for voltage and frequency settings
- * in the different power states.
- */
-/*
-
-checklist (functions are in this file if no source file named)
-Fam10 Bios and Kernel Development Guide #31116, rev 3.48, April 22, 2010
-
-2.4.2.6 Requirements for p-states
-
-1.- F3x[84:80] According to table 100 : prep_fid_change
-
-2.- COF/VID :
-     2.4.2.9.1 Steps 1,3-6 and warning for 2,7 if they apply
-               fixPsNbVidBeforeWR(...)
-     2.4.2.9.1 Step 8 enable_fid_change
-               We do this for all nodes, I don't understand BKDG 100% on
-               whether this is or isn't meant by "on the local
-               processor". Must be OK.
-     2.4.2.9.1 Steps 9-10 (repeat 1-7 and reset) romstage.c/init_cpus ?
-     2.4.2.9.1 Steps 11-12 init_fidvid_stage2
-     2.4.2.9.2 DualPlane PVI : Not supported, don't know how to detect,
-               needs specific circuitry.
-
-3.-  2.4.2.7 dualPlaneOnly(dev)
-
-4.-  2.4.2.8 applyBoostFIDOffset(dev)
-
-5.-  enableNbPState1(dev)
-
-6.- 2.4.1.7
-    a) UpdateSinglePlaneNbVid()
-    b) setVSRamp(), called from  prep_fid_change
-    c) prep_fid_change
-    d) improperly, for lack of voltage regulator details?,
-        F3xA0[PsiVidEn] in defaults.h
-        F3xA0[PsiVid] in init_cpus.c AMD_SetupPSIVID_d (before prep_fid_change)
-
-7.- TODO (Core Performance Boost is only available in revision E cpus, and we
-          don't seem to support those yet, at least they don't have any
-          constant in amddefs.h )
-
-8.- FIXME ? Transition to min Pstate according to 2.4.2.15.3 is required
-    by 2.4.2.6 after warm reset. But 2.4.2.15 states that it is not required
-    if the warm reset is issued by coreboot to update NbFid. So it is required
-    or not ? How can I tell who issued warm reset ?
-    Coreboot transitions to P0 instead, which is not recommended, and does
-    not follow 2.4.2.15.2 to do so.
-
-9.- TODO Requires information on current delivery capability
-    (depends on mainboard and maybe power supply ?). One might use a config
-    option with the maximum number of Amperes that the board can deliver to CPU.
-
-10.- [Multiprocessor] TODO 2.4.2.12
-     [Uniprocessor] FIXME ? We call setPStateMaxVal() in init_fidvid_stage2,
-     but not sure this is what is meant by "Determine the valid set of
-     P-states based on enabled P-states indicated
-     in MSRC001_00[68:64][PstateEn]" in 2.4.2.6-10
-
-11.- finalPstateChange() from init_fidvid_Stage2 (BKDG says just "may", anyway)
-
-12.- generate ACPI for p-states.
-     generated in powernow_acpi.c amd_generate_powernow()
-
-"must also be completed"
-
-a.-  PllLockTime set in ruleset in defaults.h
-     BKDG says set it "If MSRC001_00[68:64][CpuFid] is different between
-     any two enabled P-states", but since it does not say "only if"
-     I guess it is safe to do it always.
-
-b.-  prep_fid_change(...)
-
- */
-
-#if CONFIG_SET_FIDVID
-
-#include <northbridge/amd/amdht/AsPsDefs.h>
-
-static inline void print_debug_fv(const char *str, u32 val)
-{
-#if CONFIG_SET_FIDVID_DEBUG
-	printk(BIOS_DEBUG, "%s%x\n", str, val);
-#endif
-}
-
-static inline void print_debug_fv_8(const char *str, u8 val)
-{
-#if CONFIG_SET_FIDVID_DEBUG
-	printk(BIOS_DEBUG, "%s%02x\n", str, val);
-#endif
-}
-
-static inline void print_debug_fv_64(const char *str, u32 val, u32 val2)
-{
-#if CONFIG_SET_FIDVID_DEBUG
-	printk(BIOS_DEBUG, "%s%x%x\n", str, val, val2);
-#endif
-}
-
-struct fidvid_st {
-	u32 common_fid;
-};
-
-static void enable_fid_change(u8 fid)
-{
-	u32 dword;
-	u32 nodes;
-	device_t dev;
-	int i;
-
-	nodes = get_nodes();
-
-	for (i = 0; i < nodes; i++) {
-		dev = NODE_PCI(i, 3);
-		dword = pci_read_config32(dev, 0xd4);
-		dword &= ~0x1F;
-		dword |= (u32) fid & 0x1F;
-		dword |= 1 << 5;	// enable
-		pci_write_config32(dev, 0xd4, dword);
-		printk(BIOS_DEBUG, "FID Change Node:%02x, F3xD4: %08x \n", i,
-		       dword);
-	}
-}
-
-static void applyBoostFIDOffset(  device_t dev ) {
-  // BKDG 2.4.2.8
-  // revision E only, but E is apparently not supported yet, therefore untested
-  if ((cpuid_edx(0x80000007) & CPB_MASK)
-      &&  ((cpuid_ecx(0x80000008) & NC_MASK) ==5) ) {
-      u32 core =  get_node_core_id_x().coreid;
-      u32 asymetricBoostThisCore = ((pci_read_config32(dev, 0x10C) >> (core*2))) & 3;
-      msr_t msr =  rdmsr(PS_REG_BASE);
-      u32 cpuFid = msr.lo & PS_CPU_FID_MASK;
-      cpuFid = cpuFid + asymetricBoostThisCore;
-      msr.lo &=   ~PS_CPU_FID_MASK;
-      msr.lo |= cpuFid ;
-      wrmsr(PS_REG_BASE , msr);
-
-  }
-}
-
-static void enableNbPState1( device_t dev ) {
-  u32 cpuRev =  mctGetLogicalCPUID(0xFF);
-  if (cpuRev & AMD_FAM10_C3) {
-    u32 nbPState = (pci_read_config32(dev, 0x1F0) & NB_PSTATE_MASK);
-    if ( nbPState){
-      u32 nbVid1 = (pci_read_config32(dev, 0x1F4) & NB_VID1_MASK) >> NB_VID1_SHIFT;
-      u32 i;
-      for (i = nbPState; i < NM_PS_REG; i++) {
-         msr_t msr =  rdmsr(PS_REG_BASE + i);
-         if (msr.hi &  PS_EN_MASK ) {
-            msr.hi |= NB_DID_M_ON;
-            msr.lo &= NB_VID_MASK_OFF;
-	    msr.lo |= ( nbVid1 << NB_VID_POS);
-	    wrmsr(PS_REG_BASE + i, msr);
-	 }
-      }
-    }
-  }
-}
-
-static u8 setPStateMaxVal( device_t dev ) {
-      u8 i,maxpstate=0;
-      for (i = 0; i < NM_PS_REG; i++) {
-         msr_t msr =  rdmsr(PS_REG_BASE + i);
-         if (msr.hi & PS_IDD_VALUE_MASK) {
-	   msr.hi |= PS_EN_MASK ;
-	     wrmsr(PS_REG_BASE + i, msr);
-	 }
-         if (msr.hi & PS_EN_MASK) {
-	   maxpstate = i;
-	 }
-      }
-      //FIXME: CPTC2 and HTC_REG should get max per node, not per core ?
-      u32 reg = pci_read_config32(dev, CPTC2);
-      reg &= PS_MAX_VAL_MASK;
-      reg |= (maxpstate << PS_MAX_VAL_POS);
-      pci_write_config32(dev, CPTC2,reg);
-      return maxpstate;
-}
-
-static void dualPlaneOnly(  device_t dev ) {
-  // BKDG 2.4.2.7
-
-  u32 cpuRev =  mctGetLogicalCPUID(0xFF);
-  if ((mctGetProcessorPackageType() ==  AMD_PKGTYPE_AM3_2r2)
-      && (cpuRev & AMD_DR_Cx)) { // should be rev C or rev E but there's no constant for E
-    if ( (pci_read_config32(dev, 0x1FC) & DUAL_PLANE_ONLY_MASK)
-	 && (pci_read_config32(dev, 0xA0) & PVI_MODE) ){
-      if (cpuid_edx(0x80000007) & CPB_MASK) {
-          // revision E only, but E is apparently not supported yet, therefore untested
-         msr_t minPstate = rdmsr(0xC0010065);
-         wrmsr(0xC0010065, rdmsr(0xC0010068) );
-         wrmsr(0xC0010068,minPstate);
-      } else {
-	 msr_t msr;
-         msr.lo=0; msr.hi=0;
-         wrmsr(0xC0010064, rdmsr(0xC0010068) );
-         wrmsr(0xC0010068, msr );
-      }
-
-      //FIXME: CPTC2 and HTC_REG should get max per node, not per core ?
-      u8 maxpstate = setPStateMaxVal(dev);
-
-      u32 reg = pci_read_config32(dev, HTC_REG);
-      reg &= HTC_PS_LMT_MASK;
-      reg |= (maxpstate << PS_LIMIT_POS);
-      pci_write_config32(dev, HTC_REG,reg);
-
-    }
-  }
-}
-
-static int vidTo100uV(u8 vid)
-{// returns voltage corresponding to vid in tenths of mV, i.e. hundreds of uV
- // BKDG #31116 rev 3.48 2.4.1.6
-  int voltage;
-  if (vid >= 0x7c) {
-    voltage = 0;
-  } else {
-    voltage = (15500 - (125*vid));
-  }
-  return voltage;
-}
-
-static void setVSRamp(device_t dev) {
-	/* BKDG r31116 2010-04-22  2.4.1.7 step b F3xD8[VSRampTime]
-         * If this field accepts 8 values between 10 and 500 us why
-         * does page 324 say "BIOS should set this field to 001b."
-         * (20 us) ?
-         * Shouldn't it depend on the voltage regulators, mainboard
-         * or something ?
-         */
-        u32 dword;
-	dword = pci_read_config32(dev, 0xd8);
-	dword &= VSRAMP_MASK;
-	dword |= VSRAMP_VALUE;
-	pci_write_config32(dev, 0xd8, dword);
-}
-
-static void recalculateVsSlamTimeSettingOnCorePre(device_t dev)
-{
-	u8 pviModeFlag;
-	u8 highVoltageVid, lowVoltageVid, bValue;
-	u16 minimumSlamTime;
-	u16 vSlamTimes[7] = { 1000, 2000, 3000, 4000, 6000, 10000, 20000 };	/* Reg settings scaled by 100 */
-	u32 dtemp;
-	msr_t msr;
-
-	/* This function calculates the VsSlamTime using the range of possible
-	 * voltages instead of a hardcoded 200us.
-         * Note: his function is called only from prep_fid_change,
-         * and that from init_cpus.c finalize_node_setup()
-         * (after set AMD MSRs and init ht )
-	 */
-
-        /* BKDG r31116 2010-04-22  2.4.1.7 step b F3xD8[VSSlamTime] */
-	/* Calculate Slam Time
-	 * Vslam = (mobileCPU?0.2:0.4)us/mV * (Vp0 - (lowest out of Vpmin or Valt)) mV
-	 * In our case, we will scale the values by 100 to avoid
-	 * decimals.
-	 */
-
-	/* Determine if this is a PVI or SVI system */
-	dtemp = pci_read_config32(dev, 0xA0);
-
-	if (dtemp & PVI_MODE)
-		pviModeFlag = 1;
-	else
-		pviModeFlag = 0;
-
-	/* Get P0's voltage */
-        /* MSRC001_00[68:64] are not programmed yet when called from
-	   prep_fid_change, one might use F4x1[F0:E0] instead, but
-	   theoretically MSRC001_00[68:64] are equal to them after
-	   reset. */
-	msr = rdmsr(0xC0010064);
-	highVoltageVid = (u8) ((msr.lo >> PS_CPU_VID_SHFT) & 0x7F);
-        if (!(msr.hi & 0x80000000)) {
-  	    printk(BIOS_ERR,"P-state info in MSRC001_0064 is invalid !!!\n");
-            highVoltageVid = (u8) ((pci_read_config32(dev, 0x1E0)
-                                     >> PS_CPU_VID_SHFT) & 0x7F);
-	}
-
-	/* If SVI, we only care about CPU VID.
-	 * If PVI, determine the higher voltage b/t NB and CPU
-	 */
-	if (pviModeFlag) {
-		bValue = (u8) ((msr.lo >> PS_NB_VID_SHFT) & 0x7F);
-		if (highVoltageVid > bValue)
-			highVoltageVid = bValue;
-	}
-
-	/* Get PSmax's index */
-	msr = rdmsr(0xC0010061);
-	bValue = (u8) ((msr.lo >> PS_MAX_VAL_SHFT) & BIT_MASK_3);
-
-	/* Get PSmax's VID */
-	msr = rdmsr(0xC0010064 + bValue);
-	lowVoltageVid = (u8) ((msr.lo >> PS_CPU_VID_SHFT) & 0x7F);
-        if (!(msr.hi & 0x80000000)) {
-	    printk(BIOS_ERR,"P-state info in MSR%8x is invalid !!!\n",0xC0010064 + bValue);
-            lowVoltageVid = (u8) ((pci_read_config32(dev, 0x1E0+(bValue*4))
-                                     >> PS_CPU_VID_SHFT) & 0x7F);
-	}
-
-	/* If SVI, we only care about CPU VID.
-	 * If PVI, determine the higher voltage b/t NB and CPU
-         * BKDG 2.4.1.7 (a)
- 	 */
-	if (pviModeFlag) {
-		bValue = (u8) ((msr.lo >> PS_NB_VID_SHFT) & 0x7F);
-		if (lowVoltageVid > bValue)
-			lowVoltageVid = bValue;
-	}
-
-	/* Get AltVID */
-	dtemp = pci_read_config32(dev, 0xDC);
-	bValue = (u8) (dtemp & BIT_MASK_7);
-
-	/* Use the VID with the lowest voltage (higher VID) */
-	if (lowVoltageVid < bValue)
-		lowVoltageVid = bValue;
-
-        u8 mobileFlag = get_platform_type() & AMD_PTYPE_MOB;
-	minimumSlamTime =  (mobileFlag?2:4) * (vidTo100uV(highVoltageVid) - vidTo100uV(lowVoltageVid)); /* * 0.01 us */
-
-
-	/* Now round up to nearest register setting.
-	 * Note that if we don't find a value, we
-	 * will fall through to a value of 7
-	 */
-	for (bValue = 0; bValue < 7; bValue++) {
-		if (minimumSlamTime <= vSlamTimes[bValue])
-			break;
-	}
-
-	/* Apply the value */
-	dtemp = pci_read_config32(dev, 0xD8);
-	dtemp &= VSSLAM_MASK;
-	dtemp |= bValue;
-	pci_write_config32(dev, 0xd8, dtemp);
-}
-
-static u32 nb_clk_did(int node, u32 cpuRev,u8 procPkg) {
-        u8 link0isGen3 = 0;
-        u8 offset;
-        if (AMD_CpuFindCapability(node, 0, &offset)) {
-	  link0isGen3 = (AMD_checkLinkType(node, 0, offset) & HTPHY_LINKTYPE_HT3 );
-	}
-        /* FIXME: NB_CLKDID should be 101b for AMD_DA_C2 in package
-           S1g3 in link Gen3 mode, but I don't know how to tell
-           package S1g3 from S1g4 */
-	if ((cpuRev & AMD_DA_C2) && (procPkg & AMD_PKGTYPE_S1gX)
-           && link0isGen3) {
-	  return 5 ; /* divide clk by 128*/
-        } else {
-	  return 4 ; /* divide clk by 16 */
-        }
-}
-
-
-static u32 power_up_down(int node, u8 procPkg) {
-       u32 dword=0;
-        /* from CPU rev guide #41322 rev 3.74 June 2010 Table 26 */
-        u8 singleLinkFlag = ((procPkg == AMD_PKGTYPE_AM3_2r2)
-                             || (procPkg == AMD_PKGTYPE_S1gX)
-                             || (procPkg == AMD_PKGTYPE_ASB2));
-
-        if (singleLinkFlag) {
-	  /*
-           * PowerStepUp=01000b - 50nS
-	   * PowerStepDown=01000b - 50ns
-	   */
-	  dword |= PW_STP_UP50 | PW_STP_DN50;
-	} else {
-          u32 dispRefModeEn = (pci_read_config32(NODE_PCI(node,0),0x68) >> 24) & 1;
-          u32 isocEn = 0;
-          int j;
-	  for(j=0 ; (j<4) && (!isocEn) ; j++ ) {
-	    u8 offset;
-	    if (AMD_CpuFindCapability(node, j, &offset)) {
-	      isocEn = (pci_read_config32(NODE_PCI(node,0),offset+4) >>12) & 1;
-	    }
-          }
-
-          if (dispRefModeEn || isocEn) {
-        	dword |= PW_STP_UP50 | PW_STP_DN50 ;
-          } else {
-		/* get number of cores for PowerStepUp & PowerStepDown in server
-		   1 core - 400nS  - 0000b
-		   2 cores - 200nS - 0010b
-		   3 cores - 133nS -> 100nS - 0011b
-		   4 cores - 100nS - 0011b
-		 */
-		switch (get_core_num_in_bsp(node)) {
-		case 0:
-			dword |= PW_STP_UP400 | PW_STP_DN400;
-			break;
-		case 1:
-		case 2:
-			dword |= PW_STP_UP200 | PW_STP_DN200;
-			break;
-		case 3:
-			dword |= PW_STP_UP100 | PW_STP_DN100;
-			break;
-		default:
-			dword |= PW_STP_UP100 | PW_STP_DN100;
-			break;
-		}
-	  }
-	}
-        return dword;
-}
-
-static void config_clk_power_ctrl_reg0(int node, u32 cpuRev, u8 procPkg) {
-       	device_t dev = NODE_PCI(node, 3);
-
-	/* Program fields in Clock Power/Control register0 (F3xD4) */
-
-	/* set F3xD4 Clock Power/Timing Control 0 Register
-	 * NbClkDidApplyAll=1b
-	 * NbClkDid=100b or 101b
-	 * PowerStepUp= "platform dependent"
-	 * PowerStepDown= "platform dependent"
-	 * LinkPllLink=01b
-	 * ClkRampHystCtl=HW default
-         * ClkRampHystSel=1111b
-	 */
-        u32 dword= pci_read_config32(dev, 0xd4);
-	dword &= CPTC0_MASK;
-        dword |= NB_CLKDID_ALL | LNK_PLL_LOCK | CLK_RAMP_HYST_SEL_VAL;
-        dword |= (nb_clk_did(node,cpuRev,procPkg) <<  NB_CLKDID_SHIFT);
-
-        dword |= power_up_down(node, procPkg);
-
-	pci_write_config32(dev, 0xd4, dword);
-
-}
-
-static void config_power_ctrl_misc_reg(device_t dev,u32 cpuRev, u8 procPkg) {
-	/* check PVI/SVI */
-	u32 dword = pci_read_config32(dev, 0xa0);
-
-	/* BKDG r31116 2010-04-22  2.4.1.7 step b F3xA0[VSSlamVidMod] */
-	/* PllLockTime and PsiVidEn set in ruleset in defaults.h */
-	if (dword & PVI_MODE) {	/* PVI */
-		/* set slamVidMode to 0 for PVI */
-		dword &= VID_SLAM_OFF ;
-	} else {	/* SVI */
-		/* set slamVidMode to 1 for SVI */
-		dword |= VID_SLAM_ON;
-	}
-        /* set the rest of A0 since we're at it... */
-
-	if (cpuRev & (AMD_DA_Cx | AMD_RB_C3 )) {
-		dword |= NB_PSTATE_FORCE_ON;
-	} // else should we clear it ?
-
-
-        if ((procPkg == AMD_PKGTYPE_G34) || (procPkg == AMD_PKGTYPE_C32) ) {
-		dword |= BP_INS_TRI_EN_ON ;
-	}
-
-	   /* TODO: look into C1E state and F3xA0[IdleExitEn]*/
-        #if CONFIG_SVI_HIGH_FREQ
-	if (cpuRev & AMD_FAM10_C3) {
-		dword |= SVI_HIGH_FREQ_ON;
-	}
-	#endif
-	pci_write_config32(dev, 0xa0, dword);
-}
-
-static void config_nb_syn_ptr_adj(device_t dev, u32 cpuRev) {
-	/* Note the following settings are additional from the ported
-	 * function setFidVidRegs()
-	 */
-        /* adjust FIFO between nb and core clocks to max allowed
-           values (min latency) */
-	u32 nbPstate = pci_read_config32(dev,0x1f0) & NB_PSTATE_MASK;
-        u8 nbSynPtrAdj;
-	if ((cpuRev & (AMD_DR_Bx|AMD_DA_Cx) )
-	    || ( (cpuRev & AMD_RB_C3) && (nbPstate!=0)))  {
-	  nbSynPtrAdj = 5;
-	} else {
-          nbSynPtrAdj = 6;
-	}
-
-	u32 dword = pci_read_config32(dev, 0xDc);
-        dword &= ~ NB_SYN_PTR_ADJ_MASK;
-	dword |= nbSynPtrAdj << NB_SYN_PTR_ADJ_POS;
-        /* NbsynPtrAdj set to 5 or 6 per BKDG (needs reset) */
-	pci_write_config32(dev, 0xdc, dword);
-}
-
-static void config_acpi_pwr_state_ctrl_regs(device_t dev, u32 cpuRev, u8 procPkg) {
-                /* step 1, chapter 2.4.2.6 of AMD Fam 10 BKDG #31116 Rev 3.48 22.4.2010 */
-        u32 dword;
-	u32 c1= 1;
-        if (cpuRev & (AMD_DR_Bx)) {
-            // will coreboot ever enable cache scrubbing ?
-            // if it does, will it be enough to check the current state
-            // or should we configure for what we'll set up later ?
-            dword = pci_read_config32(dev, 0x58);
-            u32 scrubbingCache = dword &
-	                        ( (0x1F << 16) // DCacheScrub
-		 	          | (0x1F << 8) ); // L2Scrub
- 	    if (scrubbingCache) {
-	        c1 = 0x80;
-	    } else {
-	        c1 = 0xA0;
-	    }
-	} else { // rev C or later
-	    // same doubt as cache scrubbing: ok to check current state ?
-            dword = pci_read_config32(dev, 0xDC);
-            u32 cacheFlushOnHalt = dword & (7 << 16);
-            if (!cacheFlushOnHalt) {
-       	       c1 = 0x80;
-       	    }
-       	}
-       	dword = (c1 << 24) | (0xE641E6);
-	pci_write_config32(dev, 0x84, dword);
-
-
-        /* FIXME: BKDG Table 100 says if the link is at a Gen1
-frequency and the chipset does not support a 10us minimum LDTSTOP
-assertion time, then { If ASB2 && SVI then smaf001 = F6h else
-smaf001=87h. } else ...  I hardly know what it means or how to check
-it from here, so I bluntly assume it is false and code here the else,
-which is easier  */
-
-        u32 smaf001 = 0xE6;
-        if (cpuRev & AMD_DR_Bx ) {
-	    smaf001 = 0xA6;
-        } else {
-            #if CONFIG_SVI_HIGH_FREQ
-                if (cpuRev & (AMD_RB_C3 | AMD_DA_C3)) {
-		       smaf001 = 0xF6;
-                }
-            #endif
-        }
-        u32 fidvidChange = 0;
-        if (((cpuRev & AMD_DA_Cx) && (procPkg & AMD_PKGTYPE_S1gX))
-		    || (cpuRev & AMD_RB_C3) ) {
-                       fidvidChange=0x0B;
-        }
-	dword = (0xE6 << 24) | (fidvidChange << 16)
-                        | (smaf001 << 8) | 0x81;
-	pci_write_config32(dev, 0x80, dword);
-}
-
-static void prep_fid_change(void)
-{
-        u32 dword;
-	u32 nodes;
-	device_t dev;
-	int i;
-
-	/* This needs to be run before any Pstate changes are requested */
-
-	nodes = get_nodes();
-
-	for (i = 0; i < nodes; i++) {
-		printk(BIOS_DEBUG, "Prep FID/VID Node:%02x\n", i);
-		dev = NODE_PCI(i, 3);
-                u32 cpuRev = mctGetLogicalCPUID(0xFF) ;
-	        u8 procPkg =  mctGetProcessorPackageType();
-
-		setVSRamp(dev);
-		/* BKDG r31116 2010-04-22  2.4.1.7 step b F3xD8[VSSlamTime] */
-		/* Figure out the value for VsSlamTime and program it */
-		recalculateVsSlamTimeSettingOnCorePre(dev);
-
-		config_clk_power_ctrl_reg0(i,cpuRev,procPkg);
-
-                config_power_ctrl_misc_reg(dev,cpuRev,procPkg);
-		config_nb_syn_ptr_adj(dev,cpuRev);
-
-		config_acpi_pwr_state_ctrl_regs(dev,cpuRev,procPkg);
-
-		dword = pci_read_config32(dev, 0x80);
-		printk(BIOS_DEBUG, "  F3x80: %08x\n", dword);
-		dword = pci_read_config32(dev, 0x84);
-		printk(BIOS_DEBUG, "  F3x84: %08x\n", dword);
-		dword = pci_read_config32(dev, 0xD4);
-		printk(BIOS_DEBUG, "  F3xD4: %08x\n", dword);
-		dword = pci_read_config32(dev, 0xD8);
-		printk(BIOS_DEBUG, "  F3xD8: %08x\n", dword);
-		dword = pci_read_config32(dev, 0xDC);
-		printk(BIOS_DEBUG, "  F3xDC: %08x\n", dword);
-	}
-}
-
-static void waitCurrentPstate(u32 target_pstate){
-  msr_t initial_msr = rdmsr(TSC_MSR);
-  msr_t pstate_msr = rdmsr(CUR_PSTATE_MSR);
-  msr_t tsc_msr;
-  u8 timedout ;
-
-  /* paranoia ? I fear when we run fixPsNbVidBeforeWR we can enter a
-   * P1 that is a copy of P0, therefore has the same NB DID but the
-   * TSC will count twice per tick, so we have to wait for twice the
-   * count to achieve the desired timeout. But I'm likely to
-   * misunderstand this...
-   */
-  u32 corrected_timeout = (    (pstate_msr.lo==1)
-			    && (!(rdmsr(0xC0010065).lo & NB_DID_M_ON)) ) ?
-                          WAIT_PSTATE_TIMEOUT*2 : WAIT_PSTATE_TIMEOUT  ;
-  msr_t timeout;
-
-  timeout.lo = initial_msr.lo + corrected_timeout ;
-  timeout.hi = initial_msr.hi;
-  if ( (((u32)0xffffffff) - initial_msr.lo) < corrected_timeout ) {
-     timeout.hi++;
-  }
-
-  // assuming TSC ticks at 1.25 ns per tick (800 MHz)
-  do {
-      pstate_msr = rdmsr(CUR_PSTATE_MSR);
-      tsc_msr = rdmsr(TSC_MSR);
-      timedout = (tsc_msr.hi > timeout.hi)
-        	|| ((tsc_msr.hi == timeout.hi) && (tsc_msr.lo > timeout.lo ));
-  } while ( (pstate_msr.lo != target_pstate) && (! timedout) ) ;
-
-  if (pstate_msr.lo != target_pstate) {
-    msr_t limit_msr = rdmsr(0xc0010061);
-    printk(BIOS_ERR, "*** Time out waiting for P-state %01x. Current P-state %01x P-state current limit MSRC001_0061=%02x\n", target_pstate, pstate_msr.lo, limit_msr.lo);
-
-    do { // should we just go on instead ?
-      pstate_msr = rdmsr(CUR_PSTATE_MSR);
-    } while ( pstate_msr.lo != target_pstate  ) ;
-  }
-}
-
-static void set_pstate(u32 nonBoostedPState) {
-  	msr_t msr;
-
-	// Transition P0 for calling core.
-	msr = rdmsr(0xC0010062);
-
-	msr.lo = nonBoostedPState;
-	wrmsr(0xC0010062, msr);
-
-	/* Wait for P0 to set. */
-        waitCurrentPstate(nonBoostedPState);
-}
-
-
-
-
-static void UpdateSinglePlaneNbVid(void)
-{
-	u32 nbVid, cpuVid;
-	u8 i;
-	msr_t msr;
-
-	/* copy higher voltage (lower VID) of NBVID & CPUVID to both */
-	for (i = 0; i < 5; i++) {
-		msr = rdmsr(PS_REG_BASE + i);
-		nbVid = (msr.lo & PS_CPU_VID_M_ON) >> PS_CPU_VID_SHFT;
-		cpuVid = (msr.lo & PS_NB_VID_M_ON) >> PS_NB_VID_SHFT;
-
-		if (nbVid != cpuVid) {
-			if (nbVid > cpuVid)
-				nbVid = cpuVid;
-
-			msr.lo = msr.lo & PS_BOTH_VID_OFF;
-			msr.lo = msr.lo | (u32) ((nbVid) << PS_NB_VID_SHFT);
-			msr.lo = msr.lo | (u32) ((nbVid) << PS_CPU_VID_SHFT);
-			wrmsr(PS_REG_BASE + i, msr);
-		}
-	}
-}
-
-static void fixPsNbVidBeforeWR(u32 newNbVid, u32 coreid, u32 dev, u8 pviMode)
- {
- 	msr_t msr;
- 	u8 startup_pstate;
-
- 	/* This function sets NbVid before the warm reset.
- 	 *       Get StartupPstate from MSRC001_0071.
-	 *       Read Pstate register pointed by [StartupPstate].
- 	 *       and copy its content to P0 and P1 registers.
- 	 *       Copy newNbVid to P0[NbVid].
- 	 *       transition to P1 on all cores,
- 	 *       then transition to P0 on core 0.
- 	 *       Wait for MSRC001_0063[CurPstate] = 000b on core 0.
-         * see BKDG rev 3.48  2.4.2.9.1 BIOS NB COF and VID Configuration
-         *                              for SVI and Single-Plane PVI Systems
- 	 */
-
- 	msr = rdmsr(0xc0010071);
-	startup_pstate = (msr.hi >> (32 - 32)) & 0x07;
-
-	/* Copy startup pstate to P1 and P0 MSRs. Set the maxvid for
-	 * this node in P0.  Then transition to P1 for corex and P0
-	 * for core0.  These setting will be cleared by the warm reset
-	 */
-	msr = rdmsr(0xC0010064 + startup_pstate);
-	wrmsr(0xC0010065, msr);
-	wrmsr(0xC0010064, msr);
-
-        /* missing step 2 from BDKG , F3xDC[PstateMaxVal] =
-         * max(1,F3xDC[PstateMaxVal] ) because it would take
-         * synchronization between cores and we don't think
-         * PstatMaxVal is going to be 0 on cold reset anyway ?
-	 */
-        if ( ! (pci_read_config32(dev, 0xDC) & (~ PS_MAX_VAL_MASK)) ) {
-  	   printk(BIOS_ERR,"F3xDC[PstateMaxVal] is zero. Northbridge voltage setting will fail. fixPsNbVidBeforeWR in fidvid.c needs fixing. See AMD # 31116 rev 3.48 BKDG 2.4.2.9.1 \n");
-	};
-
-	msr.lo &= ~0xFE000000;	// clear nbvid
-	msr.lo |= (newNbVid << 25);
-	wrmsr(0xC0010064, msr);
-
-	if (pviMode) { /* single plane*/
-	  UpdateSinglePlaneNbVid();
-        }
-
-	// Transition to P1 for all APs and P0 for core0.
-        set_pstate(1);
-
-	if (coreid == 0) {
-             set_pstate(0);
- 	}
-
-	/* missing step 7 (restore PstateMax to 0 if needed) because
-	 * we skipped step 2
-	 */
-
-}
-
-static u32 needs_NB_COF_VID_update(void)
-{
-	u8 nb_cof_vid_update;
-	u8 nodes;
-	u8 i;
-
-	/* If any node has nb_cof_vid_update set all nodes need an update. */
-	nodes = get_nodes();
-	nb_cof_vid_update = 0;
-	for (i = 0; i < nodes; i++) {
-                u32 cpuRev = mctGetLogicalCPUID(i) ;
-                u32 nbCofVidUpdateDefined = (cpuRev & (AMD_FAM10_LT_D));
-		if (nbCofVidUpdateDefined
-                    && (pci_read_config32(NODE_PCI(i, 3), 0x1FC)
-                        & NB_COF_VID_UPDATE_MASK)) {
-			nb_cof_vid_update = 1;
-			break;
-		}
-	}
-	return nb_cof_vid_update;
-}
-
-static u32 init_fidvid_core(u32 nodeid, u32 coreid)
-{
-	device_t dev;
-	u32 vid_max;
-	u32 fid_max = 0;
-	u8 nb_cof_vid_update = needs_NB_COF_VID_update();
-	u8 pvimode;
-	u32 reg1fc;
-
-	/* Steps 1-6 of BIOS NB COF and VID Configuration
-	 * for SVI and Single-Plane PVI Systems. BKDG 2.4.2.9 #31116 rev 3.48
-	 */
-
-	dev = NODE_PCI(nodeid, 3);
-	pvimode = pci_read_config32(dev, PW_CTL_MISC) & PVI_MODE;
-	reg1fc = pci_read_config32(dev, 0x1FC);
-
-	if (nb_cof_vid_update) {
-                vid_max = (reg1fc &  SINGLE_PLANE_NB_VID_MASK ) >>  SINGLE_PLANE_NB_VID_SHIFT ;
-	        fid_max = (reg1fc &  SINGLE_PLANE_NB_FID_MASK ) >>  SINGLE_PLANE_NB_FID_SHIFT ;
-
-	        if (!pvimode) { /* SVI, dual power plane */
-         		vid_max = vid_max - ((reg1fc &  DUAL_PLANE_NB_VID_OFF_MASK ) >>  DUAL_PLANE_NB_VID_SHIFT );
-			fid_max = fid_max +  ((reg1fc &  DUAL_PLANE_NB_FID_OFF_MASK ) >>  DUAL_PLANE_NB_FID_SHIFT );
-		}
-		/* write newNbVid to P-state Reg's NbVid always if NbVidUpdatedAll=1 */
-		fixPsNbVidBeforeWR(vid_max, coreid,dev,pvimode);
-
-		/* fid setup is handled by the BSP at the end. */
-
-	} else {	/* ! nb_cof_vid_update */
-		/* Use max values */
-		if (pvimode)
-			UpdateSinglePlaneNbVid();
-	}
-
-	return ((nb_cof_vid_update << 16) | (fid_max << 8));
-
-}
-
-static void init_fidvid_ap(u32 apicid, u32 nodeid, u32 coreid)
-{
-	u32 send;
-
-	printk(BIOS_DEBUG, "FIDVID on AP: %02x\n", apicid);
-
-        send = init_fidvid_core(nodeid,coreid);
-	send |= (apicid << 24);	// ap apicid
-
-	// Send signal to BSP about this AP max fid
-	// This also indicates this AP is ready for warm reset (if required).
-	lapic_write(LAPIC_MSG_REG, send | F10_APSTATE_RESET);
-}
-
-static u32 calc_common_fid(u32 fid_packed, u32 fid_packed_new)
-{
-	u32 fidmax;
-	u32 fidmax_new;
-
-	fidmax = (fid_packed >> 8) & 0xFF;
-
-	fidmax_new = (fid_packed_new >> 8) & 0xFF;
-
-	if (fidmax > fidmax_new) {
-		fidmax = fidmax_new;
-	}
-
-	fid_packed &= 0xFF << 16;
-	fid_packed |= (fidmax << 8);
-	fid_packed |= fid_packed_new & (0xFF << 16);	// set nb_cof_vid_update
-
-	return fid_packed;
-}
-
-static void init_fidvid_bsp_stage1(u32 ap_apicid, void *gp)
-{
-	u32 readback = 0;
-	u32 timeout = 1;
-
-	struct fidvid_st *fvp = gp;
-	int loop;
-
-	print_debug_fv("Wait for AP stage 1: ap_apicid = ", ap_apicid);
-
-	loop = 100000;
-	while (--loop > 0) {
-		if (lapic_remote_read(ap_apicid, LAPIC_MSG_REG, &readback) != 0)
-			continue;
-		if ((readback & 0x3f) == 1) {
-			timeout = 0;
-			break;	/* target ap is in stage 1 */
-		}
-	}
-
-	if (timeout) {
-		printk(BIOS_DEBUG, "%s: timed out reading from ap %02x\n",
-		       __func__, ap_apicid);
-		return;
-	}
-
-	print_debug_fv("\treadback = ", readback);
-
-	fvp->common_fid = calc_common_fid(fvp->common_fid, readback);
-
-	print_debug_fv("\tcommon_fid(packed) = ", fvp->common_fid);
-
-}
-
-static void fixPsNbVidAfterWR(u32 newNbVid, u8 NbVidUpdatedAll,u8 pviMode)
-{
-	msr_t msr;
-	u8 i;
-	u8 StartupPstate;
-
-	/* BKDG 2.4.2.9.1 11-12
-         * This function copies newNbVid to NbVid bits in P-state
-	 * Registers[4:0] if its NbDid bit=0, and IddValue!=0 in case of
-	 * NbVidUpdatedAll =0 or copies newNbVid to NbVid bits in
-	 * P-state Registers[4:0] if its IddValue!=0 in case of
-	 * NbVidUpdatedAll=1. Then transition to StartPstate.
-	 */
-
-	/* write newNbVid to P-state Reg's NbVid if its NbDid=0 */
-	for (i = 0; i < 5; i++) {
-		msr = rdmsr(0xC0010064 + i);
-		/*  NbDid (bit 22 of P-state Reg) == 0  or NbVidUpdatedAll = 1 */
-		if (   (msr.hi & PS_IDD_VALUE_MASK)
-                    && (msr.hi & PS_EN_MASK)
-                    &&(((msr.lo & PS_NB_DID_MASK) == 0) || NbVidUpdatedAll)) {
-			msr.lo &= PS_NB_VID_M_OFF;
-			msr.lo |= (newNbVid & 0x7F) << PS_NB_VID_SHFT;
-			wrmsr(0xC0010064 + i, msr);
-		}
-	}
-
-        /* Not documented. Would overwrite Nb_Vids just copied
-         * should we just update cpu_vid or nothing at all ?
-	 */
-	if (pviMode) { //single plane
-            UpdateSinglePlaneNbVid();
-	}
-	/* For each core in the system, transition all cores to StartupPstate */
-	msr = rdmsr(0xC0010071);
-	StartupPstate = msr.hi & 0x07;
-
-	/* Set and wait for StartupPstate to set. */
-        set_pstate(StartupPstate);
-
-}
-
-static void finalPstateChange(void)
-{
-	/* Enable P0 on all cores for best performance.
-	 * Linux can slow them down later if need be.
-	 * It is safe since they will be in C1 halt
-	 * most of the time anyway.
-	 */
-	set_pstate(0);
-}
-
-static void init_fidvid_stage2(u32 apicid, u32 nodeid)
-{
-	msr_t msr;
-	device_t dev;
-	u32 reg1fc;
-	u32 dtemp;
-	u32 nbvid;
-	u8 nb_cof_vid_update = needs_NB_COF_VID_update();
-	u8 NbVidUpdateAll;
-	u8 pvimode;
-
-	/* After warm reset finish the fid/vid setup for all cores. */
-
-	/* If any node has nb_cof_vid_update set all nodes need an update. */
-
-	dev = NODE_PCI(nodeid, 3);
-	pvimode = (pci_read_config32(dev, 0xA0) >> 8) & 1;
-	reg1fc = pci_read_config32(dev, 0x1FC);
-	nbvid = (reg1fc >> 7) & 0x7F;
-	NbVidUpdateAll = (reg1fc >> 1) & 1;
-
-	if (nb_cof_vid_update) {
-		if (!pvimode) {	/* SVI */
-			nbvid = nbvid - ((reg1fc >> 17) & 0x1F);
-		}
-		/* write newNbVid to P-state Reg's NbVid if its NbDid=0 */
-		fixPsNbVidAfterWR(nbvid, NbVidUpdateAll,pvimode);
- 	} else {		/* !nb_cof_vid_update */
-		if (pvimode)
-			UpdateSinglePlaneNbVid();
-	}
-	dtemp = pci_read_config32(dev, 0xA0);
-	dtemp &= PLLLOCK_OFF;
-	dtemp |= PLLLOCK_DFT_L;
-	pci_write_config32(dev, 0xA0, dtemp);
-
-        dualPlaneOnly(dev);
-        applyBoostFIDOffset(dev);
-        enableNbPState1(dev);
-
-	finalPstateChange();
-
-	/* Set TSC to tick at the P0 ndfid rate */
-	msr = rdmsr(HWCR);
-	msr.lo |= 1 << 24;
-	wrmsr(HWCR, msr);
-}
-
-
-#if CONFIG_SET_FIDVID_STORE_AP_APICID_AT_FIRST
-struct ap_apicid_st {
-	u32 num;
-	// it could use 256 bytes for 64 node quad core system
-	u8 apicid[NODE_NUMS * 4];
-};
-
-static void store_ap_apicid(unsigned ap_apicid, void *gp)
-{
-	struct ap_apicid_st *p = gp;
-
-	p->apicid[p->num++] = ap_apicid;
-
-}
-#endif
-
-
-static int init_fidvid_bsp(u32 bsp_apicid, u32 nodes)
-{
-#if CONFIG_SET_FIDVID_STORE_AP_APICID_AT_FIRST
-	struct ap_apicid_st ap_apicidx;
-	u32 i;
-#endif
-	struct fidvid_st fv;
-
-	printk(BIOS_DEBUG, "FIDVID on BSP, APIC_id: %02x\n", bsp_apicid);
-
-	/* Steps 1-6 of BIOS NB COF and VID Configuration
-	 * for SVI and Single-Plane PVI Systems.
-	 */
-
-	fv.common_fid = init_fidvid_core(0,0);
-
-	print_debug_fv("BSP fid = ", fv.common_fid);
-
-#if CONFIG_SET_FIDVID_STORE_AP_APICID_AT_FIRST && !CONFIG_SET_FIDVID_CORE0_ONLY
-	/* For all APs (We know the APIC ID of all APs even when the APIC ID
-	   is lifted) remote read from AP LAPIC_MSG_REG about max fid.
-	   Then calculate the common max fid that can be used for all
-	   APs and BSP */
-	ap_apicidx.num = 0;
-
-	for_each_ap(bsp_apicid, CONFIG_SET_FIDVID_CORE_RANGE, store_ap_apicid, &ap_apicidx);
-
-	for (i = 0; i < ap_apicidx.num; i++) {
-		init_fidvid_bsp_stage1(ap_apicidx.apicid[i], &fv);
-	}
-#else
-	for_each_ap(bsp_apicid, CONFIG_SET_FIDVID_CORE0_ONLY, init_fidvid_bsp_stage1, &fv);
-#endif
-
-	print_debug_fv("common_fid = ", fv.common_fid);
-
-	if (fv.common_fid & (1 << 16)) {	/* check nb_cof_vid_update */
-
-		// Enable the common fid and other settings.
-		enable_fid_change((fv.common_fid >> 8) & 0x1F);
-
-		// nbfid change need warm reset, so reset at first
-		return 1;
-	}
-
-	return 0;		// No FID/VID changes. Don't reset
-}
-#endif
diff --git a/src/cpu/amd/model_10xxx/init_cpus.c b/src/cpu/amd/model_10xxx/init_cpus.c
deleted file mode 100644
index 8de6d25..0000000
--- a/src/cpu/amd/model_10xxx/init_cpus.c
+++ /dev/null
@@ -1,968 +0,0 @@
-/*
- * This file is part of the coreboot project.
- *
- * Copyright (C) 2007-2008 Advanced Micro Devices, Inc.
- * Copyright (C) 2015 Timothy Pearson <tpearson@raptorengineeringinc.com>, Raptor Engineering
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc.
- */
-
-#include "cpu/amd/car/post_cache_as_ram.c"
-#include "defaults.h"
-#include <stdlib.h>
-#include <cpu/x86/lapic.h>
-#include <cpu/x86/mtrr.h>
-#include <northbridge/amd/amdfam10/amdfam10.h>
-#include <northbridge/amd/amdht/AsPsDefs.h>
-#include <northbridge/amd/amdht/porting.h>
-
-#include <northbridge/amd/amdfam10/raminit_amdmct.c>
-#include <reset.h>
-
-static void prep_fid_change(void);
-static void init_fidvid_stage2(u32 apicid, u32 nodeid);
-void cpuSetAMDMSR(void);
-
-#if CONFIG_PCI_IO_CFG_EXT
-static void set_EnableCf8ExtCfg(void)
-{
-	// set the NB_CFG[46]=1;
-	msr_t msr;
-	msr = rdmsr(NB_CFG_MSR);
-	// EnableCf8ExtCfg: We need that to access CONFIG_PCI_IO_CFG_EXT 4K range
-	msr.hi |= (1 << (46 - 32));
-	wrmsr(NB_CFG_MSR, msr);
-}
-#else
-static void set_EnableCf8ExtCfg(void) { }
-#endif
-
-
-typedef void (*process_ap_t) (u32 apicid, void *gp);
-
-//core_range = 0 : all cores
-//core range = 1 : core 0 only
-//core range = 2 : cores other than core0
-
-static void for_each_ap(u32 bsp_apicid, u32 core_range, process_ap_t process_ap,
-			void *gp)
-{
-	// here assume the OS don't change our apicid
-	u32 ap_apicid;
-
-	u32 nodes;
-	u32 siblings;
-	u32 disable_siblings;
-	u32 cores_found;
-	u32 nb_cfg_54;
-	int i, j;
-	u32 ApicIdCoreIdSize;
-	uint8_t rev_gte_d = 0;
-	uint8_t dual_node = 0;
-	uint32_t f3xe8;
-
-	/* get_nodes define in ht_wrapper.c */
-	nodes = get_nodes();
-
-	if (!CONFIG_LOGICAL_CPUS ||
-	    read_option(multi_core, 0) != 0) {	// 0 means multi core
-		disable_siblings = 1;
-	} else {
-		disable_siblings = 0;
-	}
-
-	/* Assume that all node are same stepping, otherwise we can use use
-	   nb_cfg_54 from bsp for all nodes */
-	nb_cfg_54 = read_nb_cfg_54();
-	f3xe8 = pci_read_config32(NODE_PCI(0, 3), 0xe8);
-
-	if (cpuid_eax(0x80000001) >= 0x8)
-		/* Revision D or later */
-		rev_gte_d = 1;
-
-	if (rev_gte_d)
-		 /* Check for dual node capability */
-		if (f3xe8 & 0x20000000)
-			dual_node = 1;
-
-	ApicIdCoreIdSize = (cpuid_ecx(0x80000008) >> 12 & 0xf);
-	if (ApicIdCoreIdSize) {
-		siblings = ((1 << ApicIdCoreIdSize) - 1);
-	} else {
-		siblings = 3;	//quad core
-	}
-
-	for (i = 0; i < nodes; i++) {
-		cores_found = get_core_num_in_bsp(i);
-		if (siblings > cores_found)
-			siblings = cores_found;
-
-		u32 jstart, jend;
-
-		if (core_range == 2) {
-			jstart = 1;
-		} else {
-			jstart = 0;
-		}
-
-		if (disable_siblings || (core_range == 1)) {
-			jend = 0;
-		} else {
-			jend = cores_found;
-		}
-
-		for (j = jstart; j <= jend; j++) {
-			if (dual_node) {
-				ap_apicid = 0;
-				if (nb_cfg_54) {
-					ap_apicid |= ((i >> 1) & 0x3) << 4;			/* Node ID */
-					ap_apicid |= ((i & 0x1) * (siblings + 1)) + j;		/* Core ID */
-				} else {
-					ap_apicid |= i & 0x3;					/* Node ID */
-					ap_apicid |= (((i & 0x1) * (siblings + 1)) + j) << 4;	/* Core ID */
-				}
-			} else {
-				ap_apicid =
-				i * (nb_cfg_54 ? (siblings + 1) : 1) +
-				j * (nb_cfg_54 ? 1 : 64);
-			}
-
-
-#if CONFIG_ENABLE_APIC_EXT_ID && (CONFIG_APIC_ID_OFFSET > 0)
-#if !CONFIG_LIFT_BSP_APIC_ID
-			if ((i != 0) || (j != 0))	/* except bsp */
-#endif
-				ap_apicid += CONFIG_APIC_ID_OFFSET;
-#endif
-
-			if (ap_apicid == bsp_apicid)
-				continue;
-
-			process_ap(ap_apicid, gp);
-
-		}
-	}
-}
-
-static inline int lapic_remote_read(int apicid, int reg, u32 *pvalue)
-{
-	int timeout;
-	u32 status;
-	int result;
-	lapic_wait_icr_idle();
-	lapic_write(LAPIC_ICR2, SET_LAPIC_DEST_FIELD(apicid));
-	lapic_write(LAPIC_ICR, LAPIC_DM_REMRD | (reg >> 4));
-
-/* Extra busy check compared to lapic.h */
-	timeout = 0;
-	do {
-		status = lapic_read(LAPIC_ICR) & LAPIC_ICR_BUSY;
-	} while (status == LAPIC_ICR_BUSY && timeout++ < 1000);
-
-	timeout = 0;
-	do {
-		status = lapic_read(LAPIC_ICR) & LAPIC_ICR_RR_MASK;
-	} while (status == LAPIC_ICR_RR_INPROG && timeout++ < 1000);
-
-	result = -1;
-
-	if (status == LAPIC_ICR_RR_VALID) {
-		*pvalue = lapic_read(LAPIC_RRR);
-		result = 0;
-	}
-	return result;
-}
-
-#if CONFIG_SET_FIDVID
-static void init_fidvid_ap(u32 apicid, u32 nodeid, u32 coreid);
-#endif
-
-static inline __attribute__ ((always_inline))
-void print_apicid_nodeid_coreid(u32 apicid, struct node_core_id id,
-				const char *str)
-{
-	printk(BIOS_DEBUG,
-	       "%s --- { APICID = %02x NODEID = %02x COREID = %02x} ---\n", str,
-	       apicid, id.nodeid, id.coreid);
-}
-
-static u32 wait_cpu_state(u32 apicid, u32 state)
-{
-	u32 readback = 0;
-	u32 timeout = 1;
-	int loop = 4000000;
-	while (--loop > 0) {
-		if (lapic_remote_read(apicid, LAPIC_MSG_REG, &readback) != 0)
-			continue;
-		if ((readback & 0x3f) == state || (readback & 0x3f) == F10_APSTATE_RESET) {
-			timeout = 0;
-			break;	//target cpu is in stage started
-		}
-	}
-	if (timeout) {
-		if (readback) {
-			timeout = readback;
-		}
-	}
-
-	return timeout;
-}
-
-static void wait_ap_started(u32 ap_apicid, void *gp)
-{
-	u32 timeout;
-	timeout = wait_cpu_state(ap_apicid, F10_APSTATE_STARTED);
-	printk(BIOS_DEBUG, "* AP %02x", ap_apicid);
-	if (timeout) {
-		printk(BIOS_DEBUG, " timed out:%08x\n", timeout);
-	} else {
-		printk(BIOS_DEBUG, "started\n");
-	}
-}
-
-void wait_all_other_cores_started(u32 bsp_apicid)
-{
-	// all aps other than core0
-	printk(BIOS_DEBUG, "started ap apicid: ");
-	for_each_ap(bsp_apicid, 2, wait_ap_started, (void *)0);
-	printk(BIOS_DEBUG, "\n");
-}
-
-void allow_all_aps_stop(u32 bsp_apicid)
-{
-	/* Called by the BSP to indicate AP can stop */
-
-	/* FIXME Do APs use this? */
-
-	// allow aps to stop use 6 bits for state
-	lapic_write(LAPIC_MSG_REG, (bsp_apicid << 24) | F10_APSTATE_STOPPED);
-}
-
-static void enable_apic_ext_id(u32 node)
-{
-	u32 val;
-
-	val = pci_read_config32(NODE_HT(node), 0x68);
-	val |= (HTTC_APIC_EXT_SPUR | HTTC_APIC_EXT_ID | HTTC_APIC_EXT_BRD_CST);
-	pci_write_config32(NODE_HT(node), 0x68, val);
-}
-
-static void STOP_CAR_AND_CPU(void)
-{
-	msr_t msr;
-
-	/* Disable L2 IC to L3 connection (Only for CAR) */
-	msr = rdmsr(BU_CFG2);
-	msr.lo &= ~(1 << ClLinesToNbDis);
-	wrmsr(BU_CFG2, msr);
-
-	disable_cache_as_ram();	// inline
-	/* stop all cores except node0/core0 the bsp .... */
-	stop_this_cpu();
-}
-
-static u32 init_cpus(u32 cpu_init_detectedx, struct sys_info *sysinfo)
-{
-	u32 bsp_apicid = 0;
-	u32 apicid;
-	struct node_core_id id;
-
-	/* Please refer to the calculations and explaination in cache_as_ram.inc before modifying these values */
-	uint32_t max_ap_stack_region_size = CONFIG_MAX_CPUS * CONFIG_DCACHE_AP_STACK_SIZE;
-	uint32_t max_bsp_stack_region_size = CONFIG_DCACHE_BSP_STACK_SIZE + CONFIG_DCACHE_BSP_STACK_SLUSH;
-	uint32_t bsp_stack_region_upper_boundary = CONFIG_DCACHE_RAM_BASE + CONFIG_DCACHE_RAM_SIZE;
-	uint32_t bsp_stack_region_lower_boundary = bsp_stack_region_upper_boundary - max_bsp_stack_region_size;
-	void * lower_stack_region_boundary = (void*)(bsp_stack_region_lower_boundary - max_ap_stack_region_size);
-	if (((void*)(sysinfo + 1)) > lower_stack_region_boundary)
-		printk(BIOS_WARNING,
-			"sysinfo extends into stack region (sysinfo range: [%p,%p] lower stack region boundary: %p)\n",
-			sysinfo, sysinfo + 1, lower_stack_region_boundary);
-
-	/*
-	 * already set early mtrr in cache_as_ram.inc
-	 */
-
-	/* that is from initial apicid, we need nodeid and coreid
-	   later */
-	id = get_node_core_id_x();
-
-	/* NB_CFG MSR is shared between cores, so we need make sure
-	   core0 is done at first --- use wait_all_core0_started  */
-	if (id.coreid == 0) {
-		set_apicid_cpuid_lo();	/* only set it on core0 */
-		set_EnableCf8ExtCfg();	/* only set it on core0 */
-#if CONFIG_ENABLE_APIC_EXT_ID
-		enable_apic_ext_id(id.nodeid);
-#endif
-	}
-
-	enable_lapic();
-
-#if CONFIG_ENABLE_APIC_EXT_ID && (CONFIG_APIC_ID_OFFSET > 0)
-	u32 initial_apicid = get_initial_apicid();
-
-#if !CONFIG_LIFT_BSP_APIC_ID
-	if (initial_apicid != 0)	// other than bsp
-#endif
-	{
-		/* use initial apic id to lift it */
-		u32 dword = lapic_read(LAPIC_ID);
-		dword &= ~(0xff << 24);
-		dword |=
-		    (((initial_apicid + CONFIG_APIC_ID_OFFSET) & 0xff) << 24);
-
-		lapic_write(LAPIC_ID, dword);
-	}
-#if CONFIG_LIFT_BSP_APIC_ID
-	bsp_apicid += CONFIG_APIC_ID_OFFSET;
-#endif
-
-#endif
-
-	/* get the apicid, it may be lifted already */
-	apicid = lapicid();
-
-	// show our apicid, nodeid, and coreid
-	if (id.coreid == 0) {
-		if (id.nodeid != 0)	//all core0 except bsp
-			print_apicid_nodeid_coreid(apicid, id, " core0: ");
-	} else {		//all other cores
-		print_apicid_nodeid_coreid(apicid, id, " corex: ");
-	}
-
-	if (cpu_init_detectedx) {
-		print_apicid_nodeid_coreid(apicid, id,
-					   "\n\n\nINIT detected from ");
-		printk(BIOS_DEBUG, "\nIssuing SOFT_RESET...\n");
-		soft_reset();
-	}
-
-	if (id.coreid == 0) {
-		if (!(warm_reset_detect(id.nodeid)))	//FIXME: INIT is checked above but check for more resets?
-			distinguish_cpu_resets(id.nodeid);	// Also indicates we are started
-	}
-	// Mark the core as started.
-	lapic_write(LAPIC_MSG_REG, (apicid << 24) | F10_APSTATE_STARTED);
-
-	if (apicid != bsp_apicid) {
-		/* Setup each AP's cores MSRs.
-		 * This happens after HTinit.
-		 * The BSP runs this code in it's own path.
-		 */
-		update_microcode(cpuid_eax(1));
-
-		cpuSetAMDMSR();
-
-#if CONFIG_SET_FIDVID
-#if CONFIG_LOGICAL_CPUS && CONFIG_SET_FIDVID_CORE0_ONLY
-		// Run on all AP for proper FID/VID setup.
-		if (id.coreid == 0)	// only need set fid for core0
-#endif
-		{
-			// check warm(bios) reset to call stage2 otherwise do stage1
-			if (warm_reset_detect(id.nodeid)) {
-				printk(BIOS_DEBUG,
-				       "init_fidvid_stage2 apicid: %02x\n",
-				       apicid);
-				init_fidvid_stage2(apicid, id.nodeid);
-			} else {
-				printk(BIOS_DEBUG,
-				       "init_fidvid_ap(stage1) apicid: %02x\n",
-				       apicid);
-				init_fidvid_ap(apicid, id.nodeid, id.coreid);
-			}
-		}
-#endif
-
-		/* AP is ready, configure MTRRs and go to sleep */
-		set_var_mtrr(0, 0x00000000, CONFIG_RAMTOP, MTRR_TYPE_WRBACK);
-
-		STOP_CAR_AND_CPU();
-
-		printk(BIOS_DEBUG,
-		       "\nAP %02x should be halted but you are reading this....\n",
-		       apicid);
-	}
-
-	return bsp_apicid;
-}
-
-static u32 is_core0_started(u32 nodeid)
-{
-	u32 htic;
-	device_t device;
-	device = NODE_PCI(nodeid, 0);
-	htic = pci_read_config32(device, HT_INIT_CONTROL);
-	htic &= HTIC_ColdR_Detect;
-	return htic;
-}
-
-void wait_all_core0_started(void)
-{
-	/* When core0 is started, it will distingush_cpu_resets
-	 * So wait for that to finish */
-	u32 i;
-	u32 nodes = get_nodes();
-
-	printk(BIOS_DEBUG, "core0 started: ");
-	for (i = 1; i < nodes; i++) {	// skip bsp, because it is running on bsp
-		while (!is_core0_started(i)) {
-		}
-		printk(BIOS_DEBUG, " %02x", i);
-	}
-	printk(BIOS_DEBUG, "\n");
-}
-
-#if CONFIG_MAX_PHYSICAL_CPUS > 1
-/**
- * void start_node(u32 node)
- *
- *  start the core0 in node, so it can generate HT packet to feature code.
- *
- * This function starts the AP nodes core0s. wait_all_core0_started() in
- * romstage.c waits for all the AP to be finished before continuing
- * system init.
- */
-static void start_node(u8 node)
-{
-	u32 val;
-
-	/* Enable routing table */
-	printk(BIOS_DEBUG, "Start node %02x", node);
-
-#if CONFIG_NORTHBRIDGE_AMD_AMDFAM10
-	/* For FAM10 support, we need to set Dram base/limit for the new node */
-	pci_write_config32(NODE_MP(node), 0x44, 0);
-	pci_write_config32(NODE_MP(node), 0x40, 3);
-#endif
-
-	/* Allow APs to make requests (ROM fetch) */
-	val = pci_read_config32(NODE_HT(node), 0x6c);
-	val &= ~(1 << 1);
-	pci_write_config32(NODE_HT(node), 0x6c, val);
-
-	printk(BIOS_DEBUG, " done.\n");
-}
-
-/**
- * static void setup_remote_node(u32 node)
- *
- * Copy the BSP Address Map to each AP.
- */
-static void setup_remote_node(u8 node)
-{
-	/* There registers can be used with F1x114_x Address Map at the
-	   same time, So must set them even 32 node */
-	static const u16 pci_reg[] = {
-		/* DRAM Base/Limits Registers */
-		0x44, 0x4c, 0x54, 0x5c, 0x64, 0x6c, 0x74, 0x7c,
-		0x40, 0x48, 0x50, 0x58, 0x60, 0x68, 0x70, 0x78,
-		0x144, 0x14c, 0x154, 0x15c, 0x164, 0x16c, 0x174, 0x17c,
-		0x140, 0x148, 0x150, 0x158, 0x160, 0x168, 0x170, 0x178,
-		/* MMIO Base/Limits Registers */
-		0x84, 0x8c, 0x94, 0x9c, 0xa4, 0xac, 0xb4, 0xbc,
-		0x80, 0x88, 0x90, 0x98, 0xa0, 0xa8, 0xb0, 0xb8,
-		/* IO Base/Limits Registers */
-		0xc4, 0xcc, 0xd4, 0xdc,
-		0xc0, 0xc8, 0xd0, 0xd8,
-		/* Configuration Map Registers */
-		0xe0, 0xe4, 0xe8, 0xec,
-	};
-	u16 i;
-
-	printk(BIOS_DEBUG, "setup_remote_node: %02x", node);
-
-	/* copy the default resource map from node 0 */
-	for (i = 0; i < ARRAY_SIZE(pci_reg); i++) {
-		u32 value;
-		u16 reg;
-		reg = pci_reg[i];
-		value = pci_read_config32(NODE_MP(0), reg);
-		pci_write_config32(NODE_MP(node), reg, value);
-
-	}
-	printk(BIOS_DEBUG, " done\n");
-}
-#endif				/* CONFIG_MAX_PHYSICAL_CPUS > 1 */
-
-static void AMD_Errata281(u8 node, u32 revision, u32 platform)
-{
-	/* Workaround for Transaction Scheduling Conflict in
-	 * Northbridge Cross Bar.  Implement XCS Token adjustment
-	 * for ganged links.  Also, perform fix up for the mixed
-	 * revision case.
-	 */
-
-	u32 reg, val;
-	u8 i;
-	u8 mixed = 0;
-	u8 nodes = get_nodes();
-
-	if (platform & AMD_PTYPE_SVR) {
-		/* For each node we need to check for a "broken" node */
-		if (!(revision & (AMD_DR_B0 | AMD_DR_B1))) {
-			for (i = 0; i < nodes; i++) {
-				if (mctGetLogicalCPUID(i) &
-				    (AMD_DR_B0 | AMD_DR_B1)) {
-					mixed = 1;
-					break;
-				}
-			}
-		}
-
-		if ((revision & (AMD_DR_B0 | AMD_DR_B1)) || mixed) {
-
-			/* F0X68[22:21] DsNpReqLmt0 = 01b */
-			val = pci_read_config32(NODE_PCI(node, 0), 0x68);
-			val &= ~0x00600000;
-			val |= 0x00200000;
-			pci_write_config32(NODE_PCI(node, 0), 0x68, val);
-
-			/* F3X6C */
-			val = pci_read_config32(NODE_PCI(node, 3), 0x6C);
-			val &= ~0x700780F7;
-			val |= 0x00010094;
-			pci_write_config32(NODE_PCI(node, 3), 0x6C, val);
-
-			/* F3X7C */
-			val = pci_read_config32(NODE_PCI(node, 3), 0x7C);
-			val &= ~0x707FFF1F;
-			val |= 0x00144514;
-			pci_write_config32(NODE_PCI(node, 3), 0x7C, val);
-
-			/* F3X144[3:0] RspTok = 0001b */
-			val = pci_read_config32(NODE_PCI(node, 3), 0x144);
-			val &= ~0x0000000F;
-			val |= 0x00000001;
-			pci_write_config32(NODE_PCI(node, 3), 0x144, val);
-
-			for (i = 0; i < 3; i++) {
-				reg = 0x148 + (i * 4);
-				val = pci_read_config32(NODE_PCI(node, 3), reg);
-				val &= ~0x000000FF;
-				val |= 0x000000DB;
-				pci_write_config32(NODE_PCI(node, 3), reg, val);
-			}
-		}
-	}
-}
-
-static void AMD_Errata298(void)
-{
-	/* Workaround for L2 Eviction May Occur during operation to
-	 * set Accessed or dirty bit.
-	 */
-
-	msr_t msr;
-	u8 i;
-	u8 affectedRev = 0;
-	u8 nodes = get_nodes();
-
-	/* For each core we need to check for a "broken" node */
-	for (i = 0; i < nodes; i++) {
-		if (mctGetLogicalCPUID(i) & (AMD_DR_B0 | AMD_DR_B1 | AMD_DR_B2)) {
-			affectedRev = 1;
-			break;
-		}
-	}
-
-	if (affectedRev) {
-		msr = rdmsr(HWCR);
-		msr.lo |= 0x08;	/* Set TlbCacheDis bit[3] */
-		wrmsr(HWCR, msr);
-
-		msr = rdmsr(BU_CFG);
-		msr.lo |= 0x02;	/* Set TlbForceMemTypeUc bit[1] */
-		wrmsr(BU_CFG, msr);
-
-		msr = rdmsr(OSVW_ID_Length);
-		msr.lo |= 0x01;	/* OS Visible Workaround - MSR */
-		wrmsr(OSVW_ID_Length, msr);
-
-		msr = rdmsr(OSVW_Status);
-		msr.lo |= 0x01;	/* OS Visible Workaround - MSR */
-		wrmsr(OSVW_Status, msr);
-	}
-
-	if (!affectedRev && (mctGetLogicalCPUID(0xFF) & AMD_DR_B3)) {
-		msr = rdmsr(OSVW_ID_Length);
-		msr.lo |= 0x01;	/* OS Visible Workaround - MSR */
-		wrmsr(OSVW_ID_Length, msr);
-
-	}
-}
-
-static u32 get_platform_type(void)
-{
-	u32 ret = 0;
-
-	switch (SYSTEM_TYPE) {
-	case 1:
-		ret |= AMD_PTYPE_DSK;
-		break;
-	case 2:
-		ret |= AMD_PTYPE_MOB;
-		break;
-	case 0:
-		ret |= AMD_PTYPE_SVR;
-		break;
-	default:
-		break;
-	}
-
-	/* FIXME: add UMA support. */
-
-	/* All Fam10 are multi core */
-	ret |= AMD_PTYPE_MC;
-
-	return ret;
-}
-
-static void AMD_SetupPSIVID_d(u32 platform_type, u8 node)
-{
-	u32 dword;
-	int i;
-	msr_t msr;
-
-	if (platform_type & (AMD_PTYPE_MOB | AMD_PTYPE_DSK)) {
-
-		/* The following code sets the PSIVID to the lowest support P state
-		 * assuming that the VID for the lowest power state is below
-		 * the VDD voltage regulator threshold. (This also assumes that there
-		 * is a Pstate lower than P0)
-		 */
-
-		for (i = 4; i >= 0; i--) {
-			msr = rdmsr(PS_REG_BASE + i);
-			/*  Pstate valid? */
-			if (msr.hi & PS_EN_MASK) {
-				dword = pci_read_config32(NODE_PCI(i, 3), 0xA0);
-				dword &= ~0x7F;
-				dword |= (msr.lo >> 9) & 0x7F;
-				pci_write_config32(NODE_PCI(i, 3), 0xA0, dword);
-				break;
-			}
-		}
-	}
-}
-
-/**
- * AMD_CpuFindCapability - Traverse PCI capability list to find host HT links.
- *  HT Phy operations are not valid on links that aren't present, so this
- *  prevents invalid accesses.
- *
- * Returns the offset of the link register.
- */
-static BOOL AMD_CpuFindCapability(u8 node, u8 cap_count, u8 * offset)
-{
-	u32 reg;
-	u32 val;
-
-	/* get start of CPU HT Host Capabilities */
-	val = pci_read_config32(NODE_PCI(node, 0), 0x34);
-	val &= 0xFF;		//reg offset of first link
-
-	cap_count++;
-
-	/* Traverse through the capabilities. */
-	do {
-		reg = pci_read_config32(NODE_PCI(node, 0), val);
-		/* Is the capability block a HyperTransport capability block? */
-		if ((reg & 0xFF) == 0x08) {
-			/* Is the HT capability block an HT Host Capability? */
-			if ((reg & 0xE0000000) == (1 << 29))
-				cap_count--;
-		}
-
-		if (cap_count)
-			val = (reg >> 8) & 0xFF;	//update reg offset
-	} while (cap_count && val);
-
-	*offset = (u8) val;
-
-	/* If requested capability found val != 0 */
-	if (!cap_count)
-		return TRUE;
-	else
-		return FALSE;
-}
-
-/**
- * AMD_checkLinkType - Compare desired link characteristics using a logical
- *     link type mask.
- *
- * Returns the link characteristic mask.
- */
-static u32 AMD_checkLinkType(u8 node, u8 link, u8 regoff)
-{
-	u32 val;
-	u32 linktype = 0;
-
-	/* Check connect, init and coherency */
-	val = pci_read_config32(NODE_PCI(node, 0), regoff + 0x18);
-	val &= 0x1F;
-
-	if (val == 3)
-		linktype |= HTPHY_LINKTYPE_COHERENT;
-
-	if (val == 7)
-		linktype |= HTPHY_LINKTYPE_NONCOHERENT;
-
-	if (linktype) {
-		/* Check gen3 */
-		val = pci_read_config32(NODE_PCI(node, 0), regoff + 0x08);
-
-		if (((val >> 8) & 0x0F) > 6)
-			linktype |= HTPHY_LINKTYPE_HT3;
-		else
-			linktype |= HTPHY_LINKTYPE_HT1;
-
-		/* Check ganged */
-		val = pci_read_config32(NODE_PCI(node, 0), (link << 2) + 0x170);
-
-		if (val & 1)
-			linktype |= HTPHY_LINKTYPE_GANGED;
-		else
-			linktype |= HTPHY_LINKTYPE_UNGANGED;
-	}
-	return linktype;
-}
-
-/**
- * AMD_SetHtPhyRegister - Use the HT link's HT Phy portal registers to update
- *   a phy setting for that link.
- */
-static void AMD_SetHtPhyRegister(u8 node, u8 link, u8 entry)
-{
-	u32 phyReg;
-	u32 phyBase;
-	u32 val;
-
-	/* Determine this link's portal */
-	if (link > 3)
-		link -= 4;
-
-	phyBase = ((u32) link << 3) | 0x180;
-
-	/* Get the portal control register's initial value
-	 * and update it to access the desired phy register
-	 */
-	phyReg = pci_read_config32(NODE_PCI(node, 4), phyBase);
-
-	if (fam10_htphy_default[entry].htreg > 0x1FF) {
-		phyReg &= ~HTPHY_DIRECT_OFFSET_MASK;
-		phyReg |= HTPHY_DIRECT_MAP;
-	} else {
-		phyReg &= ~HTPHY_OFFSET_MASK;
-	}
-
-	/* Now get the current phy register data
-	 * LinkPhyDone = 0, LinkPhyWrite = 0 is a read
-	 */
-	phyReg |= fam10_htphy_default[entry].htreg;
-	pci_write_config32(NODE_PCI(node, 4), phyBase, phyReg);
-
-	do {
-		val = pci_read_config32(NODE_PCI(node, 4), phyBase);
-	} while (!(val & HTPHY_IS_COMPLETE_MASK));
-
-	/* Now we have the phy register data, apply the change */
-	val = pci_read_config32(NODE_PCI(node, 4), phyBase + 4);
-	val &= ~fam10_htphy_default[entry].mask;
-	val |= fam10_htphy_default[entry].data;
-	pci_write_config32(NODE_PCI(node, 4), phyBase + 4, val);
-
-	/* write it through the portal to the phy
-	 * LinkPhyDone = 0, LinkPhyWrite = 1 is a write
-	 */
-	phyReg |= HTPHY_WRITE_CMD;
-	pci_write_config32(NODE_PCI(node, 4), phyBase, phyReg);
-
-	do {
-		val = pci_read_config32(NODE_PCI(node, 4), phyBase);
-	} while (!(val & HTPHY_IS_COMPLETE_MASK));
-}
-
-void cpuSetAMDMSR(void)
-{
-	/* This routine loads the CPU with default settings in fam10_msr_default
-	 * table . It must be run after Cache-As-RAM has been enabled, and
-	 * Hypertransport initialization has taken place.  Also note
-	 * that it is run on the current processor only, and only for the current
-	 * processor core.
-	 */
-	msr_t msr;
-	u8 i;
-	u32 revision, platform;
-
-	printk(BIOS_DEBUG, "cpuSetAMDMSR ");
-
-	revision = mctGetLogicalCPUID(0xFF);
-	platform = get_platform_type();
-
-	for (i = 0; i < ARRAY_SIZE(fam10_msr_default); i++) {
-		if ((fam10_msr_default[i].revision & revision) &&
-		    (fam10_msr_default[i].platform & platform)) {
-			msr = rdmsr(fam10_msr_default[i].msr);
-			msr.hi &= ~fam10_msr_default[i].mask_hi;
-			msr.hi |= fam10_msr_default[i].data_hi;
-			msr.lo &= ~fam10_msr_default[i].mask_lo;
-			msr.lo |= fam10_msr_default[i].data_lo;
-			wrmsr(fam10_msr_default[i].msr, msr);
-		}
-	}
-	AMD_Errata298();
-
-	printk(BIOS_DEBUG, " done\n");
-}
-
-static void cpuSetAMDPCI(u8 node)
-{
-	/* This routine loads the CPU with default settings in fam10_pci_default
-	 * table . It must be run after Cache-As-RAM has been enabled, and
-	 * Hypertransport initialization has taken place.  Also note
-	 * that it is run for the first core on each node
-	 */
-	u8 i, j;
-	u32 revision, platform;
-	u32 val;
-	u8 offset;
-
-	printk(BIOS_DEBUG, "cpuSetAMDPCI %02d", node);
-
-	revision = mctGetLogicalCPUID(node);
-	platform = get_platform_type();
-
-	AMD_SetupPSIVID_d(platform, node);	/* Set PSIVID offset which is not table driven */
-
-	for (i = 0; i < ARRAY_SIZE(fam10_pci_default); i++) {
-		if ((fam10_pci_default[i].revision & revision) &&
-		    (fam10_pci_default[i].platform & platform)) {
-			val = pci_read_config32(NODE_PCI(node,
-							 fam10_pci_default[i].
-							 function),
-						fam10_pci_default[i].offset);
-			val &= ~fam10_pci_default[i].mask;
-			val |= fam10_pci_default[i].data;
-			pci_write_config32(NODE_PCI(node,
-						    fam10_pci_default[i].
-						    function),
-					   fam10_pci_default[i].offset, val);
-		}
-	}
-
-	for (i = 0; i < ARRAY_SIZE(fam10_htphy_default); i++) {
-		if ((fam10_htphy_default[i].revision & revision) &&
-		    (fam10_htphy_default[i].platform & platform)) {
-			/* HT Phy settings either apply to both sublinks or have
-			 * separate registers for sublink zero and one, so there
-			 * will be two table entries. So, here we only loop
-			 * through the sublink zeros in function zero.
-			 */
-			for (j = 0; j < 4; j++) {
-				if (AMD_CpuFindCapability(node, j, &offset)) {
-					if (AMD_checkLinkType(node, j, offset)
-					    & fam10_htphy_default[i].linktype) {
-						AMD_SetHtPhyRegister(node, j,
-								     i);
-					}
-				} else {
-					/* No more capabilities,
-					 * link not present
-					 */
-					break;
-				}
-			}
-		}
-	}
-
-	/* FIXME: add UMA support and programXbarToSriReg(); */
-
-	AMD_Errata281(node, revision, platform);
-
-	/* FIXME: if the dct phy doesn't init correct it needs to reset.
-	   if (revision & (AMD_DR_B2 | AMD_DR_B3))
-	   dctPhyDiag(); */
-
-	printk(BIOS_DEBUG, " done\n");
-}
-
-#ifdef UNUSED_CODE
-static void cpuInitializeMCA(void)
-{
-	/* Clears Machine Check Architecture (MCA) registers, which power on
-	 * containing unknown data, on currently running processor.
-	 * This routine should only be executed on initial power on (cold boot),
-	 * not across a warm reset because valid data is present at that time.
-	 */
-
-	msr_t msr;
-	u32 reg;
-	u8 i;
-
-	if (cpuid_edx(1) & 0x4080) {	/* MCE and MCA (edx[7] and edx[14]) */
-		msr = rdmsr(MCG_CAP);
-		if (msr.lo & MCG_CTL_P) {	/* MCG_CTL_P bit is set? */
-			msr.lo &= 0xFF;
-			msr.lo--;
-			msr.lo <<= 2;	/* multiply the count by 4 */
-			reg = MC0_STA + msr.lo;
-			msr.lo = msr.hi = 0;
-			for (i = 0; i < 4; i++) {
-				wrmsr(reg, msr);
-				reg -= 4;	/* Touch status regs for each bank */
-			}
-		}
-	}
-}
-#endif
-
-/**
- * finalize_node_setup()
- *
- * Do any additional post HT init
- *
- */
-static void finalize_node_setup(struct sys_info *sysinfo)
-{
-	u8 i;
-	u8 nodes = get_nodes();
-	u32 reg;
-
-	/* read Node0 F0_0x64 bit [8:10] to find out SbLink # */
-	reg = pci_read_config32(NODE_HT(0), 0x64);
-	sysinfo->sblk = (reg >> 8) & 7;
-	sysinfo->sbbusn = 0;
-	sysinfo->nodes = nodes;
-	sysinfo->sbdn = get_sbdn(sysinfo->sbbusn);
-
-	for (i = 0; i < nodes; i++) {
-		cpuSetAMDPCI(i);
-	}
-
-#if CONFIG_SET_FIDVID
-	// Prep each node for FID/VID setup.
-	prep_fid_change();
-#endif
-
-#if CONFIG_MAX_PHYSICAL_CPUS > 1
-	/* Skip the BSP, start at node 1 */
-	for (i = 1; i < nodes; i++) {
-		setup_remote_node(i);
-		start_node(i);
-	}
-#endif
-}
-
-#include "fidvid.c"
diff --git a/src/cpu/amd/model_10xxx/model_10xxx_init.c b/src/cpu/amd/model_10xxx/model_10xxx_init.c
deleted file mode 100644
index b942c1a..0000000
--- a/src/cpu/amd/model_10xxx/model_10xxx_init.c
+++ /dev/null
@@ -1,165 +0,0 @@
-/*
- * This file is part of the coreboot project.
- *
- * Copyright (C) 2007 Advanced Micro Devices, Inc.
- * Copyright (C) 2015 Timothy Pearson <tpearson@raptorengineeringinc.com>, Raptor Engineering
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc.
- */
-
-#include <console/console.h>
-#include <cpu/x86/msr.h>
-#include <cpu/amd/mtrr.h>
-#include <device/device.h>
-#include <device/pci.h>
-#include <string.h>
-#include <cpu/x86/msr.h>
-#include <cpu/x86/smm.h>
-#include <cpu/x86/pae.h>
-#include <pc80/mc146818rtc.h>
-#include <cpu/x86/lapic.h>
-#include "northbridge/amd/amdfam10/amdfam10.h"
-#include <cpu/amd/model_10xxx_rev.h>
-#include <cpu/cpu.h>
-#include <cpu/x86/cache.h>
-#include <cpu/x86/mtrr.h>
-#include <cpu/amd/multicore.h>
-#include <cpu/amd/model_10xxx_msr.h>
-
-#define MCI_STATUS 0x401
-
-static void model_10xxx_init(device_t dev)
-{
-	u8 i;
-	msr_t msr;
-	struct node_core_id id;
-#if CONFIG_LOGICAL_CPUS
-	u32 siblings;
-#endif
-
-	id = get_node_core_id(read_nb_cfg_54());	/* nb_cfg_54 can not be set */
-	printk(BIOS_DEBUG, "nodeid = %02d, coreid = %02d\n", id.nodeid, id.coreid);
-
-	/* Turn on caching if we haven't already */
-	x86_enable_cache();
-	amd_setup_mtrrs();
-	x86_mtrr_check();
-
-	disable_cache();
-
-	/* zero the machine check error status registers */
-	msr.lo = 0;
-	msr.hi = 0;
-	for (i = 0; i < 5; i++) {
-		wrmsr(MCI_STATUS + (i * 4), msr);
-	}
-
-	enable_cache();
-
-	/* Enable the local cpu apics */
-	setup_lapic();
-
-	/* Set the processor name string */
-	init_processor_name();
-
-#if CONFIG_LOGICAL_CPUS
-	siblings = cpuid_ecx(0x80000008) & 0xff;
-
-	if (siblings > 0) {
-		msr = rdmsr_amd(CPU_ID_FEATURES_MSR);
-		msr.lo |= 1 << 28;
-		wrmsr_amd(CPU_ID_FEATURES_MSR, msr);
-
-		msr = rdmsr_amd(CPU_ID_EXT_FEATURES_MSR);
-		msr.hi |= 1 << (33 - 32);
-		wrmsr_amd(CPU_ID_EXT_FEATURES_MSR, msr);
-	}
-	printk(BIOS_DEBUG, "siblings = %02d, ", siblings);
-#endif
-
-	/* DisableCf8ExtCfg */
-	msr = rdmsr(NB_CFG_MSR);
-	msr.hi &= ~(1 << (46 - 32));
-	wrmsr(NB_CFG_MSR, msr);
-
-	msr = rdmsr(BU_CFG2_MSR);
-	/* Clear ClLinesToNbDis */
-	msr.lo &= ~(1 << 15);
-	/* Clear bit 35 as per Erratum 343 */
-	msr.hi &= ~(1 << (35-32));
-	wrmsr(BU_CFG2_MSR, msr);
-
-	if (IS_ENABLED(CONFIG_HAVE_SMI_HANDLER)) {
-		printk(BIOS_DEBUG, "Initializing SMM ASeg memory\n");
-
-		/* Set SMM base address for this CPU */
-		msr = rdmsr(SMM_BASE_MSR);
-		msr.lo = SMM_BASE - (lapicid() * 0x400);
-		wrmsr(SMM_BASE_MSR, msr);
-
-		/* Enable the SMM memory window */
-		msr = rdmsr(SMM_MASK_MSR);
-		msr.lo |= (1 << 0); /* Enable ASEG SMRAM Range */
-		wrmsr(SMM_MASK_MSR, msr);
-	} else {
-		printk(BIOS_DEBUG, "Disabling SMM ASeg memory\n");
-
-		/* Set SMM base address for this CPU */
-		msr = rdmsr(SMM_BASE_MSR);
-		msr.lo = SMM_BASE - (lapicid() * 0x400);
-		wrmsr(SMM_BASE_MSR, msr);
-
-		/* Disable the SMM memory window */
-		msr.hi = 0x0;
-		msr.lo = 0x0;
-		wrmsr(SMM_MASK_MSR, msr);
-	}
-
-	/* Set SMMLOCK to avoid exploits messing with SMM */
-	msr = rdmsr(HWCR_MSR);
-	msr.lo |= (1 << 0);
-	wrmsr(HWCR_MSR, msr);
-
-}
-
-static struct device_operations cpu_dev_ops = {
-	.init = model_10xxx_init,
-};
-
-static struct cpu_device_id cpu_table[] = {
-//AMD_GH_SUPPORT
-	{ X86_VENDOR_AMD, 0x100f00 },		/* SH-F0 L1 */
-	{ X86_VENDOR_AMD, 0x100f10 },		/* M2 */
-	{ X86_VENDOR_AMD, 0x100f20 },		/* S1g1 */
-	{ X86_VENDOR_AMD, 0x100f21 },
-	{ X86_VENDOR_AMD, 0x100f2A },
-	{ X86_VENDOR_AMD, 0x100f22 },
-	{ X86_VENDOR_AMD, 0x100f23 },
-	{ X86_VENDOR_AMD, 0x100f40 },		/* RB-C0 */
-	{ X86_VENDOR_AMD, 0x100F42 },           /* RB-C2 */
-	{ X86_VENDOR_AMD, 0x100F43 },           /* RB-C3 */
-	{ X86_VENDOR_AMD, 0x100F52 },           /* BL-C2 */
-	{ X86_VENDOR_AMD, 0x100F62 },           /* DA-C2 */
-	{ X86_VENDOR_AMD, 0x100F63 },           /* DA-C3 */
-	{ X86_VENDOR_AMD, 0x100F80 },           /* HY-D0 */
-	{ X86_VENDOR_AMD, 0x100F81 },           /* HY-D1 */
-	{ X86_VENDOR_AMD, 0x100F91 },           /* HY-D1 */
-	{ X86_VENDOR_AMD, 0x100FA0 },           /* PH-E0 */
-	{ 0, 0 },
-};
-
-static const struct cpu_driver model_10xxx __cpu_driver = {
-	.ops      = &cpu_dev_ops,
-	.id_table = cpu_table,
-};
diff --git a/src/cpu/amd/model_10xxx/monotonic_timer.c b/src/cpu/amd/model_10xxx/monotonic_timer.c
deleted file mode 100644
index 8c02fd1..0000000
--- a/src/cpu/amd/model_10xxx/monotonic_timer.c
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * This file is part of the coreboot project.
- *
- * Copyright (C) 2015 Timothy Pearson <tpearson@raptorengineeringinc.com>, Raptor Engineering
- * Copyright (C) 2013 Google, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc.
- */
-#include <stdint.h>
-#include <arch/cpu.h>
-#include <cpu/x86/msr.h>
-#include <timer.h>
-#include <device/pci.h>
-#include <device/pci_ids.h>
-
-#include <northbridge/amd/amdht/AsPsDefs.h>
-#include <cpu/amd/model_10xxx_msr.h>
-
-static struct monotonic_counter {
-	int initialized;
-	uint32_t core_frequency;
-	struct mono_time time;
-	uint64_t last_value;
-} mono_counter;
-
-static inline uint64_t read_counter_msr(void)
-{
-	msr_t counter_msr;
-
-	counter_msr = rdmsr(TSC_MSR);
-
-	return ((uint64_t)counter_msr.hi << 32) | (uint64_t)counter_msr.lo;
-}
-
-static void init_timer(void)
-{
-	uint8_t model;
-	uint32_t cpuid_fms;
-	uint8_t cpufid;
-	uint8_t cpudid;
-	uint8_t boost_capable = 0;
-
-	/* Get CPU model */
-	cpuid_fms = cpuid_eax(0x80000001);
-	model = ((cpuid_fms & 0xf0000) >> 16) | ((cpuid_fms & 0xf0) >> 4);
-
-	/* Get boost capability */
-	if ((model == 0x8) || (model == 0x9)) {	/* revision D */
-		boost_capable = (pci_read_config32(dev_find_slot(0, PCI_DEVFN(0x18, 4)), 0x15c) & 0x4) >> 2;
-	}
-
-	/* Set up TSC (BKDG v3.62 section 2.9.4)*/
-	msr_t msr = rdmsr(HWCR_MSR);
-	msr.lo |= 0x1000000;
-	wrmsr(HWCR_MSR, msr);
-
-	/* Get core Pstate 0 frequency in MHz */
-	msr = rdmsr(0xC0010064 + boost_capable);
-	cpufid = (msr.lo & 0x3f);
-	cpudid = (msr.lo & 0x1c0) >> 6;
-	mono_counter.core_frequency = (100 * (cpufid + 0x10)) / (0x01 << cpudid);
-
-	mono_counter.last_value = read_counter_msr();
-	mono_counter.initialized = 1;
-}
-
-void timer_monotonic_get(struct mono_time *mt)
-{
-	uint64_t current_tick;
-	uint32_t usecs_elapsed = 0;
-
-	if (!mono_counter.initialized)
-		init_timer();
-
-	current_tick = read_counter_msr();
-	if (mono_counter.core_frequency != 0)
-		usecs_elapsed = (current_tick - mono_counter.last_value) / mono_counter.core_frequency;
-
-	/* Update current time and tick values only if a full tick occurred. */
-	if (usecs_elapsed) {
-		mono_time_add_usecs(&mono_counter.time, usecs_elapsed);
-		mono_counter.last_value = current_tick;
-	}
-
-	/* Save result. */
-	*mt = mono_counter.time;
-}
diff --git a/src/cpu/amd/model_10xxx/powernow_acpi.c b/src/cpu/amd/model_10xxx/powernow_acpi.c
deleted file mode 100644
index 98ef08a..0000000
--- a/src/cpu/amd/model_10xxx/powernow_acpi.c
+++ /dev/null
@@ -1,311 +0,0 @@
-/*
- * This file is part of the coreboot project.
- *
- * Copyright (C) 2007-2008 Advanced Micro Devices, Inc.
- * Copyright (C) 2009 Rudolf Marek <r.marek@assembler.cz>
- * Copyright (C) 2015 Timothy Pearson <tpearson@raptorengineeringinc.com>, Raptor Engineering
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc.
- */
-
-#include <console/console.h>
-#include <stdint.h>
-#include <cpu/x86/msr.h>
-#include <arch/acpigen.h>
-#include <cpu/amd/powernow.h>
-#include <device/pci.h>
-#include <device/pci_ids.h>
-#include <cpu/x86/msr.h>
-#include <cpu/amd/mtrr.h>
-#include <cpu/amd/amdfam10_sysconf.h>
-#include <arch/cpu.h>
-#include <northbridge/amd/amdht/AsPsDefs.h>
-#include <northbridge/amd/amdmct/mct/mct.h>
-#include <northbridge/amd/amdmct/amddefs.h>
-
-static void write_pstates_for_core(u8 pstate_num, u16 *pstate_feq, u32 *pstate_power,
-				u32 *pstate_latency, u32 *pstate_control,
-				u32 *pstate_status, int coreID,
-				u32 pcontrol_blk, u8 plen, u8 onlyBSP,
-				uint8_t single_link)
-{
-	int i;
-	struct cpuid_result cpuid1;
-
-	if ((onlyBSP) && (coreID != 0)) {
-	    plen = 0;
-	    pcontrol_blk = 0;
-	}
-
-	acpigen_write_processor(coreID, pcontrol_blk, plen);
-	acpigen_write_empty_PCT();
-	acpigen_write_name("_PSS");
-
-	/* add later to total sum */
-	acpigen_write_package(pstate_num);
-
-	for (i = 0;i < pstate_num; i++)
-		acpigen_write_PSS_package(pstate_feq[i],
-					  pstate_power[i],
-					  pstate_latency[i],
-					  pstate_latency[i],
-					  pstate_control[i],
-					  pstate_status[i]);
-
-	/* update the package size */
-	acpigen_pop_len();
-
-	/* Write PPC object */
-	acpigen_write_PPC(pstate_num);
-
-	/* Write PSD indicating coordination type */
-	if ((single_link) && (mctGetLogicalCPUID(0) & AMD_DR_GT_Bx)) {
-		/* Revision C or greater single-link processor */
-		cpuid1 = cpuid(0x80000008);
-		acpigen_write_PSD_package(0, (cpuid1.ecx & 0xff) + 1, SW_ALL);
-	}
-	else {
-		/* Find the local APIC ID for the specified core ID */
-		struct device* cpu;
-		int cpu_index = 0;
-		for (cpu = all_devices; cpu; cpu = cpu->next) {
-			if ((cpu->path.type != DEVICE_PATH_APIC) ||
-				(cpu->bus->dev->path.type != DEVICE_PATH_CPU_CLUSTER))
-				continue;
-			if (!cpu->enabled)
-				continue;
-			if (cpu_index == coreID)
-				break;
-			cpu_index++;
-		}
-
-		if (cpu)
-			acpigen_write_PSD_package(cpu->path.apic.apic_id, 1, SW_ANY);
-	}
-
-	/* patch the whole Processor token length */
-	acpigen_pop_len();
-}
-
-/*
-* For details of this algorithm, please refer to the BDKG 3.62 page 69
-*
-* WARNING: The core count algorithm below assumes that all processors
-* are identical, with the same number of active cores.  While the BKDG
-* states the BIOS must enforce this coreboot does not currently do so.
-* As a result it is possible that this code may break if an illegal
-* processor combination is installed.  If it does break please fix the
-* code in the proper locations!
-*/
-void amd_generate_powernow(u32 pcontrol_blk, u8 plen, u8 onlyBSP)
-{
-	u8 processor_brand[49];
-	u32 *v;
-	struct cpuid_result cpuid1;
-
-	u16 Pstate_feq[10];
-	u32 Pstate_power[10];
-	u32 Pstate_latency[10];
-	u32 Pstate_control[10];
-	u32 Pstate_status[10];
-	u8 Pstate_num;
-	u8 cmp_cap;
-	u8 index;
-	msr_t msr;
-
-	/* Get the Processor Brand String using cpuid(0x8000000x) command x=2,3,4 */
-	cpuid1 = cpuid(0x80000002);
-	v = (u32 *) processor_brand;
-	v[0] = cpuid1.eax;
-	v[1] = cpuid1.ebx;
-	v[2] = cpuid1.ecx;
-	v[3] = cpuid1.edx;
-	cpuid1 = cpuid(0x80000003);
-	v[4] = cpuid1.eax;
-	v[5] = cpuid1.ebx;
-	v[6] = cpuid1.ecx;
-	v[7] = cpuid1.edx;
-	cpuid1 = cpuid(0x80000004);
-	v[8] = cpuid1.eax;
-	v[9] = cpuid1.ebx;
-	v[10] = cpuid1.ecx;
-	v[11] = cpuid1.edx;
-	processor_brand[48] = 0;
-	printk(BIOS_INFO, "processor_brand=%s\n", processor_brand);
-
-	uint32_t dtemp;
-	uint8_t node_index;
-	uint8_t node_count;
-	uint8_t cores_per_node;
-	uint8_t total_core_count;
-
-	/*
-	 * Based on the CPU socket type,cmp_cap and pwr_lmt , get the power limit.
-	 * socket_type : 0x10 SocketF; 0x11 AM2/ASB1 ; 0x12 S1G1
-	 * cmp_cap : 0x0 SingleCore ; 0x1 DualCore ; 0x2 TripleCore ; 0x3 QuadCore ; 0x4 QuintupleCore ; 0x5 HexCore
-	 */
-	printk(BIOS_INFO, "Pstates algorithm ...\n");
-	/* Get number of cores */
-	dtemp = pci_read_config32(dev_find_slot(0, PCI_DEVFN(0x18, 3)), 0xE8);
-	cmp_cap = (dtemp & 0x3000) >> 12;
-	if (mctGetLogicalCPUID(0) & AMD_FAM10_REV_D)	/* revision D */
-		cmp_cap |= (dtemp & 0x8000) >> 13;
-	/* Get number of nodes */
-	dtemp = pci_read_config32(dev_find_slot(0, PCI_DEVFN(0x18, 0)), 0x60);
-	node_count = ((dtemp & 0x70) >> 4) + 1;
-	cores_per_node = cmp_cap + 1;
-
-	/* Compute total number of cores installed in system */
-	total_core_count = cores_per_node * node_count;
-
-	Pstate_num = 0;
-
-	/* See if the CPUID(0x80000007) returned EDX[7]==1b */
-	cpuid1 = cpuid(0x80000007);
-	if ((cpuid1.edx & 0x80) != 0x80) {
-		printk(BIOS_INFO, "No valid set of P-states\n");
-		return;
-	}
-
-	uint8_t pviModeFlag;
-	uint8_t Pstate_max;
-	uint8_t cpufid;
-	uint8_t cpudid;
-	uint8_t cpuvid;
-	uint8_t cpuidd;
-	uint8_t cpuidv;
-	uint8_t power_step_up;
-	uint8_t power_step_down;
-	uint8_t pll_lock_time;
-	uint32_t expanded_cpuidv;
-	uint32_t core_frequency;
-	uint32_t core_power;
-	uint32_t core_latency;
-	uint32_t core_voltage;	/* multiplied by 10000 */
-	uint8_t single_link;
-
-	/* Determine if this is a PVI or SVI system */
-	dtemp = pci_read_config32(dev_find_slot(0, PCI_DEVFN(0x18, 3)), 0xA0);
-
-	if (dtemp & PVI_MODE)
-		pviModeFlag = 1;
-	else
-		pviModeFlag = 0;
-
-	/* Get PSmax's index */
-	msr = rdmsr(0xC0010061);
-	Pstate_max = (uint8_t) ((msr.lo >> PS_MAX_VAL_SHFT) & BIT_MASK_3);
-
-	/* Determine if all enabled Pstates have the same fidvid */
-	uint8_t i;
-	uint8_t cpufid_prev = (rdmsr(0xC0010064).lo & 0x3f);
-	uint8_t all_enabled_cores_have_same_cpufid = 1;
-	for (i = 1; i < Pstate_max; i++) {
-		cpufid = rdmsr(0xC0010064 + i).lo & 0x3f;
-		if (cpufid != cpufid_prev) {
-			all_enabled_cores_have_same_cpufid = 0;
-			break;
-		}
-	}
-
-	/* Populate tables with all Pstate information */
-	for (Pstate_num = 0; Pstate_num < Pstate_max; Pstate_num++) {
-		/* Get power state information */
-		msr = rdmsr(0xC0010064 + Pstate_num);
-		cpufid = (msr.lo & 0x3f);
-		cpudid = (msr.lo & 0x1c0) >> 6;
-		cpuvid = (msr.lo & 0xfe00) >> 9;
-		cpuidd = (msr.hi & 0xff);
-		cpuidv = (msr.hi & 0x300) >> 8;
-		core_frequency = (100 * (cpufid + 0x10)) / (0x01 << cpudid);
-		if (pviModeFlag) {
-			if (cpuvid >= 0x20) {
-				core_voltage = 7625 - (((cpuvid - 0x20) * 10000) / 80);
-			}
-			else {
-				core_voltage = 15500 - ((cpuvid * 10000) / 40);
-			}
-		}
-		else {
-			cpuvid = cpuvid & 0x7f;
-			if (cpuvid >= 0x7c)
-				core_voltage = 0;
-			else
-				core_voltage = 15500 - ((cpuvid * 10000) / 80);
-		}
-		switch (cpuidv) {
-			case 0x0:
-				expanded_cpuidv = 1;
-				break;
-			case 0x1:
-				expanded_cpuidv = 10;
-				break;
-			case 0x2:
-				expanded_cpuidv = 100;
-				break;
-			case 0x3:
-				expanded_cpuidv = 1000;
-				break;
-			default:
-				printk(BIOS_ERR, "%s:%s:%d: Invalid cpuidv, "
-					"not generating pstate tables.\n",
-					__FILE__, __func__, __LINE__);
-				return;
-		}
-		core_power = (core_voltage * cpuidd) / (expanded_cpuidv * 10);
-
-		/* Calculate transition latency */
-		dtemp = pci_read_config32(dev_find_slot(0, PCI_DEVFN(0x18, 3)), 0xD4);
-		power_step_up = (dtemp & 0xf000000) >> 24;
-		power_step_down = (dtemp & 0xf00000) >> 20;
-		dtemp = pci_read_config32(dev_find_slot(0, PCI_DEVFN(0x18, 3)), 0xA0);
-		pll_lock_time = (dtemp & 0x3800) >> 11;
-		if (all_enabled_cores_have_same_cpufid)
-			core_latency = ((12 * power_step_down) + power_step_up) / 1000;
-		else
-			core_latency = (12 * (power_step_down + power_step_up) / 1000)
-						 + pll_lock_time;
-
-		Pstate_feq[Pstate_num] = core_frequency;
-		Pstate_power[Pstate_num] = core_power;
-		Pstate_latency[Pstate_num] = core_latency;
-		Pstate_control[Pstate_num] = Pstate_num;
-		Pstate_status[Pstate_num] = Pstate_num;
-	}
-
-	/* Print Pstate frequency, power, and latency */
-	for (index = 0; index < Pstate_num; index++) {
-		printk(BIOS_INFO, "Pstate_freq[%d] = %dMHz\t", index,
-			    Pstate_feq[index]);
-		printk(BIOS_INFO, "Pstate_power[%d] = %dmw\n", index,
-			    Pstate_power[index]);
-		printk(BIOS_INFO, "Pstate_latency[%d] = %dus\n", index,
-			    Pstate_latency[index]);
-	}
-
-	char pscope[] = "\\_PR";
-
-	acpigen_write_scope(pscope);
-	for (index = 0; index < total_core_count; index++) {
-		/* Determine if this is a single-link processor */
-		node_index = 0x18 + (index / cores_per_node);
-		dtemp = pci_read_config32(dev_find_slot(0, PCI_DEVFN(node_index, 0)), 0x80);
-		single_link = !!(((dtemp & 0xff00) >> 8) == 0);
-
-		write_pstates_for_core(Pstate_num, Pstate_feq, Pstate_power,
-				Pstate_latency, Pstate_control, Pstate_status,
-				index, pcontrol_blk, plen, onlyBSP, single_link);
-	}
-	acpigen_pop_len();
-}
diff --git a/src/cpu/amd/model_10xxx/processor_name.c b/src/cpu/amd/model_10xxx/processor_name.c
deleted file mode 100644
index 12c45c9..0000000
--- a/src/cpu/amd/model_10xxx/processor_name.c
+++ /dev/null
@@ -1,323 +0,0 @@
-/*
- * This file is part of the coreboot project.
- *
- * Copyright (C) 2007 Advanced Micro Devices, Inc.
- * Copyright (C) 2008 Peter Stuge
- * Copyright (C) 2010 Marc Jones <marcj303@gmail.com>
- * Copyright (C) 2015 Timothy Pearson <tpearson@raptorengineeringinc.com>, Raptor Engineering
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc.
- */
-
-/*
- * This code sets the Processor Name String for AMD64 CPUs.
- *
- * Revision Guide for AMD Family 10h Processors
- * Publication # 41322 Revision: 3.17 Issue Date: February 2008
- */
-
-#include <console/console.h>
-#include <string.h>
-#include <cpu/x86/msr.h>
-#include <cpu/amd/mtrr.h>
-#include <cpu/cpu.h>
-#include <cpu/amd/model_10xxx_rev.h>
-
-/* The maximum length of CPU names is 48 bytes, including the final NULL byte.
- * If you change these names your BIOS will _NOT_ pass the AMD validation and
- * your mainboard will not be posted on the AMD Recommended Motherboard Website
- */
-
-struct str_s {
-	u8 Pg;
-	u8 NC;
-	u8 String;
-	char const *value;
-};
-
-
-static const struct str_s String1_socket_F[] = {
-	{0x00, 0x01, 0x00, "Dual-Core AMD Opteron(tm) Processor 83"},
-	{0x00, 0x01, 0x01, "Dual-Core AMD Opteron(tm) Processor 23"},
-	{0x00, 0x03, 0x00, "Quad-Core AMD Opteron(tm) Processor 83"},
-	{0x00, 0x03, 0x01, "Quad-Core AMD Opteron(tm) Processor 23"},
-	{0x00, 0x05, 0x00, "Six-Core AMD Opteron(tm) Processor 84"},
-	{0x00, 0x05, 0x01, "Six-Core AMD Opteron(tm) Processor 24"},
-	{0x00, 0x03, 0x02, "Embedded AMD Opteron(tm) Processor 83"},
-	{0x00, 0x03, 0x03, "Embedded AMD Opteron(tm) Processor 23"},
-	{0x00, 0x03, 0x04, "Embedded AMD Opteron(tm) Processor 13"},
-	{0x00, 0x03, 0x05, "AMD Phenom(tm) FX-"},
-	{0x01, 0x01, 0x01, "Embedded AMD Opteron(tm) Processor"},
-	{0, 0, 0, NULL}
-};
-
-static const struct str_s String2_socket_F[] = {
-	{0x00, 0xFF, 0x02, " EE"},
-	{0x00, 0xFF, 0x0A, " SE"},
-	{0x00, 0xFF, 0x0B, " HE"},
-	{0x00, 0xFF, 0x0C, " EE"},
-	{0x00, 0xFF, 0x0D, " Quad-Core Processor"},
-	{0x00, 0xFF, 0x0F, ""},
-	{0x01, 0x01, 0x01, "GF HE"},
-	{0, 0, 0, NULL}
-};
-
-
-static const struct str_s String1_socket_AM2[] = {
-	{0x00, 0x00, 0x00, "AMD Athlon(tm) Processor LE-"},
-	{0x00, 0x00, 0x01, "AMD Sempron(tm) Processor LE-"},
-	{0x00, 0x00, 0x02, "AMD Sempron(tm) 1"},
-	{0x00, 0x00, 0x03, "AMD Athlon(tm) II 1"},
-	{0x00, 0x01, 0x00, "Dual-Core AMD Opteron(tm) Processor 13"},
-	{0x00, 0x01, 0x01, "AMD Athlon(tm)"},
-	{0x00, 0x01, 0x03, "AMD Athlon(tm) II X2 2"},
-	{0x00, 0x01, 0x04, "AMD Athlon(tm) II X2 B"},
-	{0x00, 0x01, 0x05, "AMD Athlon(tm) II X2"},
-	{0x00, 0x01, 0x07, "AMD Phenom(tm) II X2 5"},
-	{0x00, 0x01, 0x0A, "AMD Phenom(tm) II X2"},
-	{0x00, 0x01, 0x0B, "AMD Phenom(tm) II X2 B"},
-	{0x00, 0x02, 0x00, "AMD Phenom(tm)"},
-	{0x00, 0x02, 0x03, "AMD Phenom(tm) II X3 B"},
-	{0x00, 0x02, 0x04, "AMD Phenom(tm) II X3"},
-	{0x00, 0x02, 0x07, "AMD Athlon(tm) II X3 4"},
-	{0x00, 0x02, 0x08, "AMD Phenom(tm) II X3 7"},
-	{0x00, 0x02, 0x0A, "AMD Athlon(tm) II X3"},
-	{0x00, 0x03, 0x00, "Quad-Core AMD Opteron(tm) Processor 13"},
-	{0x00, 0x03, 0x01, "AMD Phenom(tm) FX-"},
-	{0x00, 0x03, 0x02, "AMD Phenom(tm)"},
-	{0x00, 0x03, 0x03, "AMD Phenom(tm) II X4 9"},
-	{0x00, 0x03, 0x04, "AMD Phenom(tm) II X4 8"},
-	{0x00, 0x03, 0x07, "AMD Phenom(tm) II X4 B"},
-	{0x00, 0x03, 0x08, "AMD Phenom(tm) II X4"},
-	{0x00, 0x03, 0x0A, "AMD Athlon(tm) II X4 6"},
-	{0x00, 0x03, 0x0F, "AMD Athlon(tm) II X4"},
-	{0, 0, 0, NULL}
-};
-
-static const struct str_s String2_socket_AM2[] = {
-	{0x00, 0x00, 0x00, "00"},
-	{0x00, 0x00, 0x01, "10"},
-	{0x00, 0x00, 0x02, "20"},
-	{0x00, 0x00, 0x03, "30"},
-	{0x00, 0x00, 0x04, "40"},
-	{0x00, 0x00, 0x05, "50"},
-	{0x00, 0x00, 0x06, "60"},
-	{0x00, 0x00, 0x07, "70"},
-	{0x00, 0x00, 0x08, "80"},
-	{0x00, 0x00, 0x09, "90"},
-	{0x00, 0x00, 0x09, " Processor"},
-	{0x00, 0x00, 0x09, "u Processor"},
-	{0x00, 0x01, 0x00, "00 Dual-Core Processor"},
-	{0x00, 0x01, 0x01, "00e Dual-Core Processor"},
-	{0x00, 0x01, 0x02, "00B Dual-Core Processor"},
-	{0x00, 0x01, 0x03, "50 Dual-Core Processor"},
-	{0x00, 0x01, 0x04, "50e Dual-Core Processor"},
-	{0x00, 0x01, 0x05, "50B Dual-Core Processor"},
-	{0x00, 0x01, 0x06, " Processor"},
-	{0x00, 0x01, 0x07, "e Processor"},
-	{0x00, 0x01, 0x09, "0 Processor"},
-	{0x00, 0x01, 0x0A, "0e Processor"},
-	{0x00, 0x01, 0x0B, "u Processor"},
-	{0x00, 0x02, 0x00, "00 Triple-Core Processor"},
-	{0x00, 0x02, 0x01, "00e Triple-Core Processor"},
-	{0x00, 0x02, 0x02, "00B Triple-Core Processor"},
-	{0x00, 0x02, 0x03, "50 Triple-Core Processor"},
-	{0x00, 0x02, 0x04, "50e Triple-Core Processor"},
-	{0x00, 0x02, 0x05, "50B Triple-Core Processor"},
-	{0x00, 0x02, 0x06, " Processor"},
-	{0x00, 0x02, 0x07, "e Processor"},
-	{0x00, 0x02, 0x09, "0e Processor"},
-	{0x00, 0x02, 0x0A, "0 Processor"},
-	{0x00, 0x03, 0x00, "00 Quad-Core Processor"},
-	{0x00, 0x03, 0x01, "00e Quad-Core Processor"},
-	{0x00, 0x03, 0x02, "00B Quad-Core Processor"},
-	{0x00, 0x03, 0x03, "50 Quad-Core Processor"},
-	{0x00, 0x03, 0x04, "50e Quad-Core Processor"},
-	{0x00, 0x03, 0x05, "50B Quad-Core Processor"},
-	{0x00, 0x03, 0x06, " Processor"},
-	{0x00, 0x03, 0x07, "e Processor"},
-	{0x00, 0x03, 0x09, "0e Processor"},
-	{0x00, 0x03, 0x0A, " SE"},
-	{0x00, 0x03, 0x0B, " HE"},
-	{0x00, 0x03, 0x0C, " EE"},
-	{0x00, 0x03, 0x0D, " Quad-Core Processor"},
-	{0x00, 0x03, 0x0E, "0 Processor"},
-	{0x00, 0xFF, 0x0F, ""},
-	{0, 0, 0, NULL}
-};
-
-static const struct str_s String1_socket_G34[] = {
-	{0x00, 0x07, 0x00, "AMD Opteron(tm) Processor 61"},
-	{0x00, 0x0B, 0x00, "AMD Opteron(tm) Processor 61"},
-	{0x01, 0x07, 0x01, "Embedded AMD Opteron(tm) Processor "},
-	{0, 0, 0, NULL}
-};
-
-static const struct str_s String2_socket_G34[] = {
-	{0x00, 0x07, 0x00, " HE"},
-	{0x00, 0x07, 0x01, " SE"},
-	{0x00, 0x0B, 0x00, " HE"},
-	{0x00, 0x0B, 0x01, " SE"},
-	{0x00, 0x0B, 0x0F, ""},
-	{0x01, 0x07, 0x01, " QS"},
-	{0x01, 0x07, 0x02, " KS"},
-	{0, 0, 0, NULL}
-};
-
-static const struct str_s String1_socket_C32[] = {
-	{0x00, 0x03, 0x00, "AMD Opteron(tm) Processor 41"},
-	{0x00, 0x05, 0x00, "AMD Opteron(tm) Processor 41"},
-	{0x01, 0x03, 0x01, "Embedded AMD Opteron(tm) Processor "},
-	{0x01, 0x05, 0x01, "Embedded AMD Opteron(tm) Processor "},
-	{0, 0, 0, NULL}
-};
-
-static const struct str_s String2_socket_C32[] = {
-	{0x00, 0x03, 0x00, " HE"},
-	{0x00, 0x03, 0x01, " EE"},
-	{0x00, 0x05, 0x00, " HE"},
-	{0x00, 0x05, 0x01, " EE"},
-	{0x01, 0x03, 0x01, "QS HE"},
-	{0x01, 0x03, 0x02, "LE HE"},
-	{0x01, 0x05, 0x01, "KX HE"},
-	{0x01, 0x05, 0x02, "GL EE"},
-	{0, 0, 0, NULL}
-};
-
-const char *unknown = "AMD Processor model unknown";
-const char *unknown2 = " type unknown";
-const char *sample = "AMD Engineering Sample";
-const char *thermal = "AMD Thermal Test Kit";
-
-
-static int strcpymax(char *dst, const char *src, int buflen)
-{
-	int i;
-	for (i = 0; i < buflen && src[i]; i++)
-		dst[i] = src[i];
-	if (i >= buflen)
-		i--;
-	dst[i] = 0;
-	return i;
-}
-
-
-int init_processor_name(void)
-{
-	/* variable names taken from fam10 revision guide for clarity */
-	u32 BrandId;	/* CPUID Fn8000_0001_EBX */
-	u8 String1;	/* BrandID[14:11] */
-	u8 String2;	/* BrandID[3:0] */
-	u8 Model;	/* BrandID[10:4] */
-	u8 Pg;		/* BrandID[15] */
-	u8 PkgTyp;	/* BrandID[31:28] */
-	u8 NC;		/* CPUID Fn8000_0008_ECX */
-	const char *processor_name_string = unknown;
-	char program_string[48];
-	u32 *p_program_string = (u32 *)program_string;
-	msr_t msr;
-	int i, j = 0, str2_checkNC = 1;
-	const struct str_s *str, *str2;
-
-
-	/* Find out which CPU brand it is */
-	BrandId = cpuid_ebx(0x80000001);
-	String1 = (u8)((BrandId >> 11) & 0x0F);
-	String2 = (u8)((BrandId >> 0) & 0x0F);
-	Model = (u8)((BrandId >> 4) & 0x7F);
-	Pg = (u8)((BrandId >> 15) & 0x01);
-	PkgTyp = (u8)((BrandId >> 28) & 0x0F);
-	NC = (u8)(cpuid_ecx(0x80000008) & 0xFF);
-
-	/* null the string */
-	memset(program_string, 0, sizeof(program_string));
-
-	if (!Model) {
-		processor_name_string = Pg ? thermal : sample;
-		goto done;
-	}
-
-	switch (PkgTyp) {
-	case 0:		/* F1207 */
-		str = String1_socket_F;
-		str2 = String2_socket_F;
-		str2_checkNC = 0;
-		break;
-	case 1:		/* AM2 */
-		str = String1_socket_AM2;
-		str2 = String2_socket_AM2;
-		break;
-	case 3:		/* G34 */
-		str = String1_socket_G34;
-		str2 = String2_socket_G34;
-		str2_checkNC = 0;
-		break;
-	case 5:		/* C32 */
-		str = String1_socket_C32;
-		str2 = String2_socket_C32;
-		break;
-	default:
-		goto done;
-	}
-
-	/* String1 */
-	for (i = 0; str[i].value; i++) {
-		if ((str[i].Pg == Pg) &&
-		    (str[i].NC == NC) &&
-		    (str[i].String == String1)) {
-			processor_name_string = str[i].value;
-			break;
-		}
-	}
-
-	if (!str[i].value)
-		goto done;
-
-	j = strcpymax(program_string, processor_name_string,
-		      sizeof(program_string));
-
-	/* Translate Model from 01-99 to ASCII and put it on the end.
-	 * Numbers less than 10 should include a leading zero, e.g., 09.*/
-	if (Model < 100 && j < sizeof(program_string) - 2) {
-		program_string[j++] = (Model / 10) + '0';
-		program_string[j++] = (Model % 10) + '0';
-	}
-
-	processor_name_string = unknown2;
-
-	/* String 2 */
-	for(i = 0; str2[i].value; i++) {
-		if ((str2[i].Pg == Pg) &&
-		    ((str2[i].NC == NC) || !str2_checkNC) &&
-		    (str2[i].String == String2)) {
-			processor_name_string = str2[i].value;
-			break;
-		}
-	}
-
-
-done:
-	strcpymax(&program_string[j], processor_name_string,
-		  sizeof(program_string) - j);
-
-	printk(BIOS_DEBUG, "CPU model: %s\n", program_string);
-
-	for (i = 0; i < 6; i++) {
-		msr.lo = p_program_string[(2 * i) + 0];
-		msr.hi = p_program_string[(2 * i) + 1];
-		wrmsr_amd(0xC0010030 + i, msr);
-	}
-
-	return 0;
-}
diff --git a/src/cpu/amd/model_10xxx/ram_calc.c b/src/cpu/amd/model_10xxx/ram_calc.c
deleted file mode 100644
index 46ccdbd..0000000
--- a/src/cpu/amd/model_10xxx/ram_calc.c
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * This file is part of the coreboot project.
- *
- * Copyright (C) 2015 Timothy Pearson <tpearson@raptorengineeringinc.com>, Raptor Engineering
- * Copyright (C) 2007 Advanced Micro Devices, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc.
- */
-
-#include <cpu/cpu.h>
-#include <cpu/x86/msr.h>
-#include <cpu/amd/mtrr.h>
-
-#include <cbmem.h>
-
-#include "ram_calc.h"
-
-#if !IS_ENABLED(CONFIG_LATE_CBMEM_INIT)
-uint64_t get_uma_memory_size(uint64_t topmem)
-{
-	uint64_t uma_size = 0;
-	if (IS_ENABLED(CONFIG_GFXUMA)) {
-		/* refer to UMA Size Consideration in 780 BDG. */
-		if (topmem >= 0x40000000)	/* 1GB and above system memory */
-			uma_size = 0x10000000;	/* 256M recommended UMA */
-
-		else if (topmem >= 0x20000000)	/* 512M - 1023M system memory */
-			uma_size = 0x8000000;	/* 128M recommended UMA */
-
-		else if (topmem >= 0x10000000)	/* 256M - 511M system memory */
-			uma_size = 0x4000000;	/* 64M recommended UMA */
-	}
-
-	return uma_size;
-}
-
-void *cbmem_top(void)
-{
-	uint32_t topmem = rdmsr(TOP_MEM).lo;
-
-	return (void *) topmem - get_uma_memory_size(topmem);
-}
-#endif
diff --git a/src/cpu/amd/model_10xxx/ram_calc.h b/src/cpu/amd/model_10xxx/ram_calc.h
deleted file mode 100644
index 61da328..0000000
--- a/src/cpu/amd/model_10xxx/ram_calc.h
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * This file is part of the coreboot project.
- *
- * Copyright (C) 2015 Timothy Pearson <tpearson@raptorengineeringinc.com>, Raptor Engineering
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc.
- */
-
-#ifndef _AMD_MODEL_10XXX_RAM_CALC_H_
-#define _AMD_MODEL_10XXX_RAM_CALC_H_
-
-uint64_t get_uma_memory_size(uint64_t topmem);
-
-#endif
diff --git a/src/cpu/amd/model_10xxx/update_microcode.c b/src/cpu/amd/model_10xxx/update_microcode.c
deleted file mode 100644
index 51aca35..0000000
--- a/src/cpu/amd/model_10xxx/update_microcode.c
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * This file is part of the coreboot project.
- *
- * Copyright (C) 2015 Timothy Pearson <tpearson@raptorengineeringinc.com>, Raptor Engineering
- * Copyright (C) 2007 Advanced Micro Devices, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc.
- */
-
-#include <stdint.h>
-#include <cpu/amd/microcode.h>
-
-struct id_mapping {
-        uint32_t orig_id;
-        uint16_t new_id;
-};
-
-static u16 get_equivalent_processor_rev_id(u32 orig_id) {
-	static const struct id_mapping id_mapping_table[] = {
-		{ 0x100f00, 0x1000 },
-		{ 0x100f01, 0x1000 },
-		{ 0x100f02, 0x1000 },
-		{ 0x100f20, 0x1020 },
-		{ 0x100f21, 0x1020 }, /* DR-B1 */
-		{ 0x100f2A, 0x1020 }, /* DR-BA */
-		{ 0x100f22, 0x1022 }, /* DR-B2 */
-		{ 0x100f23, 0x1022 }, /* DR-B3 */
-		{ 0x100f42, 0x1041 }, /* RB-C2 */
-		{ 0x100f43, 0x1043 }, /* RB-C3 */
-		{ 0x100f52, 0x1041 }, /* BL-C2 */
-		{ 0x100f62, 0x1062 }, /* DA-C2 */
-		{ 0x100f63, 0x1043 }, /* DA-C3 */
-		{ 0x100f81, 0x1081 }, /* HY-D1 */
-		{ 0x100fa0, 0x10A0 }, /* PH-E0 */
-
-		/* Array terminator */
-		{ 0xffffff, 0x0000 },
-	};
-
-	u32 new_id;
-	int i;
-
-	new_id = 0;
-
-	for (i = 0; id_mapping_table[i].orig_id != 0xffffff; i++) {
-		if (id_mapping_table[i].orig_id == orig_id) {
-			new_id = id_mapping_table[i].new_id;
-			break;
-		}
-	}
-
-	return new_id;
-
-}
-
-void update_microcode(u32 cpu_deviceid)
-{
-	u32 equivalent_processor_rev_id = get_equivalent_processor_rev_id(cpu_deviceid);
-	amd_update_microcode_from_cbfs(equivalent_processor_rev_id);
-}
diff --git a/src/cpu/amd/socket_AM2r2/Makefile.inc b/src/cpu/amd/socket_AM2r2/Makefile.inc
index 3675af4..6917441 100644
--- a/src/cpu/amd/socket_AM2r2/Makefile.inc
+++ b/src/cpu/amd/socket_AM2r2/Makefile.inc
@@ -1,4 +1,4 @@
-subdirs-y += ../model_10xxx
+subdirs-y += ../family_10h-family_15h
 subdirs-y += ../quadcore
 subdirs-y += ../mtrr
 subdirs-y += ../microcode
diff --git a/src/cpu/amd/socket_AM3/Makefile.inc b/src/cpu/amd/socket_AM3/Makefile.inc
index 3675af4..6917441 100644
--- a/src/cpu/amd/socket_AM3/Makefile.inc
+++ b/src/cpu/amd/socket_AM3/Makefile.inc
@@ -1,4 +1,4 @@
-subdirs-y += ../model_10xxx
+subdirs-y += ../family_10h-family_15h
 subdirs-y += ../quadcore
 subdirs-y += ../mtrr
 subdirs-y += ../microcode
diff --git a/src/cpu/amd/socket_ASB2/Makefile.inc b/src/cpu/amd/socket_ASB2/Makefile.inc
index 3675af4..6917441 100644
--- a/src/cpu/amd/socket_ASB2/Makefile.inc
+++ b/src/cpu/amd/socket_ASB2/Makefile.inc
@@ -1,4 +1,4 @@
-subdirs-y += ../model_10xxx
+subdirs-y += ../family_10h-family_15h
 subdirs-y += ../quadcore
 subdirs-y += ../mtrr
 subdirs-y += ../microcode
diff --git a/src/cpu/amd/socket_C32/Makefile.inc b/src/cpu/amd/socket_C32/Makefile.inc
index 3675af4..6917441 100644
--- a/src/cpu/amd/socket_C32/Makefile.inc
+++ b/src/cpu/amd/socket_C32/Makefile.inc
@@ -1,4 +1,4 @@
-subdirs-y += ../model_10xxx
+subdirs-y += ../family_10h-family_15h
 subdirs-y += ../quadcore
 subdirs-y += ../mtrr
 subdirs-y += ../microcode
diff --git a/src/cpu/amd/socket_F_1207/Makefile.inc b/src/cpu/amd/socket_F_1207/Makefile.inc
index b74862e..ece8d9a 100644
--- a/src/cpu/amd/socket_F_1207/Makefile.inc
+++ b/src/cpu/amd/socket_F_1207/Makefile.inc
@@ -1,4 +1,4 @@
-subdirs-y += ../model_10xxx
+subdirs-y += ../family_10h-family_15h
 subdirs-y += ../quadcore
 subdirs-y += ../mtrr
 subdirs-y += ../microcode
diff --git a/src/cpu/amd/socket_G34/Makefile.inc b/src/cpu/amd/socket_G34/Makefile.inc
index a8e1333..de33cd3 100644
--- a/src/cpu/amd/socket_G34/Makefile.inc
+++ b/src/cpu/amd/socket_G34/Makefile.inc
@@ -1,5 +1,5 @@
 ramstage-y += socket_G34.c
-subdirs-y += ../model_10xxx
+subdirs-y += ../family_10h-family_15h
 subdirs-y += ../quadcore
 subdirs-y += ../mtrr
 subdirs-y += ../microcode
diff --git a/src/mainboard/advansus/a785e-i/romstage.c b/src/mainboard/advansus/a785e-i/romstage.c
index dfda22e..4c2b38a 100644
--- a/src/mainboard/advansus/a785e-i/romstage.c
+++ b/src/mainboard/advansus/a785e-i/romstage.c
@@ -68,7 +68,7 @@ static int spd_read_byte(u32 device, u32 address)
 #include "resourcemap.c"
 #include "cpu/amd/quadcore/quadcore.c"
 #include <cpu/amd/microcode.h>
-#include "cpu/amd/model_10xxx/init_cpus.c"
+#include "cpu/amd/family_10h-family_15h/init_cpus.c"
 #include "northbridge/amd/amdfam10/early_ht.c"
 #include "spd.h"
 #include <reset.h>
diff --git a/src/mainboard/amd/bimini_fam10/romstage.c b/src/mainboard/amd/bimini_fam10/romstage.c
index 9e2e904..e2bd351 100644
--- a/src/mainboard/amd/bimini_fam10/romstage.c
+++ b/src/mainboard/amd/bimini_fam10/romstage.c
@@ -65,7 +65,7 @@ static int spd_read_byte(u32 device, u32 address)
 #include "cpu/amd/quadcore/quadcore.c"
 #include <cpu/amd/microcode.h>
 
-#include "cpu/amd/model_10xxx/init_cpus.c"
+#include "cpu/amd/family_10h-family_15h/init_cpus.c"
 #include "northbridge/amd/amdfam10/early_ht.c"
 
 void cache_as_ram_main(unsigned long bist, unsigned long cpu_init_detectedx)
diff --git a/src/mainboard/amd/mahogany_fam10/romstage.c b/src/mainboard/amd/mahogany_fam10/romstage.c
index c01ccf0..74bc9d5 100644
--- a/src/mainboard/amd/mahogany_fam10/romstage.c
+++ b/src/mainboard/amd/mahogany_fam10/romstage.c
@@ -68,7 +68,7 @@ static int spd_read_byte(u32 device, u32 address)
 #include "cpu/amd/quadcore/quadcore.c"
 #include <cpu/amd/microcode.h>
 
-#include "cpu/amd/model_10xxx/init_cpus.c"
+#include "cpu/amd/family_10h-family_15h/init_cpus.c"
 #include "northbridge/amd/amdfam10/early_ht.c"
 
 void cache_as_ram_main(unsigned long bist, unsigned long cpu_init_detectedx)
diff --git a/src/mainboard/amd/serengeti_cheetah_fam10/romstage.c b/src/mainboard/amd/serengeti_cheetah_fam10/romstage.c
index 3d7c168..20d46e6 100644
--- a/src/mainboard/amd/serengeti_cheetah_fam10/romstage.c
+++ b/src/mainboard/amd/serengeti_cheetah_fam10/romstage.c
@@ -87,7 +87,7 @@ static int spd_read_byte(u32 device, u32 address)
 #include "cpu/amd/quadcore/quadcore.c"
 #include <cpu/amd/microcode.h>
 
-#include "cpu/amd/model_10xxx/init_cpus.c"
+#include "cpu/amd/family_10h-family_15h/init_cpus.c"
 #include "northbridge/amd/amdfam10/early_ht.c"
 
 static const u8 spd_addr[] = {
diff --git a/src/mainboard/amd/tilapia_fam10/romstage.c b/src/mainboard/amd/tilapia_fam10/romstage.c
index 924345d..89100b1 100644
--- a/src/mainboard/amd/tilapia_fam10/romstage.c
+++ b/src/mainboard/amd/tilapia_fam10/romstage.c
@@ -67,7 +67,7 @@ static int spd_read_byte(u32 device, u32 address)
 #include "cpu/amd/quadcore/quadcore.c"
 #include <cpu/amd/microcode.h>
 
-#include "cpu/amd/model_10xxx/init_cpus.c"
+#include "cpu/amd/family_10h-family_15h/init_cpus.c"
 #include "northbridge/amd/amdfam10/early_ht.c"
 #include <spd.h>
 
diff --git a/src/mainboard/asus/kfsn4-dre/romstage.c b/src/mainboard/asus/kfsn4-dre/romstage.c
index b35473c..5d1f5a6 100644
--- a/src/mainboard/asus/kfsn4-dre/romstage.c
+++ b/src/mainboard/asus/kfsn4-dre/romstage.c
@@ -74,7 +74,7 @@ static inline int spd_read_byte(unsigned device, unsigned address)
 #include "southbridge/nvidia/ck804/early_setup_car.c"
 #include <cpu/amd/microcode.h>
 
-#include "cpu/amd/model_10xxx/init_cpus.c"
+#include "cpu/amd/family_10h-family_15h/init_cpus.c"
 #include "northbridge/amd/amdfam10/early_ht.c"
 
 #define GPIO3_DEV PNP_DEV(0x2e, W83627THG_GPIO3)
diff --git a/src/mainboard/asus/kgpe-d16/romstage.c b/src/mainboard/asus/kgpe-d16/romstage.c
index 18e7c16..a3f3310 100644
--- a/src/mainboard/asus/kgpe-d16/romstage.c
+++ b/src/mainboard/asus/kgpe-d16/romstage.c
@@ -66,7 +66,7 @@ static inline int spd_read_byte(unsigned device, unsigned address)
 
 #include <cpu/amd/microcode.h>
 
-#include "cpu/amd/model_10xxx/init_cpus.c"
+#include "cpu/amd/family_10h-family_15h/init_cpus.c"
 #include "northbridge/amd/amdfam10/early_ht.c"
 
 /*
diff --git a/src/mainboard/asus/m4a78-em/romstage.c b/src/mainboard/asus/m4a78-em/romstage.c
index bcff9e4..82f30d9 100644
--- a/src/mainboard/asus/m4a78-em/romstage.c
+++ b/src/mainboard/asus/m4a78-em/romstage.c
@@ -68,7 +68,7 @@ static int spd_read_byte(u32 device, u32 address)
 #include "cpu/amd/quadcore/quadcore.c"
 #include <cpu/amd/microcode.h>
 
-#include "cpu/amd/model_10xxx/init_cpus.c"
+#include "cpu/amd/family_10h-family_15h/init_cpus.c"
 #include "northbridge/amd/amdfam10/early_ht.c"
 #include <spd.h>
 
diff --git a/src/mainboard/asus/m4a785-m/romstage.c b/src/mainboard/asus/m4a785-m/romstage.c
index e49c9b9..780bf81 100644
--- a/src/mainboard/asus/m4a785-m/romstage.c
+++ b/src/mainboard/asus/m4a785-m/romstage.c
@@ -68,7 +68,7 @@ static int spd_read_byte(u32 device, u32 address)
 #include "cpu/amd/quadcore/quadcore.c"
 #include <cpu/amd/microcode.h>
 
-#include "cpu/amd/model_10xxx/init_cpus.c"
+#include "cpu/amd/family_10h-family_15h/init_cpus.c"
 #include "northbridge/amd/amdfam10/early_ht.c"
 #include <spd.h>
 
diff --git a/src/mainboard/asus/m5a88-v/romstage.c b/src/mainboard/asus/m5a88-v/romstage.c
index 35e9e94..38761a6 100644
--- a/src/mainboard/asus/m5a88-v/romstage.c
+++ b/src/mainboard/asus/m5a88-v/romstage.c
@@ -66,7 +66,7 @@ static int spd_read_byte(u32 device, u32 address)
 #include "resourcemap.c"
 #include "cpu/amd/quadcore/quadcore.c"
 #include <cpu/amd/microcode.h>
-#include "cpu/amd/model_10xxx/init_cpus.c"
+#include "cpu/amd/family_10h-family_15h/init_cpus.c"
 #include "northbridge/amd/amdfam10/early_ht.c"
 #include "spd.h"
 #include <reset.h>
diff --git a/src/mainboard/avalue/eax-785e/romstage.c b/src/mainboard/avalue/eax-785e/romstage.c
index bace1d0..764a5c6 100644
--- a/src/mainboard/avalue/eax-785e/romstage.c
+++ b/src/mainboard/avalue/eax-785e/romstage.c
@@ -69,7 +69,7 @@ static int spd_read_byte(u32 device, u32 address)
 #include "resourcemap.c"
 #include "cpu/amd/quadcore/quadcore.c"
 #include <cpu/amd/microcode.h>
-#include "cpu/amd/model_10xxx/init_cpus.c"
+#include "cpu/amd/family_10h-family_15h/init_cpus.c"
 #include "northbridge/amd/amdfam10/early_ht.c"
 #include "spd.h"
 #include <reset.h>
diff --git a/src/mainboard/gigabyte/ma785gm/romstage.c b/src/mainboard/gigabyte/ma785gm/romstage.c
index 8ac24f9..db4e449 100644
--- a/src/mainboard/gigabyte/ma785gm/romstage.c
+++ b/src/mainboard/gigabyte/ma785gm/romstage.c
@@ -64,7 +64,7 @@ static int spd_read_byte(u32 device, u32 address)
 #include "cpu/amd/quadcore/quadcore.c"
 #include <cpu/amd/microcode.h>
 
-#include "cpu/amd/model_10xxx/init_cpus.c"
+#include "cpu/amd/family_10h-family_15h/init_cpus.c"
 #include "northbridge/amd/amdfam10/early_ht.c"
 #include <spd.h>
 
diff --git a/src/mainboard/gigabyte/ma785gmt/romstage.c b/src/mainboard/gigabyte/ma785gmt/romstage.c
index cd9b790..4ce7c58 100644
--- a/src/mainboard/gigabyte/ma785gmt/romstage.c
+++ b/src/mainboard/gigabyte/ma785gmt/romstage.c
@@ -64,7 +64,7 @@ static int spd_read_byte(u32 device, u32 address)
 #include "cpu/amd/quadcore/quadcore.c"
 #include <cpu/amd/microcode.h>
 
-#include "cpu/amd/model_10xxx/init_cpus.c"
+#include "cpu/amd/family_10h-family_15h/init_cpus.c"
 #include "northbridge/amd/amdfam10/early_ht.c"
 #include <spd.h>
 
diff --git a/src/mainboard/gigabyte/ma78gm/romstage.c b/src/mainboard/gigabyte/ma78gm/romstage.c
index 6cb4227..d2a0b95 100644
--- a/src/mainboard/gigabyte/ma78gm/romstage.c
+++ b/src/mainboard/gigabyte/ma78gm/romstage.c
@@ -68,7 +68,7 @@ static int spd_read_byte(u32 device, u32 address)
 #include "cpu/amd/quadcore/quadcore.c"
 #include <cpu/amd/microcode.h>
 
-#include "cpu/amd/model_10xxx/init_cpus.c"
+#include "cpu/amd/family_10h-family_15h/init_cpus.c"
 #include "northbridge/amd/amdfam10/early_ht.c"
 #include <spd.h>
 
diff --git a/src/mainboard/hp/dl165_g6_fam10/romstage.c b/src/mainboard/hp/dl165_g6_fam10/romstage.c
index 62fd6cb..97e60d5 100644
--- a/src/mainboard/hp/dl165_g6_fam10/romstage.c
+++ b/src/mainboard/hp/dl165_g6_fam10/romstage.c
@@ -78,7 +78,7 @@ static inline int spd_read_byte(unsigned device, unsigned address)
 #include "cpu/amd/quadcore/quadcore.c"
 #include <cpu/amd/microcode.h>
 
-#include "cpu/amd/model_10xxx/init_cpus.c"
+#include "cpu/amd/family_10h-family_15h/init_cpus.c"
 #include "northbridge/amd/amdfam10/early_ht.c"
 
 static const u8 spd_addr[] = {
diff --git a/src/mainboard/iei/kino-780am2-fam10/romstage.c b/src/mainboard/iei/kino-780am2-fam10/romstage.c
index 6df828b..edbae3a 100644
--- a/src/mainboard/iei/kino-780am2-fam10/romstage.c
+++ b/src/mainboard/iei/kino-780am2-fam10/romstage.c
@@ -67,7 +67,7 @@ static int spd_read_byte(u32 device, u32 address)
 #include "cpu/amd/quadcore/quadcore.c"
 #include <cpu/amd/microcode.h>
 
-#include "cpu/amd/model_10xxx/init_cpus.c"
+#include "cpu/amd/family_10h-family_15h/init_cpus.c"
 #include "northbridge/amd/amdfam10/early_ht.c"
 #include <spd.h>
 
diff --git a/src/mainboard/jetway/pa78vm5/romstage.c b/src/mainboard/jetway/pa78vm5/romstage.c
index ac66ada..16bb089 100644
--- a/src/mainboard/jetway/pa78vm5/romstage.c
+++ b/src/mainboard/jetway/pa78vm5/romstage.c
@@ -72,7 +72,7 @@ static int spd_read_byte(u32 device, u32 address)
 #include "cpu/amd/quadcore/quadcore.c"
 #include <cpu/amd/microcode.h>
 
-#include "cpu/amd/model_10xxx/init_cpus.c"
+#include "cpu/amd/family_10h-family_15h/init_cpus.c"
 #include "northbridge/amd/amdfam10/early_ht.c"
 #include <spd.h>
 
diff --git a/src/mainboard/msi/ms9652_fam10/romstage.c b/src/mainboard/msi/ms9652_fam10/romstage.c
index b8fca64..4ea3306 100644
--- a/src/mainboard/msi/ms9652_fam10/romstage.c
+++ b/src/mainboard/msi/ms9652_fam10/romstage.c
@@ -74,7 +74,7 @@ static inline int spd_read_byte(unsigned device, unsigned address)
 #include "southbridge/nvidia/mcp55/early_setup_car.c"
 #include <cpu/amd/microcode.h>
 
-#include "cpu/amd/model_10xxx/init_cpus.c"
+#include "cpu/amd/family_10h-family_15h/init_cpus.c"
 #include "northbridge/amd/amdfam10/early_ht.c"
 
 static void sio_setup(void)
diff --git a/src/mainboard/supermicro/h8dmr_fam10/romstage.c b/src/mainboard/supermicro/h8dmr_fam10/romstage.c
index d94d917..c224dbc 100644
--- a/src/mainboard/supermicro/h8dmr_fam10/romstage.c
+++ b/src/mainboard/supermicro/h8dmr_fam10/romstage.c
@@ -66,7 +66,7 @@ static inline int spd_read_byte(unsigned device, unsigned address)
 #include "southbridge/nvidia/mcp55/early_setup_car.c"
 #include <cpu/amd/microcode.h>
 
-#include "cpu/amd/model_10xxx/init_cpus.c"
+#include "cpu/amd/family_10h-family_15h/init_cpus.c"
 #include "northbridge/amd/amdfam10/early_ht.c"
 
 static void sio_setup(void)
diff --git a/src/mainboard/supermicro/h8qme_fam10/romstage.c b/src/mainboard/supermicro/h8qme_fam10/romstage.c
index c79c2b1..0f9445b 100644
--- a/src/mainboard/supermicro/h8qme_fam10/romstage.c
+++ b/src/mainboard/supermicro/h8qme_fam10/romstage.c
@@ -73,7 +73,7 @@ static inline int spd_read_byte(unsigned device, unsigned address)
 #include "southbridge/nvidia/mcp55/early_setup_car.c"
 #include <cpu/amd/microcode.h>
 
-#include "cpu/amd/model_10xxx/init_cpus.c"
+#include "cpu/amd/family_10h-family_15h/init_cpus.c"
 #include "northbridge/amd/amdfam10/early_ht.c"
 
 static void sio_setup(void)
diff --git a/src/mainboard/supermicro/h8scm_fam10/romstage.c b/src/mainboard/supermicro/h8scm_fam10/romstage.c
index b3174ae..4ea14fe 100644
--- a/src/mainboard/supermicro/h8scm_fam10/romstage.c
+++ b/src/mainboard/supermicro/h8scm_fam10/romstage.c
@@ -65,7 +65,7 @@ static int spd_read_byte(u32 device, u32 address)
 #include "resourcemap.c"
 #include "cpu/amd/quadcore/quadcore.c"
 #include <cpu/amd/microcode.h>
-#include "cpu/amd/model_10xxx/init_cpus.c"
+#include "cpu/amd/family_10h-family_15h/init_cpus.c"
 #include "northbridge/amd/amdfam10/early_ht.c"
 #include <spd.h>
 
diff --git a/src/mainboard/tyan/s2912_fam10/romstage.c b/src/mainboard/tyan/s2912_fam10/romstage.c
index 1049014..0030619 100644
--- a/src/mainboard/tyan/s2912_fam10/romstage.c
+++ b/src/mainboard/tyan/s2912_fam10/romstage.c
@@ -74,7 +74,7 @@ static inline int spd_read_byte(unsigned device, unsigned address)
 #include "southbridge/nvidia/mcp55/early_setup_car.c"
 #include <cpu/amd/microcode.h>
 
-#include "cpu/amd/model_10xxx/init_cpus.c"
+#include "cpu/amd/family_10h-family_15h/init_cpus.c"
 #include "northbridge/amd/amdfam10/early_ht.c"
 
 static void sio_setup(void)
diff --git a/src/northbridge/amd/amdfam10/northbridge.c b/src/northbridge/amd/amdfam10/northbridge.c
index ff324cd..fb3b2f7 100644
--- a/src/northbridge/amd/amdfam10/northbridge.c
+++ b/src/northbridge/amd/amdfam10/northbridge.c
@@ -34,7 +34,7 @@
 #include <cpu/x86/lapic.h>
 #include <cpu/amd/mtrr.h>
 #include <cpu/amd/amdfam10_sysconf.h>
-#include <cpu/amd/model_10xxx/ram_calc.h>
+#include <cpu/amd/family_10h-family_15h/ram_calc.h>
 
 #if CONFIG_LOGICAL_CPUS
 #include <cpu/amd/multicore.h>
-- 
1.7.9.5

