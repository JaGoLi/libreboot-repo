From f2d97b4ed0b0594b8983dbe4d551aca7f9e6a32e Mon Sep 17 00:00:00 2001
From: Timothy Pearson <tpearson@raptorengineeringinc.com>
Date: Sun, 21 Jun 2015 16:27:03 -0500
Subject: [PATCH 066/143] src/southbridge/amd/sb700: Reset SATA controller in
 AHCI mode during startup

In AHCI mode SeaBIOS randomly fails to detect disks (AHCI timeouts),
with the probability of a failure increasing with the number of disks
connected to the controller.  Resetting the SATA controller appears to
show the true state of the underlying hardware, allowing the drive
detection code to attempt link renegotiation as needed.

Change-Id: Ib1f7c5f830a0cdba41cb6f5b05d759adee5ce369
Signed-off-by: Timothy Pearson <tpearson@raptorengineeringinc.com>
---
 src/southbridge/amd/sb700/sata.c |   47 ++++++++++++++++++++++++++++----------
 1 file changed, 35 insertions(+), 12 deletions(-)

diff --git a/src/southbridge/amd/sb700/sata.c b/src/southbridge/amd/sb700/sata.c
index 24f78dd..d51baa1 100644
--- a/src/southbridge/amd/sb700/sata.c
+++ b/src/southbridge/amd/sb700/sata.c
@@ -135,6 +135,8 @@ static void sata_init(struct device *dev)
 	/* get rev_id */
 	rev_id = pci_read_config8(sm_dev, 0x08) - 0x28;
 
+	printk(BIOS_SPEW, "rev_id=%x\n", rev_id);
+
 	if (sata_ahci_mode) {
 		/* Enable link latency enhancement on A14 and above */
 		if (rev_id >= 0x14) {
@@ -245,6 +247,27 @@ static void sata_init(struct device *dev)
 		write32(sata_bar5 + 0xfc, dword);
 	}
 
+	if (sata_ahci_mode) {
+		/* FIXME
+		* SeaBIOS does not know how to spin
+		* up the drives and therefore hangs
+		* in AHCI init if this is enabled...
+		*/
+		/* Enable staggered spin-up */
+		dword = read32(sata_bar5 + 0x00);
+#if 0
+		dword |= 0x1 << 27;
+#else
+		dword &= ~(0x1 << 27);
+#endif
+		write32(sata_bar5 + 0x00, dword);
+
+		/* Reset the HBA to avoid stuck drives in SeaBIOS */
+		dword = read32(sata_bar5 + 0x04);
+		dword |= 0x1;
+		write32(sata_bar5 + 0x04, dword);
+	}
+
 	/* Write protect Sub-Class Code */
 	byte = pci_read_config8(dev, 0x40);
 	byte &= ~(1 << 0);
@@ -371,21 +394,21 @@ static void sata_init(struct device *dev)
 	}
 
 	/* Below is CIM InitSataLateFar */
-	/* Enable interrupts from the HBA  */
-	byte = read8(sata_bar5 + 0x4);
-	byte |= 1 << 1;
-	write8((sata_bar5 + 0x4), byte);
-
 	if (!sata_ahci_mode) {
-		/* Clear error status */
-		write32((sata_bar5 + 0x130), 0xFFFFFFFF);
-		write32((sata_bar5 + 0x1b0), 0xFFFFFFFF);
-		write32((sata_bar5 + 0x230), 0xFFFFFFFF);
-		write32((sata_bar5 + 0x2b0), 0xFFFFFFFF);
-		write32((sata_bar5 + 0x330), 0xFFFFFFFF);
-		write32((sata_bar5 + 0x3b0), 0xFFFFFFFF);
+		/* Enable interrupts from the HBA  */
+		byte = read8(sata_bar5 + 0x4);
+		byte |= 1 << 1;
+		write8((sata_bar5 + 0x4), byte);
 	}
 
+	/* Clear error status */
+	write32((sata_bar5 + 0x130), 0xFFFFFFFF);
+	write32((sata_bar5 + 0x1b0), 0xFFFFFFFF);
+	write32((sata_bar5 + 0x230), 0xFFFFFFFF);
+	write32((sata_bar5 + 0x2b0), 0xFFFFFFFF);
+	write32((sata_bar5 + 0x330), 0xFFFFFFFF);
+	write32((sata_bar5 + 0x3b0), 0xFFFFFFFF);
+
 	/* Clear SATA status,Firstly we get the AcpiGpe0BlkAddr */
 	/* ????? why CIM does not set the AcpiGpe0BlkAddr , but use it??? */
 
-- 
1.7.9.5

