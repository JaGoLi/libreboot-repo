From 72d183bad6db0f2f91b991710d1c0a8113a071f3 Mon Sep 17 00:00:00 2001
From: Timothy Pearson <tpearson@raptorengineeringinc.com>
Date: Sat, 5 Sep 2015 17:53:20 -0500
Subject: [PATCH 003/143] drivers/i2c/w83795: Add full support for core
 functions

Add full support for fan control, fan monitoring, and voltage
monitoring.  Fan speeds and functions are configurable via
each mainboard's devicetree.cb file.

NOTE: This patch effectively rewrites large portions of
the original driver.  You may need to re-verify correct
operation on your hardware if you were using the old
driver code.

Change-Id: I3e246af0e398d65ee43ea708060885c67fd7d202
Signed-off-by: Timothy Pearson <tpearson@raptorengineeringinc.com>
---
 src/drivers/i2c/w83795/chip.h   |  142 ++++++++++++++++
 src/drivers/i2c/w83795/w83795.c |  339 ++++++++++++++++++++++++++-------------
 src/drivers/i2c/w83795/w83795.h |   52 ++++--
 3 files changed, 405 insertions(+), 128 deletions(-)
 create mode 100644 src/drivers/i2c/w83795/chip.h

diff --git a/src/drivers/i2c/w83795/chip.h b/src/drivers/i2c/w83795/chip.h
new file mode 100644
index 0000000..c8a42ea
--- /dev/null
+++ b/src/drivers/i2c/w83795/chip.h
@@ -0,0 +1,142 @@
+/*
+ * This file is part of the coreboot project.
+ *
+ * Copyright (C) 2015 Raptor Engineering
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.
+ */
+
+struct drivers_i2c_w83795_config {
+	uint8_t fanin_ctl1;
+	uint8_t fanin_ctl2;
+
+	uint8_t temp_ctl1;
+	uint8_t temp_ctl2;
+	uint8_t temp_dtse;
+
+	uint8_t volt_ctl1;
+	uint8_t volt_ctl2;
+
+	uint8_t temp1_fan_select;
+	uint8_t temp2_fan_select;
+	uint8_t temp3_fan_select;
+	uint8_t temp4_fan_select;
+	uint8_t temp5_fan_select;
+	uint8_t temp6_fan_select;
+
+	uint8_t temp1_source_select;
+	uint8_t temp2_source_select;
+	uint8_t temp3_source_select;
+	uint8_t temp4_source_select;
+	uint8_t temp5_source_select;
+	uint8_t temp6_source_select;
+
+	uint32_t vcore1_high_limit_mv;		/* mV */
+	uint32_t vcore1_low_limit_mv;		/* mV */
+	uint32_t vcore2_high_limit_mv;		/* mV */
+	uint32_t vcore2_low_limit_mv;		/* mV */
+	uint32_t vtt_high_limit_mv;		/* mV */
+	uint32_t vtt_low_limit_mv;		/* mV */
+	uint32_t vsen3_high_limit_mv;		/* mV */
+	uint32_t vsen3_low_limit_mv;		/* mV */
+	uint32_t vsen4_high_limit_mv;		/* mV */
+	uint32_t vsen4_low_limit_mv;		/* mV */
+	uint32_t vsen5_high_limit_mv;		/* mV */
+	uint32_t vsen5_low_limit_mv;		/* mV */
+	uint32_t vsen6_high_limit_mv;		/* mV */
+	uint32_t vsen6_low_limit_mv;		/* mV */
+	uint32_t vsen7_high_limit_mv;		/* mV */
+	uint32_t vsen7_low_limit_mv;		/* mV */
+	uint32_t vsen8_high_limit_mv;		/* mV */
+	uint32_t vsen8_low_limit_mv;		/* mV */
+	uint32_t vsen9_high_limit_mv;		/* mV */
+	uint32_t vsen9_low_limit_mv;		/* mV */
+	uint32_t vsen10_high_limit_mv;		/* mV */
+	uint32_t vsen10_low_limit_mv;		/* mV */
+	uint32_t vsen11_high_limit_mv;		/* mV */
+	uint32_t vsen11_low_limit_mv;		/* mV */
+	uint32_t vsen12_high_limit_mv;		/* mV */
+	uint32_t vsen12_low_limit_mv;		/* mV */
+	uint32_t vsen13_high_limit_mv;		/* mV */
+	uint32_t vsen13_low_limit_mv;		/* mV */
+	uint32_t vdd_high_limit_mv;		/* mV */
+	uint32_t vdd_low_limit_mv;		/* mV */
+	uint32_t vsb_high_limit_mv;		/* mV */
+	uint32_t vsb_low_limit_mv;		/* mV */
+	uint32_t vbat_high_limit_mv;		/* mV */
+	uint32_t vbat_low_limit_mv;		/* mV */
+
+	int8_t tr1_critical_temperature;	/* °C */
+	int8_t tr1_critical_hysteresis;		/* °C */
+	int8_t tr1_warning_temperature;		/* °C */
+	int8_t tr1_warning_hysteresis;		/* °C */
+	int8_t tr2_critical_temperature;	/* °C */
+	int8_t tr2_critical_hysteresis;		/* °C */
+	int8_t tr2_warning_temperature;		/* °C */
+	int8_t tr2_warning_hysteresis;		/* °C */
+	int8_t tr3_critical_temperature;	/* °C */
+	int8_t tr3_critical_hysteresis;		/* °C */
+	int8_t tr3_warning_temperature;		/* °C */
+	int8_t tr3_warning_hysteresis;		/* °C */
+	int8_t tr4_critical_temperature;	/* °C */
+	int8_t tr4_critical_hysteresis;		/* °C */
+	int8_t tr4_warning_temperature;		/* °C */
+	int8_t tr4_warning_hysteresis;		/* °C */
+	int8_t tr5_critical_temperature;	/* °C */
+	int8_t tr5_critical_hysteresis;		/* °C */
+	int8_t tr5_warning_temperature;		/* °C */
+	int8_t tr5_warning_hysteresis;		/* °C */
+	int8_t tr6_critical_temperature;	/* °C */
+	int8_t tr6_critical_hysteresis;		/* °C */
+	int8_t tr6_warning_temperature;		/* °C */
+	int8_t tr6_warning_hysteresis;		/* °C */
+	int8_t dts_critical_temperature;	/* °C */
+	int8_t dts_critical_hysteresis;		/* °C */
+	int8_t dts_warning_temperature;		/* °C */
+	int8_t dts_warning_hysteresis;		/* °C */
+
+	int8_t temp1_critical_temperature;	/* °C */
+	int8_t temp2_critical_temperature;	/* °C */
+	int8_t temp3_critical_temperature;	/* °C */
+	int8_t temp4_critical_temperature;	/* °C */
+	int8_t temp5_critical_temperature;	/* °C */
+	int8_t temp6_critical_temperature;	/* °C */
+
+	int8_t temp1_target_temperature;	/* °C */
+	int8_t temp2_target_temperature;	/* °C */
+	int8_t temp3_target_temperature;	/* °C */
+	int8_t temp4_target_temperature;	/* °C */
+	int8_t temp5_target_temperature;	/* °C */
+	int8_t temp6_target_temperature;	/* °C */
+
+	uint8_t fan1_nonstop;			/* % of full speed (0-100) */
+	uint8_t fan2_nonstop;			/* % of full speed (0-100) */
+	uint8_t fan3_nonstop;			/* % of full speed (0-100) */
+	uint8_t fan4_nonstop;			/* % of full speed (0-100) */
+	uint8_t fan5_nonstop;			/* % of full speed (0-100) */
+	uint8_t fan6_nonstop;			/* % of full speed (0-100) */
+	uint8_t fan7_nonstop;			/* % of full speed (0-100) */
+	uint8_t fan8_nonstop;			/* % of full speed (0-100) */
+
+	uint8_t default_speed;			/* % of full speed (0-100) */
+
+	uint8_t fan1_duty;			/* % of full speed (0-100) */
+	uint8_t fan2_duty;			/* % of full speed (0-100) */
+	uint8_t fan3_duty;			/* % of full speed (0-100) */
+	uint8_t fan4_duty;			/* % of full speed (0-100) */
+	uint8_t fan5_duty;			/* % of full speed (0-100) */
+	uint8_t fan6_duty;			/* % of full speed (0-100) */
+	uint8_t fan7_duty;			/* % of full speed (0-100) */
+	uint8_t fan8_duty;			/* % of full speed (0-100) */
+};
diff --git a/src/drivers/i2c/w83795/w83795.c b/src/drivers/i2c/w83795/w83795.c
index 2bbe0be..0af272f 100644
--- a/src/drivers/i2c/w83795/w83795.c
+++ b/src/drivers/i2c/w83795/w83795.c
@@ -2,6 +2,7 @@
  * This file is part of the coreboot project.
  *
  * Copyright (C) 2012 Advanced Micro Devices, Inc.
+ * Copyright (C) 2015 Raptor Engineering
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -21,106 +22,68 @@
 #include <arch/cpu.h>
 #include <console/console.h>
 #include <device/device.h>
-#include "southbridge/amd/cimx/sb700/smbus.h" /*SMBUS_IO_BASE*/
 #include "w83795.h"
+#include <device/smbus.h>
+#include "chip.h"
 
-static int w83795_set_bank(u8 bank)
+static int w83795_set_bank(struct device *dev, uint8_t bank)
 {
-	return do_smbus_write_byte(SMBUS_IO_BASE, W83795_DEV, W83795_REG_BANKSEL, bank);
+	return smbus_write_byte(dev, W83795_REG_BANKSEL, bank);
 }
 
-static u8 w83795_read(u16 reg)
+static uint8_t w83795_read(struct device *dev, uint16_t reg)
 {
 	int ret;
 
-	ret = w83795_set_bank(reg >> 8);
+	ret = w83795_set_bank(dev, reg >> 8);
 	if (ret < 0) {
-		printk(BIOS_DEBUG, "read faild to set bank %x\n", reg >> 8);
+		printk(BIOS_DEBUG, "read failed to set bank %x\n", reg >> 8);
 		return -1;
 	}
 
-	ret = do_smbus_read_byte(SMBUS_IO_BASE, W83795_DEV, reg & 0xff);
+	ret = smbus_read_byte(dev, reg & 0xff);
 	return ret;
 }
 
-static u8 w83795_write(u16 reg, u8 value)
+static uint8_t w83795_write(struct device *dev, uint16_t reg, uint8_t value)
 {
 	int err;
 
-	err = w83795_set_bank(reg >> 8);
+	err = w83795_set_bank(dev, reg >> 8);
 	if (err < 0) {
-		printk(BIOS_DEBUG, "write faild to set bank %x\n", reg >> 8);
+		printk(BIOS_DEBUG, "write failed to set bank %x\n", reg >> 8);
 		return -1;
 	}
 
-	err = do_smbus_write_byte(SMBUS_IO_BASE, W83795_DEV, reg & 0xff, value);
+	err = smbus_write_byte(dev, reg & 0xff, value);
 	return err;
 }
 
 /*
- * Enable Digital Temperature Sensor
+ * Configure Digital Temperature Sensor
  */
-static void w83795_dts_enable(u8 dts_src)
+static void w83795_dts_configure(struct device *dev, uint8_t dts_src)
 {
 	u8 val;
 
 	/* DIS */
-	val = w83795_read(W83795_REG_DTSC);
+	val = w83795_read(dev, W83795_REG_DTSC);
 	val |= (dts_src & 0x01);
-	w83795_write(W83795_REG_DTSC, val);
-
-	/* DTSE */
-	val = w83795_read(W83795_REG_DTSE);
-	val |= 0xFF;
-	w83795_write(W83795_REG_DTSE, val);
-
-	/* store bank3 regs first before enable DTS */
-
-	/*
-	 * TD/TR1-4 thermal diode by default
-	 *  0x00 Disable
-	 *  0x01 thermistors on motherboard
-	 *  0x10 different mode voltage
-	 *  0x11 CPU internal thermal diode output
-	 *
-	 * TR5-6 thermistors by default  TRn
-	 */
-	val = 0x55; /* thermal diode */
-	w83795_write(W83795_REG_TEMP_CTRL2, val);
-
-	/* Enable Digital Temperature Sensor */
-	val = w83795_read(W83795_REG_TEMP_CTRL1);
-	val |= W83795_REG_TEMP_CTRL1_EN_DTS; /* EN_DTS */
-	w83795_write(W83795_REG_TEMP_CTRL1, val);
+	w83795_write(dev, W83795_REG_DTSC, val);
 }
 
-static void w83795_set_tfmr(w83795_fan_mode_t mode)
-{
-	u8 val;
-	u8 i;
-
-	if ((mode == SMART_FAN_MODE) || (mode == THERMAL_CRUISE_MODE)) {
-		val = 0xFF;
-	} else {
-		val = 0x00;
-	}
-
-	for (i = 0; i < 6; i++)
-		w83795_write(W83795_REG_TFMR(i), val);
-}
-
-static u32 w83795_set_fan_mode(w83795_fan_mode_t mode)
+static u32 w83795_set_fan_mode(struct device *dev, w83795_fan_mode_t mode)
 {
 	if (mode == SPEED_CRUISE_MODE) {
-		w83795_write(W83795_REG_FCMS1, 0xFF);
+		w83795_write(dev, W83795_REG_FCMS1, 0xFF);
 		printk(BIOS_INFO, "W83795G/ADG work in Speed Cruise Mode\n");
 	}  else {
-		w83795_write(W83795_REG_FCMS1, 0x00);
+		w83795_write(dev, W83795_REG_FCMS1, 0x00);
 		if (mode == THERMAL_CRUISE_MODE) {
-			w83795_write(W83795_REG_FCMS2, 0x00);
+			w83795_write(dev, W83795_REG_FCMS2, 0x00);
 			printk(BIOS_INFO, "W83795G/ADG work in Thermal Cruise Mode\n");
 		} else if (mode == SMART_FAN_MODE) {
-			w83795_write(W83795_REG_FCMS2, 0x3F);
+			w83795_write(dev, W83795_REG_FCMS2, 0x3F);
 			printk(BIOS_INFO, "W83795G/ADG work in Smart Fan Mode\n");
 		} else {
 			printk(BIOS_INFO, "W83795G/ADG work in Manual Mode\n");
@@ -131,40 +94,12 @@ static u32 w83795_set_fan_mode(w83795_fan_mode_t mode)
 	return 0;
 }
 
-static void w83795_set_tss(void)
+static void w83795_set_fan(struct device *dev, w83795_fan_mode_t mode)
 {
-	u8 val;
-
-	val = 0x00;
-	w83795_write(W83795_REG_TSS(0), val); /* Temp1, 2 */
-	w83795_write(W83795_REG_TSS(1), val); /* Temp3, 4 */
-	w83795_write(W83795_REG_TSS(2), val); /* Temp5, 6 */
-}
-
-static void w83795_set_fan(w83795_fan_mode_t mode)
-{
-	u8 i;
-
-	/* select temperature sensor (TSS)*/
-	w83795_set_tss();
-
-	/* select Temperature to Fan mapping Relationships (TFMR)*/
-	w83795_set_tfmr(mode);
-
 	/* set fan output controlled mode (FCMS)*/
-	w83795_set_fan_mode(mode);
+	w83795_set_fan_mode(dev, mode);
 
-	/* Set Critical Temperature to Full Speed all fan (CTFS) */
-	for (i = 0; i < 6; i++) {
-		w83795_write(W83795_REG_CTFS(i), 0x50); /* default 80 celsius degree */
-	}
-
-	if (mode == THERMAL_CRUISE_MODE) {
-		/* Set Target Temperature of Temperature Inputs (TTTI) */
-		for (i = 0; i < 6; i++) {
-			w83795_write(W83795_REG_TTTI(i), 0x28); /* default 40 celsius degree */
-		}
-	} else if (mode == SMART_FAN_MODE) {
+	if (mode == SMART_FAN_MODE) {
 		/* Set the Relative Register-at SMART FAN IV Control Mode Table */
 		//SFIV TODO
 	}
@@ -173,16 +108,44 @@ static void w83795_set_fan(w83795_fan_mode_t mode)
 	//TODO
 }
 
-static void w83795_init(w83795_fan_mode_t mode, u8 dts_src)
+static uint8_t fan_pct_to_cfg_val(uint8_t percent)
 {
-	u8 i;
-	u8 val;
+	uint16_t cfg = (((unsigned int)percent * 10000) / 3922);
+	if (cfg > 0xff)
+		cfg = 0xff;
+	return cfg;
+}
+
+static uint8_t millivolts_to_limit_value_type1(int millivolts)
+{
+	/* Datasheet v1.41 page 44 (VSEN1 - VSEN13, VTT) */
+	return ((millivolts / 2) >> 2);
+}
+
+static uint8_t millivolts_to_limit_value_type2(int millivolts)
+{
+	/* Datasheet v1.41 page 44 (3VSB, 3VDD, VBAT) */
+	return ((millivolts / 6) >> 2);
+}
+
+static uint16_t millivolts_to_limit_value_type3(int millivolts)
+{
+	/* Datasheet v1.41 page 44 (VDSEN14 - VDSEN17) */
+	return (millivolts / 2);
+}
+
+static void w83795_init(struct device *dev, w83795_fan_mode_t mode, u8 dts_src)
+{
+	struct drivers_i2c_w83795_config *config = dev->chip_info;
+	uint8_t i;
+	uint8_t val;
+	uint16_t limit_value;
 
-	if (do_smbus_read_byte(SMBUS_IO_BASE, W83795_DEV, 0x00) < 0) {
+	if (smbus_read_byte(dev, 0x00) < 0) {
 		printk(BIOS_ERR, "W83795G/ADG Nuvoton H/W Monitor not found\n");
 		return;
 	}
-	val = w83795_read(W83795_REG_CONFIG);
+	val = w83795_read(dev, W83795_REG_CONFIG);
 	if ((val & W83795_REG_CONFIG_CONFIG48) == 0)
 		printk(BIOS_INFO, "Found 64 pin W83795G Nuvoton H/W Monitor\n");
 	else if ((val & W83795_REG_CONFIG_CONFIG48) == 1)
@@ -190,35 +153,185 @@ static void w83795_init(w83795_fan_mode_t mode, u8 dts_src)
 
 	/* Reset */
 	val |= W83795_REG_CONFIG_INIT;
-	w83795_write(W83795_REG_CONFIG, val);
-
-	/* Fan monitoring setting */
-	val = 0xFF; /* FAN1-FAN8 */
-	w83795_write(W83795_REG_FANIN_CTRL1, val);
-	val = 0x3F; /* FAN9-FAN14 */
-	w83795_write(W83795_REG_FANIN_CTRL2, val);
+	w83795_write(dev, W83795_REG_CONFIG, val);
+
+	/* Fan monitor settings */
+	w83795_write(dev, W83795_REG_FANIN_CTRL1, config->fanin_ctl1);
+	w83795_write(dev, W83795_REG_FANIN_CTRL2, config->fanin_ctl2);
+
+	/* Temperature thresholds */
+	w83795_write(dev, W83795_REG_TEMP_CRIT(0), config->tr1_critical_temperature);
+	w83795_write(dev, W83795_REG_TEMP_CRIT_HYSTER(0), config->tr1_critical_hysteresis);
+	w83795_write(dev, W83795_REG_TEMP_WARN(0), config->tr1_warning_temperature);
+	w83795_write(dev, W83795_REG_TEMP_WARN_HYSTER(0), config->tr1_warning_hysteresis);
+	w83795_write(dev, W83795_REG_TEMP_CRIT(1), config->tr2_critical_temperature);
+	w83795_write(dev, W83795_REG_TEMP_CRIT_HYSTER(1), config->tr2_critical_hysteresis);
+	w83795_write(dev, W83795_REG_TEMP_WARN(1), config->tr2_warning_temperature);
+	w83795_write(dev, W83795_REG_TEMP_WARN_HYSTER(1), config->tr2_warning_hysteresis);
+	w83795_write(dev, W83795_REG_TEMP_CRIT(2), config->tr3_critical_temperature);
+	w83795_write(dev, W83795_REG_TEMP_CRIT_HYSTER(2), config->tr3_critical_hysteresis);
+	w83795_write(dev, W83795_REG_TEMP_WARN(2), config->tr3_warning_temperature);
+	w83795_write(dev, W83795_REG_TEMP_WARN_HYSTER(2), config->tr3_warning_hysteresis);
+	w83795_write(dev, W83795_REG_TEMP_CRIT(3), config->tr4_critical_temperature);
+	w83795_write(dev, W83795_REG_TEMP_CRIT_HYSTER(3), config->tr4_critical_hysteresis);
+	w83795_write(dev, W83795_REG_TEMP_WARN(3), config->tr4_warning_temperature);
+	w83795_write(dev, W83795_REG_TEMP_WARN_HYSTER(3), config->tr4_warning_hysteresis);
+	w83795_write(dev, W83795_REG_TEMP_CRIT(4), config->tr5_critical_temperature);
+	w83795_write(dev, W83795_REG_TEMP_CRIT_HYSTER(4), config->tr5_critical_hysteresis);
+	w83795_write(dev, W83795_REG_TEMP_WARN(4), config->tr5_warning_temperature);
+	w83795_write(dev, W83795_REG_TEMP_WARN_HYSTER(4), config->tr5_warning_hysteresis);
+	w83795_write(dev, W83795_REG_TEMP_CRIT(5), config->tr6_critical_temperature);
+	w83795_write(dev, W83795_REG_TEMP_CRIT_HYSTER(5), config->tr6_critical_hysteresis);
+	w83795_write(dev, W83795_REG_TEMP_WARN(5), config->tr6_warning_temperature);
+	w83795_write(dev, W83795_REG_TEMP_WARN_HYSTER(5), config->tr6_warning_hysteresis);
+
+	/* DTS enable */
+	w83795_write(dev, W83795_REG_DTSE, config->temp_dtse);
+
+	/* DTS temperature thresholds */
+	w83795_write(dev, W83795_REG_DTS_CRIT, config->dts_critical_temperature);
+	w83795_write(dev, W83795_REG_DTS_CRIT_HYSTER, config->dts_critical_hysteresis);
+	w83795_write(dev, W83795_REG_DTS_WARN, config->dts_warning_temperature);
+	w83795_write(dev, W83795_REG_DTS_WARN_HYSTER, config->dts_warning_hysteresis);
+
+	/* Configure DTS registers in bank3 before enabling DTS */
+	w83795_dts_configure(dev, dts_src);
+
+	/* Temperature monitor settings */
+	w83795_write(dev, W83795_REG_TEMP_CTRL1, config->temp_ctl1);
+	w83795_write(dev, W83795_REG_TEMP_CTRL2, config->temp_ctl2);
+
+	/* Temperature to fan mappings */
+	w83795_write(dev, W83795_REG_TFMR(0), config->temp1_fan_select);
+	w83795_write(dev, W83795_REG_TFMR(1), config->temp2_fan_select);
+	w83795_write(dev, W83795_REG_TFMR(2), config->temp3_fan_select);
+	w83795_write(dev, W83795_REG_TFMR(3), config->temp4_fan_select);
+	w83795_write(dev, W83795_REG_TFMR(4), config->temp5_fan_select);
+	w83795_write(dev, W83795_REG_TFMR(5), config->temp6_fan_select);
+
+	/* Temperature data source to temperature mappings */
+	w83795_write(dev, W83795_REG_T12TSS, ((config->temp2_source_select & 0xff) << 8) | (config->temp1_source_select & 0xff));
+	w83795_write(dev, W83795_REG_T34TSS, ((config->temp4_source_select & 0xff) << 8) | (config->temp3_source_select & 0xff));
+	w83795_write(dev, W83795_REG_T56TSS, ((config->temp6_source_select & 0xff) << 8) | (config->temp5_source_select & 0xff));
+
+	/* Set critical temperatures
+	 * If any sensor exceeds the associated critical temperature,
+	 * all fans will be forced to full speed.
+	 */
+	w83795_write(dev, W83795_REG_CTFS(0), config->temp1_critical_temperature);
+	w83795_write(dev, W83795_REG_CTFS(1), config->temp2_critical_temperature);
+	w83795_write(dev, W83795_REG_CTFS(2), config->temp3_critical_temperature);
+	w83795_write(dev, W83795_REG_CTFS(3), config->temp4_critical_temperature);
+	w83795_write(dev, W83795_REG_CTFS(4), config->temp5_critical_temperature);
+	w83795_write(dev, W83795_REG_CTFS(5), config->temp6_critical_temperature);
+
+	/* Set fan control target temperatures */
+	w83795_write(dev, W83795_REG_TTTI(0), config->temp1_target_temperature);
+	w83795_write(dev, W83795_REG_TTTI(1), config->temp2_target_temperature);
+	w83795_write(dev, W83795_REG_TTTI(2), config->temp3_target_temperature);
+	w83795_write(dev, W83795_REG_TTTI(3), config->temp4_target_temperature);
+	w83795_write(dev, W83795_REG_TTTI(4), config->temp5_target_temperature);
+	w83795_write(dev, W83795_REG_TTTI(5), config->temp6_target_temperature);
+
+	/* Set fan stall prevention parameters */
+	w83795_write(dev, W83795_REG_FAN_NONSTOP(0), config->fan1_nonstop);
+	w83795_write(dev, W83795_REG_FAN_NONSTOP(1), config->fan2_nonstop);
+	w83795_write(dev, W83795_REG_FAN_NONSTOP(2), config->fan3_nonstop);
+	w83795_write(dev, W83795_REG_FAN_NONSTOP(3), config->fan4_nonstop);
+	w83795_write(dev, W83795_REG_FAN_NONSTOP(4), config->fan5_nonstop);
+	w83795_write(dev, W83795_REG_FAN_NONSTOP(5), config->fan6_nonstop);
+	w83795_write(dev, W83795_REG_FAN_NONSTOP(6), config->fan7_nonstop);
+	w83795_write(dev, W83795_REG_FAN_NONSTOP(7), config->fan8_nonstop);
+
+	/* Set fan default speed */
+	w83795_write(dev, W83795_REG_DFSP, fan_pct_to_cfg_val(config->default_speed));
+
+	/* Set initial fan speeds */
+	w83795_write(dev, W83795_REG_FAN_MANUAL_SPEED(0), fan_pct_to_cfg_val(config->fan1_duty));
+	w83795_write(dev, W83795_REG_FAN_MANUAL_SPEED(1), fan_pct_to_cfg_val(config->fan2_duty));
+	w83795_write(dev, W83795_REG_FAN_MANUAL_SPEED(2), fan_pct_to_cfg_val(config->fan3_duty));
+	w83795_write(dev, W83795_REG_FAN_MANUAL_SPEED(3), fan_pct_to_cfg_val(config->fan4_duty));
+	w83795_write(dev, W83795_REG_FAN_MANUAL_SPEED(4), fan_pct_to_cfg_val(config->fan5_duty));
+	w83795_write(dev, W83795_REG_FAN_MANUAL_SPEED(5), fan_pct_to_cfg_val(config->fan6_duty));
+	w83795_write(dev, W83795_REG_FAN_MANUAL_SPEED(6), fan_pct_to_cfg_val(config->fan7_duty));
+	w83795_write(dev, W83795_REG_FAN_MANUAL_SPEED(7), fan_pct_to_cfg_val(config->fan8_duty));
+
+	/* Voltage monitor settings */
+	w83795_write(dev, W83795_REG_VOLT_CTRL1, config->volt_ctl1);
+	w83795_write(dev, W83795_REG_VOLT_CTRL2, config->volt_ctl2);
+
+	/* Voltage high/low limits */
+	w83795_write(dev, W83795_REG_VOLT_LIM_HIGH(0), millivolts_to_limit_value_type1(config->vcore1_high_limit_mv));
+	w83795_write(dev, W83795_REG_VOLT_LIM_LOW(0), millivolts_to_limit_value_type1(config->vcore1_low_limit_mv));
+	w83795_write(dev, W83795_REG_VOLT_LIM_HIGH(1), millivolts_to_limit_value_type1(config->vcore2_high_limit_mv));
+	w83795_write(dev, W83795_REG_VOLT_LIM_LOW(1), millivolts_to_limit_value_type1(config->vcore2_low_limit_mv));
+	w83795_write(dev, W83795_REG_VOLT_LIM_HIGH(2), millivolts_to_limit_value_type1(config->vsen3_high_limit_mv));
+	w83795_write(dev, W83795_REG_VOLT_LIM_LOW(2), millivolts_to_limit_value_type1(config->vsen3_low_limit_mv));
+	w83795_write(dev, W83795_REG_VOLT_LIM_HIGH(3), millivolts_to_limit_value_type1(config->vsen4_high_limit_mv));
+	w83795_write(dev, W83795_REG_VOLT_LIM_LOW(3), millivolts_to_limit_value_type1(config->vsen4_low_limit_mv));
+	w83795_write(dev, W83795_REG_VOLT_LIM_HIGH(4), millivolts_to_limit_value_type1(config->vsen5_high_limit_mv));
+	w83795_write(dev, W83795_REG_VOLT_LIM_LOW(4), millivolts_to_limit_value_type1(config->vsen5_low_limit_mv));
+	w83795_write(dev, W83795_REG_VOLT_LIM_HIGH(5), millivolts_to_limit_value_type1(config->vsen6_high_limit_mv));
+	w83795_write(dev, W83795_REG_VOLT_LIM_LOW(5), millivolts_to_limit_value_type1(config->vsen6_low_limit_mv));
+	w83795_write(dev, W83795_REG_VOLT_LIM_HIGH(6), millivolts_to_limit_value_type1(config->vsen7_high_limit_mv));
+	w83795_write(dev, W83795_REG_VOLT_LIM_LOW(6), millivolts_to_limit_value_type1(config->vsen7_low_limit_mv));
+	w83795_write(dev, W83795_REG_VOLT_LIM_HIGH(7), millivolts_to_limit_value_type1(config->vsen8_high_limit_mv));
+	w83795_write(dev, W83795_REG_VOLT_LIM_LOW(7), millivolts_to_limit_value_type1(config->vsen8_low_limit_mv));
+	w83795_write(dev, W83795_REG_VOLT_LIM_HIGH(8), millivolts_to_limit_value_type1(config->vsen9_high_limit_mv));
+	w83795_write(dev, W83795_REG_VOLT_LIM_LOW(8), millivolts_to_limit_value_type1(config->vsen9_low_limit_mv));
+	w83795_write(dev, W83795_REG_VOLT_LIM_HIGH(9), millivolts_to_limit_value_type1(config->vsen10_high_limit_mv));
+	w83795_write(dev, W83795_REG_VOLT_LIM_LOW(9), millivolts_to_limit_value_type1(config->vsen10_low_limit_mv));
+	w83795_write(dev, W83795_REG_VOLT_LIM_HIGH(10), millivolts_to_limit_value_type1(config->vsen11_high_limit_mv));
+	w83795_write(dev, W83795_REG_VOLT_LIM_LOW(10), millivolts_to_limit_value_type1(config->vsen11_low_limit_mv));
+	w83795_write(dev, W83795_REG_VOLT_LIM_HIGH(11), millivolts_to_limit_value_type1(config->vtt_high_limit_mv));
+	w83795_write(dev, W83795_REG_VOLT_LIM_LOW(11), millivolts_to_limit_value_type1(config->vtt_low_limit_mv));
+	w83795_write(dev, W83795_REG_VOLT_LIM_HIGH(12), millivolts_to_limit_value_type2(config->vdd_high_limit_mv));
+	w83795_write(dev, W83795_REG_VOLT_LIM_LOW(12), millivolts_to_limit_value_type2(config->vdd_low_limit_mv));
+	w83795_write(dev, W83795_REG_VOLT_LIM_HIGH(13), millivolts_to_limit_value_type2(config->vsb_high_limit_mv));
+	w83795_write(dev, W83795_REG_VOLT_LIM_LOW(13), millivolts_to_limit_value_type2(config->vsb_low_limit_mv));
+	w83795_write(dev, W83795_REG_VOLT_LIM_HIGH(14), millivolts_to_limit_value_type2(config->vbat_high_limit_mv));
+	w83795_write(dev, W83795_REG_VOLT_LIM_LOW(14), millivolts_to_limit_value_type2(config->vbat_low_limit_mv));
+
+	/* VSEN12 limits */
+	if (config->temp_ctl1 & 0x2) {
+		limit_value = millivolts_to_limit_value_type3(config->vsen12_high_limit_mv);
+		w83795_write(dev, W83795_REG_VOLT_LIM_HIGH_2_M(4), limit_value >> 2);
+		w83795_write(dev, W83795_REG_VOLT_LIM_HIGH_2_L(4), limit_value & 0x3);
+		limit_value = millivolts_to_limit_value_type3(config->vsen12_low_limit_mv);
+		w83795_write(dev, W83795_REG_VOLT_LIM_LOW_2_M(4), limit_value >> 2);
+		w83795_write(dev, W83795_REG_VOLT_LIM_LOW_2_L(4), limit_value & 0x3);
+	}
 
-	/* enable monitoring operations */
-	val = w83795_read(W83795_REG_CONFIG);
-	val |= W83795_REG_CONFIG_START;
-	w83795_write(W83795_REG_CONFIG, val);
+	/* VSEN13 limits */
+	if (config->temp_ctl1 & 0x8) {
+		limit_value = millivolts_to_limit_value_type3(config->vsen13_high_limit_mv);
+		w83795_write(dev, W83795_REG_VOLT_LIM_HIGH_2_M(5), limit_value >> 2);
+		w83795_write(dev, W83795_REG_VOLT_LIM_HIGH_2_L(5), limit_value & 0x3);
+		limit_value = millivolts_to_limit_value_type3(config->vsen13_low_limit_mv);
+		w83795_write(dev, W83795_REG_VOLT_LIM_LOW_2_M(5), limit_value >> 2);
+		w83795_write(dev, W83795_REG_VOLT_LIM_LOW_2_L(5), limit_value & 0x3);
+	}
 
-	w83795_dts_enable(dts_src);
-	w83795_set_fan(mode);
+	w83795_set_fan(dev, mode);
 
 	printk(BIOS_INFO, "Fan   CTFS(celsius)  TTTI(celsius)\n");
 	for (i = 0; i < 6; i++) {
-		val = w83795_read(W83795_REG_CTFS(i));
+		val = w83795_read(dev, W83795_REG_CTFS(i));
 		printk(BIOS_INFO, " %x     %d", i, val);
-		val = w83795_read(W83795_REG_TTTI(i));
+		val = w83795_read(dev, W83795_REG_TTTI(i));
 		printk(BIOS_INFO, "             %d\n", val);
 	}
 
 	/* Temperature ReadOut */
 	for (i = 0; i < 9; i++) {
-		val = w83795_read(W83795_REG_DTS(i));
+		val = w83795_read(dev, W83795_REG_DTS(i));
 		printk(BIOS_DEBUG, "DTS%x ReadOut=%x\n", i, val);
 	}
+
+	/* start monitoring operation */
+	val = w83795_read(dev, W83795_REG_CONFIG);
+	val |= W83795_REG_CONFIG_START;
+	w83795_write(dev, W83795_REG_CONFIG, val);
 }
 
 static void w83795_hwm_init(struct device *dev)
@@ -232,9 +345,9 @@ static void w83795_hwm_init(struct device *dev)
 		die("CPU: missing cpu device structure");
 
 	if (cpu->vendor == X86_VENDOR_AMD)
-		w83795_init(THERMAL_CRUISE_MODE, DTS_SRC_AMD_SBTSI);
+		w83795_init(dev, THERMAL_CRUISE_MODE, DTS_SRC_AMD_SBTSI);
 	else if (cpu->vendor == X86_VENDOR_INTEL)
-		w83795_init(THERMAL_CRUISE_MODE, DTS_SRC_INTEL_PECI);
+		w83795_init(dev, THERMAL_CRUISE_MODE, DTS_SRC_INTEL_PECI);
 	else
 		printk(BIOS_ERR, "Neither AMD nor INTEL CPU detected\n");
 }
diff --git a/src/drivers/i2c/w83795/w83795.h b/src/drivers/i2c/w83795/w83795.h
index cac4d5f..ef603f5 100644
--- a/src/drivers/i2c/w83795/w83795.h
+++ b/src/drivers/i2c/w83795/w83795.h
@@ -2,6 +2,7 @@
  * This file is part of the coreboot project.
  *
  * Copyright (C) 2012 Advanced Micro Devices, Inc.
+ * Copyright (C) 2015 Raptor Engineering
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -20,8 +21,6 @@
 #ifndef _W83795_H_
 #define _W83795_H_
 
-#define W83795_DEV			0x2F /* Host I2c Addr (strap to addr1 addr0 1 1, 0x5E) */
-
 #define W83795_REG_I2C_ADDR		0xFC
 #define W83795_REG_BANKSEL		0x00
 #define W83795_REG_CONFIG		0x01
@@ -29,6 +28,8 @@
 #define W83795_REG_CONFIG_CONFIG48	0x04
 #define W83795_REG_CONFIG_INIT		0x80
 
+#define W83795_REG_VOLT_CTRL1		0x02
+#define W83795_REG_VOLT_CTRL2		0x03
 #define W83795_REG_TEMP_CTRL1		0x04 /* Temperature Monitoring Control Register */
 #define W83795_REG_TEMP_CTRL2		0x05 /* Temperature Monitoring Control Register */
 #define W83795_REG_FANIN_CTRL1		0x06
@@ -37,37 +38,58 @@
 #define DTS_SRC_INTEL_PECI		(0 << 0)
 #define DTS_SRC_AMD_SBTSI		(1 << 0)
 
-#define W83795_REG_TSS(n)		(0x209 + (n)) /* Temperature Source Selection Register */
 #define W83795_REG_TTTI(n)		(0x260 + (n)) /* Target temperature W83795G/ADG will try to tune the fan output to keep */
 #define W83795_REG_CTFS(n)		(0x268 + (n)) /* Critical Temperature to Full Speed all fan */
-#define W83795_REG_HT(n)		(0x270 + (n)) /* Hysteresis of Temperature */
 #define W83795_REG_DTSC			0x301 /* Digital Temperature Sensor Configuration */
 
 #define W83795_REG_DTSE			0x302 /* Digital Temperature Sensor Enable */
 #define W83795_REG_DTS(n)		(0x26 + (n))
 #define W83795_REG_VRLSB		0x3C
 
-#define W83795_TEMP_REG_TR1		0x21
-#define W83795_TEMP_REG_TR2		0x22
-#define W83795_TEMP_REG_TR3		0x23
-#define W83795_TEMP_REG_TR4		0x24
-#define W83795_TEMP_REG_TR5		0x1F
-#define W83795_TEMP_REG_TR6		0x20
+#define W83795_REG_TEMP_TR1		0x21
+#define W83795_REG_TEMP_TR2		0x22
+#define W83795_REG_TEMP_TR3		0x23
+#define W83795_REG_TEMP_TR4		0x24
+#define W83795_REG_TEMP_TR5		0x1F
+#define W83795_REG_TEMP_TR6		0x20
+
+#define W83795_REG_VOLT_LIM_HIGH(n)	(0x70 + (n * 2))	/* Voltage high limit (0 == VSEN1) */
+#define W83795_REG_VOLT_LIM_LOW(n)	(0x71 + (n * 2))	/* Voltage low limit (0 == VSEN1) */
+#define W83795_REG_VOLT_LIM_HIGH_2_M(n)	(0x96 + (n * 4))	/* Voltage high limit MSB (0 == VDSEN14) */
+#define W83795_REG_VOLT_LIM_LOW_2_M(n)	(0x97 + (n * 4))	/* Voltage low limit MSB (0 == VDSEN14)  */
+#define W83795_REG_VOLT_LIM_HIGH_2_L(n)	(0x98 + (n * 4))	/* Voltage high limit LSB (0 == VDSEN14) */
+#define W83795_REG_VOLT_LIM_LOW_2_L(n)	(0x99 + (n * 4))	/* Voltage low limit LSB (0 == VDSEN14)  */
+
+#define W83795_REG_TEMP_CRIT(n)		(0x96 + (n * 4))	/* Temperature critical limit */
+#define W83795_REG_TEMP_CRIT_HYSTER(n)	(0x97 + (n * 4))	/* Temperature critical limit hysteresis */
+#define W83795_REG_TEMP_WARN(n)		(0x98 + (n * 4))	/* Temperature warning limit */
+#define W83795_REG_TEMP_WARN_HYSTER(n)	(0x99 + (n * 4))	/* Temperature warning limit hysteresis */
+
+#define W83795_REG_DTS_CRIT		0xB2			/* Temperature critical limit */
+#define W83795_REG_DTS_CRIT_HYSTER	0xB3			/* Temperature critical limit hysteresis */
+#define W83795_REG_DTS_WARN		0xB4			/* Temperature warning limit */
+#define W83795_REG_DTS_WARN_HYSTER	0xB5			/* Temperature warning limit hysteresis */
 
 #define W83795_REG_FCMS1		0x201
 #define W83795_REG_FCMS2		0x208
-#define W83795_REG_TFMR(n)		(0x202 + (n)) /*temperature to fam mappig*/
+#define W83795_REG_TFMR(n)		(0x202 + (n))		/* Temperature to fan mapping */
+#define W83795_REG_T12TSS		0x209			/* Temperature Source Selection Register 1 */
+#define W83795_REG_T34TSS		0x20A			/* Temperature Source Selection Register 2 */
+#define W83795_REG_T56TSS		0x20B			/* Temperature Source Selection Register 3 */
+#define W83795_REG_FAN_MANUAL_SPEED(n)	(0x210 + n)
 #define W83795_REG_DFSP			0x20C
 
+#define W83795_REG_FAN_NONSTOP(n)	(0x228 + (n))	/* Fan Nonstop Value */
+
 #define W83795_REG_FTSH(n)		(0x240 + (n) * 2)
 #define W83795_REG_FTSL(n)		(0x241 + (n) * 2)
 #define W83795_REG_TFTS			0x250
 
 typedef enum w83795_fan_mode {
-	SPEED_CRUISE_MODE,	///< Fan Speed Cruise mode keeps the fan speed in a specified range
-	THERMAL_CRUISE_MODE,	///< Thermal Cruise mode is an algorithm to control the fan speed to keep the temperature source around the TTTI
-	SMART_FAN_MODE,		///< Smart Fan mode offers 6 slopes to control the fan speed
-	MANUAL_MODE,		///< control manually
+	SPEED_CRUISE_MODE = 0,		///< Fan Speed Cruise mode keeps the fan speed in a specified range
+	THERMAL_CRUISE_MODE = 1,	///< Thermal Cruise mode is an algorithm to control the fan speed to keep the temperature source around the TTTI
+	SMART_FAN_MODE = 2,		///< Smart Fan mode offers 6 slopes to control the fan speed
+	MANUAL_MODE = 3,		///< control manually
 } w83795_fan_mode_t;
 
 #endif
-- 
1.7.9.5

