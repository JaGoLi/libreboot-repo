From 2515607768d1699c148a9eee0e40ccaeb8bb0650 Mon Sep 17 00:00:00 2001
From: Timothy Pearson <tpearson@raptorengineeringinc.com>
Date: Thu, 30 Apr 2015 01:47:31 -0500
Subject: [PATCH 013/139] mainboard/asus/kgpe-d16: Add initial support for the
 KGPE-D16

As of this commit S3 suspend does not work on any K10 boards,
including this board.

Change-Id: Idd3971422fb2473bff7c60fe8d8161d6e20808ed
Signed-off-by: Timothy Pearson <tpearson@raptorengineeringinc.com>
---
 src/mainboard/asus/kgpe-d16/Kconfig          |  95 ++++
 src/mainboard/asus/kgpe-d16/Kconfig.name     |   2 +
 src/mainboard/asus/kgpe-d16/acpi/pm_ctrl.asl | 367 ++++++++++++++
 src/mainboard/asus/kgpe-d16/acpi_tables.c    |  75 +++
 src/mainboard/asus/kgpe-d16/board_info.txt   |   5 +
 src/mainboard/asus/kgpe-d16/bootblock.c      |  52 ++
 src/mainboard/asus/kgpe-d16/cmos.default     |  16 +
 src/mainboard/asus/kgpe-d16/cmos.layout      | 134 +++++
 src/mainboard/asus/kgpe-d16/devicetree.cb    | 248 +++++++++
 src/mainboard/asus/kgpe-d16/dsdt.asl         | 730 +++++++++++++++++++++++++++
 src/mainboard/asus/kgpe-d16/get_bus_conf.c   | 128 +++++
 src/mainboard/asus/kgpe-d16/irq_tables.c     | 112 ++++
 src/mainboard/asus/kgpe-d16/mainboard.c      |  81 +++
 src/mainboard/asus/kgpe-d16/mb_sysconf.h     |  44 ++
 src/mainboard/asus/kgpe-d16/mptable.c        | 231 +++++++++
 src/mainboard/asus/kgpe-d16/resourcemap.c    | 284 +++++++++++
 src/mainboard/asus/kgpe-d16/romstage.c       | 422 ++++++++++++++++
 src/mainboard/asus/kgpe-d16/spd_notes.txt    |  30 ++
 18 files changed, 3056 insertions(+)
 create mode 100644 src/mainboard/asus/kgpe-d16/Kconfig
 create mode 100644 src/mainboard/asus/kgpe-d16/Kconfig.name
 create mode 100644 src/mainboard/asus/kgpe-d16/acpi/pm_ctrl.asl
 create mode 100644 src/mainboard/asus/kgpe-d16/acpi_tables.c
 create mode 100644 src/mainboard/asus/kgpe-d16/board_info.txt
 create mode 100644 src/mainboard/asus/kgpe-d16/bootblock.c
 create mode 100644 src/mainboard/asus/kgpe-d16/cmos.default
 create mode 100644 src/mainboard/asus/kgpe-d16/cmos.layout
 create mode 100644 src/mainboard/asus/kgpe-d16/devicetree.cb
 create mode 100644 src/mainboard/asus/kgpe-d16/dsdt.asl
 create mode 100644 src/mainboard/asus/kgpe-d16/get_bus_conf.c
 create mode 100644 src/mainboard/asus/kgpe-d16/irq_tables.c
 create mode 100644 src/mainboard/asus/kgpe-d16/mainboard.c
 create mode 100644 src/mainboard/asus/kgpe-d16/mb_sysconf.h
 create mode 100644 src/mainboard/asus/kgpe-d16/mptable.c
 create mode 100644 src/mainboard/asus/kgpe-d16/resourcemap.c
 create mode 100644 src/mainboard/asus/kgpe-d16/romstage.c
 create mode 100644 src/mainboard/asus/kgpe-d16/spd_notes.txt

diff --git a/src/mainboard/asus/kgpe-d16/Kconfig b/src/mainboard/asus/kgpe-d16/Kconfig
new file mode 100644
index 0000000..95b3b5b
--- /dev/null
+++ b/src/mainboard/asus/kgpe-d16/Kconfig
@@ -0,0 +1,95 @@
+if BOARD_ASUS_KGPE_D16
+
+config BOARD_SPECIFIC_OPTIONS # dummy
+	def_bool y
+	select CPU_AMD_SOCKET_G34_NON_AGESA
+	select DIMM_DDR3
+	select DIMM_REGISTERED
+	# select QRANK_DIMM_SUPPORT
+	select NORTHBRIDGE_AMD_AMDFAM10
+	select SOUTHBRIDGE_AMD_SR5650
+	select SOUTHBRIDGE_AMD_SB700
+	select SOUTHBRIDGE_AMD_SB700_DISABLE_ISA_DMA
+	select SUPERIO_NUVOTON_NCT5572D
+	select PARALLEL_CPU_INIT
+	select HAVE_HARD_RESET
+	select HAVE_OPTION_TABLE
+	select HAVE_CMOS_DEFAULT
+	select HAVE_PIRQ_TABLE
+	select HAVE_MP_TABLE
+	select HAVE_ACPI_TABLES
+	select SB_HT_CHAIN_UNITID_OFFSET_ONLY
+	select LIFT_BSP_APIC_ID
+	select BOARD_ROMSIZE_KB_2048
+	select ENABLE_APIC_EXT_ID
+	select MMCONF_SUPPORT_DEFAULT
+	select DRIVERS_I2C_W83795
+	select DRIVERS_ASPEED_AST2050
+	select MAINBOARD_HAS_NATIVE_VGA_INIT_TEXTMODECFG
+
+config MAINBOARD_DIR
+	string
+	default asus/kgpe-d16
+
+config BOOTBLOCK_MAINBOARD_INIT
+	string
+	default "mainboard/asus/kgpe-d16/bootblock.c"
+
+config DCACHE_RAM_BASE
+	hex
+	default 0xc2000
+
+config DCACHE_RAM_SIZE
+	hex
+	default 0x1e000
+
+config APIC_ID_OFFSET
+	hex
+	default 0
+
+config MAINBOARD_PART_NUMBER
+	string
+	default "KGPE-D16"
+
+config HW_MEM_HOLE_SIZEK
+	hex
+	default 0x100000
+
+config PCI_64BIT_PREF_MEM
+	bool
+	default n
+
+config MAX_CPUS
+	int
+	default 32
+
+# 2 (internal) processors per G34 socket
+config MAX_PHYSICAL_CPUS
+	int
+	default 4
+
+config SB_HT_CHAIN_ON_BUS0
+	int
+	default 1
+
+config HT_CHAIN_UNITID_BASE
+	hex
+	default 0x0
+
+config HT_CHAIN_END_UNITID_BASE
+	hex
+	default 0x20
+
+config IRQ_SLOT_COUNT
+	int
+	default 13
+
+config ONBOARD_VGA_IS_PRIMARY
+	bool
+	default y
+
+config MAINBOARD_POWER_ON_AFTER_POWER_FAIL
+	bool
+	default y
+
+endif # BOARD_ASUS_KGPE_D16
diff --git a/src/mainboard/asus/kgpe-d16/Kconfig.name b/src/mainboard/asus/kgpe-d16/Kconfig.name
new file mode 100644
index 0000000..bdfa31a
--- /dev/null
+++ b/src/mainboard/asus/kgpe-d16/Kconfig.name
@@ -0,0 +1,2 @@
+config BOARD_ASUS_KGPE_D16
+	bool "KGPE-D16"
diff --git a/src/mainboard/asus/kgpe-d16/acpi/pm_ctrl.asl b/src/mainboard/asus/kgpe-d16/acpi/pm_ctrl.asl
new file mode 100644
index 0000000..b3c65ca
--- /dev/null
+++ b/src/mainboard/asus/kgpe-d16/acpi/pm_ctrl.asl
@@ -0,0 +1,367 @@
+/*
+ * This file is part of the coreboot project.
+ *
+ * Copyright (C) 2015 Timothy Pearson <tpearson@raptorengineeringinc.com>, Raptor Engineering
+ * Copyright (C) 2009 Advanced Micro Devices, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/*
+ * WARNING: Sleep/Wake is a work in progress and is still somewhat flaky!
+ */
+
+	/* Port 80 POST card debug */
+	OperationRegion (DBG0, SystemIO, 0x80, One)
+		Field (DBG0, ByteAcc, NoLock, Preserve) {
+		DBG8, 8
+	}
+
+	/* SuperIO control port */
+	Name (SPIO, 0x2E)
+
+	/* SuperIO control map */
+	OperationRegion (SPIM, SystemIO, SPIO, 0x02)
+		Field (SPIM, ByteAcc, NoLock, Preserve) {
+		INDX, 8,
+		DATA, 8
+	}
+
+	/* SuperIO control registers */
+	IndexField (INDX, DATA, ByteAcc, NoLock, Preserve) {
+		Offset (0x07),
+		CR07, 8,		/* Logical device number */
+		Offset (0x2C),
+		CR2C, 8,		/* GPIO3 multiplexed pin selection */
+		Offset (0x30),
+		CR30, 8,		/* Logical device activation control register */
+		Offset (0xE0),
+		CRE0, 8,		/* Wake control register */
+		Offset (0xE6),
+		CRE6, 8,		/* Mouse wake event configuration register */
+		Offset (0xF1),
+		CRF1, 8,		/* GPIO3 data register */
+		Offset (0xF3),
+		CRF3, 8,		/* SUSLED mode register */
+		Offset (0xF6),
+		CRF6, 8,		/* SMI/PME event generation control register */
+		Offset (0xF9),
+		CRF9, 8,		/* ACPI PME configuration register */
+	}
+
+	/* Power Management I/O registers */
+	OperationRegion(PIOR, SystemIO, 0x00000CD6, 0x00000002)
+		Field(PIOR, ByteAcc, NoLock, Preserve) {
+		PIOI, 0x00000008,
+		PIOD, 0x00000008,
+	}
+	IndexField (PIOI, PIOD, ByteAcc, NoLock, Preserve) {
+		Offset(0x00),	/* MiscControl */
+		, 1,
+		T1EE, 1,
+		T2EE, 1,
+		Offset(0x01),	/* MiscStatus */
+		, 1,
+		T1E, 1,
+		T2E, 1,
+		Offset(0x04),	/* SmiWakeUpEventEnable3 */
+		, 7,
+		SSEN, 1,
+		Offset(0x07),	/* SmiWakeUpEventStatus3 */
+		, 7,
+		CSSM, 1,
+		Offset(0x10),	/* AcpiEnable */
+		, 6,
+		PWDE, 1,
+		Offset(0x1C),	/* ProgramIoEnable */
+		, 3,
+		MKME, 1,
+		IO3E, 1,
+		IO2E, 1,
+		IO1E, 1,
+		IO0E, 1,
+		Offset(0x1D),	/* IOMonitorStatus */
+		, 3,
+		MKMS, 1,
+		IO3S, 1,
+		IO2S, 1,
+		IO1S, 1,
+		IO0S,1,
+		Offset(0x20),	/* AcpiPmEvtBlk */
+		APEB, 16,
+		Offset(0x36),	/* GEvtLevelConfig */
+		, 6,
+		ELC6, 1,
+		ELC7, 1,
+		Offset(0x37),	/* GPMLevelConfig0 */
+		, 3,
+		PLC0, 1,
+		PLC1, 1,
+		PLC2, 1,
+		PLC3, 1,
+		PLC8, 1,
+		Offset(0x38),	/* GPMLevelConfig1 */
+		, 1,
+		 PLC4, 1,
+		 PLC5, 1,
+		, 1,
+		 PLC6, 1,
+		 PLC7, 1,
+		Offset(0x3B),	/* PMEStatus1 */
+		GP0S, 1,
+		GM4S, 1,
+		GM5S, 1,
+		APS, 1,
+		GM6S, 1,
+		GM7S, 1,
+		GP2S, 1,
+		STSS, 1,
+		Offset(0x55),	/* SoftPciRst */
+		SPRE, 1,
+		, 1,
+		, 1,
+		PNAT, 1,
+		PWMK, 1,
+		PWNS, 1,
+
+		/* 	Offset(0x61), */	/*  Options_1 */
+		/* 		,7,  */
+		/* 		R617,1, */
+
+		Offset(0x65),	/* UsbPMControl */
+		, 4,
+		URRE, 1,
+		Offset(0x68),	/* MiscEnable68 */
+		, 3,
+		TMTE, 1,
+		, 1,
+		Offset(0x7C),	/* MiscEnable7C */
+		, 2,
+		BLNK, 2,
+		Offset(0x92),	/* GEVENTIN */
+		, 7,
+		E7IS, 1,
+		Offset(0x96),	/* GPM98IN */
+		G8IS, 1,
+		G9IS, 1,
+		Offset(0x9A),	/* EnhanceControl */
+		,7,
+		HPDE, 1,
+		Offset(0xA8),	/* PIO7654Enable */
+		IO4E, 1,
+		IO5E, 1,
+		IO6E, 1,
+		IO7E, 1,
+		Offset(0xA9),	/* PIO7654Status */
+		IO4S, 1,
+		IO5S, 1,
+		IO6S, 1,
+		IO7S, 1,
+	}
+
+	/* PM1 Event Block
+	 * First word is PM1_Status, Second word is PM1_Enable
+	 */
+	OperationRegion(P1EB, SystemIO, APEB, 0x04)
+		Field(P1EB, ByteAcc, NoLock, Preserve) {
+		TMST, 1,
+		,    3,
+		BMST,    1,
+		GBST,   1,
+		Offset(0x01),
+		PBST, 1,
+		, 1,
+		RTST, 1,
+		, 3,
+		PWST, 1,
+		SPWS, 1,
+		Offset(0x02),
+		TMEN, 1,
+		, 4,
+		GBEN, 1,
+		Offset(0x03),
+		PBEN, 1,
+		, 1,
+		RTEN, 1,
+		, 3,
+		PWDA, 1,
+	}
+
+	/* Wake status package */
+	Name(WKST,Package(){Zero, Zero})
+
+	/*
+	 *  \_WAK System Wake method
+	 *
+	 *	Entry:
+	 *		Arg0=The value of the sleeping state S1=1, S2=2
+	 *
+	 *	Exit:
+	 *		Return package of 2 DWords
+	 *		Dword 1 - Status
+	 *			0x00000000	wake succeeded
+	 *			0x00000001	Wake was signaled but failed due to lack of power
+	 *			0x00000002	Wake was signaled but failed due to thermal condition
+	 *		Dword 2 - Power Supply state
+	 *			if non-zero the effective S-state the power supply entered
+	 */
+	Method(\_WAK, 1) {
+		Store (0x20, DBG8)
+
+		/* Set up LEDs */
+		/* Set power LED to steady on */
+		Store(0x3, BLNK)
+
+		/* Configure SuperIO for wake */
+		/* Access SuperIO ACPI device */
+		Store(0x87, INDX)
+		Store(0x87, INDX)
+		Store(0x0A, CR07)
+
+		if (LEqual(Arg0, One))	/* Resuming from power state S1 */
+		{
+			/* Deactivate the ACPI device */
+			Store(Zero, CR30)
+
+			/* Disable PS/2 SMI/PME events */
+			And(CRF6, 0xCF, CRF6)
+		}
+		if (Lor(LEqual(Arg0, 0x03), LEqual(Arg0, 0x04)))	/* Resuming from power state S3 or S4 */
+		{
+			/* Disable PS/2 wake */
+			And(CRE0, 0x1D, CRE0)
+			And(CRE6, 0x7F, CRE6)
+		}
+
+		/* Restore default SuperIO access */
+		Store(0xAA, INDX)
+
+		Store (0x21, DBG8)
+
+		/* Re-enable HPET */
+		Store(1, HPDE)
+
+		/* Restore PCIRST# so it resets USB */
+		if (LEqual(Arg0, 3)){
+			Store(1, URRE)
+		}
+
+		/* Configure southbridge for wake */
+		/* Arbitrarily clear PciExpWakeStatus */
+		Store(PWST, PWST)
+
+		Store (0x22, DBG8)
+
+		Notify(\_SB.PWRB, 0x02)			/* NOTIFY_DEVICE_WAKE */
+
+		Return(WKST)
+	}
+
+	/*
+	 * \_PTS - Prepare to Sleep method
+	 *
+	 *	Entry:
+	 *		Arg0=The value of the sleeping state S1=1, S2=2, etc
+	 *
+	 * Exit:
+	 *		-none-
+	 *
+	 * The _PTS control method is executed at the beginning of the sleep process
+	 * for S1-S5. The sleeping value is passed to the _PTS control method.	This
+	 * control method may be executed a relatively long time before entering the
+	 * sleep state and the OS may abort the operation without notification to
+	 * the ACPI driver.  This method cannot modify the configuration or power
+	 * state of any device in the system.
+	 */
+	Method(\_PTS, 1) {
+		Store (Arg0, DBG8)
+
+		/* Set up LEDs */
+		if (LEqual(Arg0, One))	/* Power state S1 requested */
+		{
+			/* Set suspend LED to 0.25Hz toggle pulse with 50% duty cycle */
+			Store(0x2, BLNK)
+		}
+		if (LEqual(Arg0, 0x3))	/* Power state S3 requested */
+		{
+			/* Set suspend LED to 0.25Hz toggle pulse with 25% duty cycle */
+			Store(0x1, BLNK)
+		}
+
+		/* Configure SuperIO for sleep */
+		/* Access SuperIO ACPI device */
+		Store(0x87, INDX)
+		Store(0x87, INDX)
+		Store(0x0A, CR07)
+
+		/* Disable PS/2 wakeup and connect PANSW_IN to PANSW_OUT */
+		And(CRE0, 0x1F, CRE0)
+
+		if (LEqual(Arg0, One))	/* Power state S1 requested */
+		{
+			/* Activate the ACPI device */
+			Store(One, CR30)
+
+			/* Disable SMI/PME events for:
+			 * LPT
+			 * FDC
+			 * UART
+			Store(0x00, CRF6)
+
+			/* Enable PS/2 keyboard SMI/PME events */
+			Or(CRF6, 0x10, CRF6)
+
+			/* Enable PS/2 keyboard wake */
+			Or(CRE0, 0x40, CRE0)
+
+			/* Enable PS/2 mouse SMI/PME events */
+			Or(CRF6, 0x20, CRF6)
+
+			/* Enable PS/2 mouse wake  */
+			Or(CRE0, 0x20, CRE0)
+		} else {
+			/* Enable PS/2 keyboard wake on any keypress */
+			Or(CRE0, 0x41, CRE0)
+
+			/* Enable PS/2 mouse wake on any click  */
+			Or(CRE0, 0x22, CRE0)
+			Or(CRE6, 0x80, CRE6)
+		}
+
+		/* Restore default SuperIO access */
+		Store(0xAA, INDX)
+
+		Store (0x10, DBG8)
+
+		/* Don't allow PCIRST# to reset USB */
+		if (LEqual(Arg0, 3)){
+			Store(0, URRE)
+		}
+
+		/* Configure southbridge for sleep */
+		/* Clear sleep SMI status flag and enable sleep SMI trap. */
+		// Store(One, CSSM)	/* Set ExtEvent0 as SMI# source */
+		// Store(One, SSEN)	/* Enable wake on external event 0 */
+
+		/* On older chips, clear PciExpWakeDisEn */
+		// if (LLessEqual(SBRI, 0x13)) {
+		//	Store(0, PWDE)
+		// }
+
+		Store (0x11, DBG8)
+
+		/* Clear wake status structure. */
+		Store(0, Index(WKST,0))
+		Store(0, Index(WKST,1))
+	}
\ No newline at end of file
diff --git a/src/mainboard/asus/kgpe-d16/acpi_tables.c b/src/mainboard/asus/kgpe-d16/acpi_tables.c
new file mode 100644
index 0000000..4e98dfe
--- /dev/null
+++ b/src/mainboard/asus/kgpe-d16/acpi_tables.c
@@ -0,0 +1,75 @@
+/*
+ * This file is part of the coreboot project.
+ *
+ * Copyright (C) 2010 Advanced Micro Devices, Inc.
+ * Copyright (C) 2015 Timothy Pearson <tpearson@raptorengineeringinc.com>, Raptor Engineering
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <console/console.h>
+#include <string.h>
+#include <arch/acpi.h>
+#include <arch/ioapic.h>
+#include <device/pci.h>
+#include <device/pci_ids.h>
+#include <cpu/x86/msr.h>
+#include <cpu/amd/mtrr.h>
+#include <cpu/amd/amdfam10_sysconf.h>
+
+#include "mb_sysconf.h"
+
+unsigned long acpi_fill_madt(unsigned long current)
+{
+	device_t dev;
+	u32 dword;
+	u32 gsi_base=0;
+	uint32_t apicid_sp5100;
+	uint32_t apicid_sr5650;
+	/* create all subtables for processors */
+	current = acpi_create_madt_lapics(current);
+
+	apicid_sp5100 = 0x20;
+	apicid_sr5650 = apicid_sp5100 + 1;
+
+	/* Write SB700 IOAPIC, only one */
+	current += acpi_create_madt_ioapic((acpi_madt_ioapic_t *) current, apicid_sp5100,
+					   IO_APIC_ADDR, gsi_base);
+	/* IOAPIC on rs5690 */
+	gsi_base += 24;		/* SB700 has 24 IOAPIC entries. */
+	dev = dev_find_slot(0, PCI_DEVFN(0, 0));
+	if (dev) {
+		pci_write_config32(dev, 0xF8, 0x1);
+		dword = pci_read_config32(dev, 0xFC) & 0xfffffff0;
+		current += acpi_create_madt_ioapic((acpi_madt_ioapic_t *) current, apicid_sr5650,
+						   dword, gsi_base);
+	}
+
+	/* bus, source, gsirq, flags */
+	current += acpi_create_madt_irqoverride((acpi_madt_irqoverride_t *)
+						current, 0, 0, 2, 0);
+	current += acpi_create_madt_irqoverride((acpi_madt_irqoverride_t *)
+						current, 0, 9, 9, 0xF);
+	/* 0: mean bus 0--->ISA */
+	/* 0: PIC 0 */
+	/* 2: APIC 2 */
+	/* 5 mean: 0101 --> Edge-triggered, Active high */
+
+	/* create all subtables for processors */
+	current += acpi_create_madt_lapic_nmi((acpi_madt_lapic_nmi_t *)current, 0, 5, 1);
+	current += acpi_create_madt_lapic_nmi((acpi_madt_lapic_nmi_t *)current, 1, 5, 1);
+	/* 1: LINT1 connect to NMI */
+
+	return current;
+}
diff --git a/src/mainboard/asus/kgpe-d16/board_info.txt b/src/mainboard/asus/kgpe-d16/board_info.txt
new file mode 100644
index 0000000..788888e
--- /dev/null
+++ b/src/mainboard/asus/kgpe-d16/board_info.txt
@@ -0,0 +1,5 @@
+Category: server
+ROM package: PLCC-32
+ROM protocol: LPC
+ROM socketed: y
+Flashrom support: y
\ No newline at end of file
diff --git a/src/mainboard/asus/kgpe-d16/bootblock.c b/src/mainboard/asus/kgpe-d16/bootblock.c
new file mode 100644
index 0000000..2e9d70f
--- /dev/null
+++ b/src/mainboard/asus/kgpe-d16/bootblock.c
@@ -0,0 +1,52 @@
+/*
+ * This file is part of the coreboot project.
+ *
+ * Copyright (C) 2015 Timothy Pearson <tpearson@raptorengineeringinc.com>, Raptor Engineering
+ * Copyright (C) 2014 Edward O'Callaghan <eocallaghan@alterapraxis.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <pc80/mc146818rtc.h>
+
+void bootblock_mainboard_init(void)
+{
+	uint8_t recovery_enabled;
+	unsigned char addr;
+	unsigned char byte;
+
+	bootblock_northbridge_init();
+	bootblock_southbridge_init();
+
+	/* Recovery jumper is connected to SP5100 GPIO61, and clears the GPIO when placed in the Recovery position */
+	recovery_enabled = (!(pci_read_config8(PCI_DEV(0, 0x14, 0), 0x57) & 0x1));
+	if (recovery_enabled) {
+#if CONFIG_USE_OPTION_TABLE
+		/* Clear NVRAM checksum */
+		for (addr = LB_CKS_RANGE_START; addr <= LB_CKS_RANGE_END; addr++) {
+			cmos_write(0x0, addr);
+		}
+
+		/* Set fallback boot */
+		byte = cmos_read(RTC_BOOT_BYTE);
+		byte &= 0xfc;
+		cmos_write(byte, RTC_BOOT_BYTE);
+#else
+		/* FIXME
+		 * Figure out how to recover if the option table is not available
+		 */
+#endif
+	}
+}
\ No newline at end of file
diff --git a/src/mainboard/asus/kgpe-d16/cmos.default b/src/mainboard/asus/kgpe-d16/cmos.default
new file mode 100644
index 0000000..cffdd03
--- /dev/null
+++ b/src/mainboard/asus/kgpe-d16/cmos.default
@@ -0,0 +1,16 @@
+baud_rate = 115200
+debug_level = Spew
+multi_core = Enable
+slow_cpu = off
+iommu = Disable
+nmi = Disable
+hypertransport_speed_limit = Auto
+max_mem_clock = DDR3-1600
+ECC_memory = Enable
+ECC_redirection = Disable
+ecc_scrub_rate = 1.28us
+interleave_chip_selects = Enable
+interleave_nodes = Disable
+interleave_memory_channels = Enable
+power_on_after_fail = On
+boot_option = Fallback
diff --git a/src/mainboard/asus/kgpe-d16/cmos.layout b/src/mainboard/asus/kgpe-d16/cmos.layout
new file mode 100644
index 0000000..bcf9cd3
--- /dev/null
+++ b/src/mainboard/asus/kgpe-d16/cmos.layout
@@ -0,0 +1,134 @@
+##
+## This file is part of the coreboot project.
+##
+## Copyright (C) 2015 Timothy Pearson <tpearson@raptorengineeringinc.com>, Raptor Engineering
+## Copyright (C) 2007 AMD
+## Written by Yinghai Lu <yinghailu@amd.com> for AMD.
+##
+## This program is free software; you can redistribute it and/or modify
+## it under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 2 of the License, or
+## (at your option) any later version.
+##
+## This program is distributed in the hope that it will be useful,
+## but WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+## GNU General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with this program; if not, write to the Free Software
+## Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+##
+
+entries
+
+0          384       r       0        reserved_memory
+384          1       e       4        boot_option
+385          1       e       4        last_boot
+388          4       r       0        reboot_bits
+393          3       e       5        baud_rate
+396          5       e       10       ecc_scrub_rate
+401          1       e       1        interleave_chip_selects
+402          1       e       1        interleave_nodes
+403          1       e       1        interleave_memory_channels
+404          2       e       8        max_mem_clock
+406          1       e       2        multi_core
+412          4       e       6        debug_level
+440          4       e       9        slow_cpu
+444          1       e       1        nmi
+445          1       e       1        iommu
+446          2       e       3        power_on_after_fail
+456          1       e       1        ECC_memory
+457          1       e       1        ECC_redirection
+458          4       e       11       hypertransport_speed_limit
+728        256       h       0        user_data
+984         16       h       0        check_sum
+# Reserve the extended AMD configuration registers
+1000        24       r       0        amd_reserved
+
+
+
+enumerations
+
+#ID value   text
+1     0     Disable
+1     1     Enable
+2     0     Enable
+2     1     Disable
+3     0     Off
+3     1     On
+3     2     Last
+4     0     Fallback
+4     1     Normal
+5     0     115200
+5     1     57600
+5     2     38400
+5     3     19200
+5     4     9600
+5     5     4800
+5     6     2400
+5     7     1200
+6     0     Emergency
+6     1     Alert
+6     2     Critical
+6     3     Error
+6     4     Warning
+6     5     Notice
+6     6     Information
+6     7     Debug
+6     8     Spew
+8     0     DDR3-1600
+8     1     DDR3-1333
+8     2     DDR3-1066
+8     3     DDR3-800
+9     0     off
+9     1     87.5%
+9     2     75.0%
+9     3     62.5%
+9     4     50.0%
+9     5     37.5%
+9     6     25.0%
+9     7     12.5%
+10    0     Disabled
+10    1     40ns
+10    2     80ns
+10    3     160ns
+10    4     320ns
+10    5     640ns
+10    6     1.28us
+10    7     2.56us
+10    8     5.12us
+10    9     10.2us
+10    10    20.5us
+10    11    41us
+10    12    81.9us
+10    13    163.8us
+10    14    327.7us
+10    15    655.4us
+10    16    1.31ms
+10    17    2.62ms
+10    18    5.24ms
+10    19    10.49ms
+10    20    20.97ms
+10    21    42ms
+10    22    84ms
+11    0     Auto
+11    1     2.6GHz
+11    2     2.4GHz
+11    3     2.2GHz
+11    4     2.0GHz
+11    5     1.8GHz
+11    6     1.6GHz
+11    7     1.4GHz
+11    8     1.2GHz
+11    9     1.0GHz
+11    10    800MHz
+11    11    600MHz
+11    12    500MHz
+11    13    400MHz
+11    14    300MHz
+11    15    200MHz
+
+checksums
+
+checksum 392 983 984
diff --git a/src/mainboard/asus/kgpe-d16/devicetree.cb b/src/mainboard/asus/kgpe-d16/devicetree.cb
new file mode 100644
index 0000000..a172d89
--- /dev/null
+++ b/src/mainboard/asus/kgpe-d16/devicetree.cb
@@ -0,0 +1,248 @@
+chip northbridge/amd/amdfam10/root_complex	# Root complex
+	device cpu_cluster 0 on			# (L)APIC cluster
+		chip cpu/amd/socket_F_1207			# CPU socket
+			device lapic 0 on end			# Local APIC of the CPU
+		end
+	end
+	device domain 0 on			# PCI domain
+		subsystemid 0x1043 0x8163 inherit
+		chip northbridge/amd/amdfam10		# Northbridge / RAM controller
+			register "maximum_memory_capacity" = "0x4000000000"	# 256GB
+			device pci 18.0 on end		# Link 0 == LDT 0
+			device pci 18.0 on end		# Link 1 == LDT 1
+			device pci 18.0 on end		# Link 2 == LDT 2
+			device pci 18.0 on		# Link 3 == LDT 3 [SB on link 3]
+				chip southbridge/amd/sr5650		# Primary southbridge
+					device pci 0.0 on end			# HT Root Complex 0x9600
+					device pci 0.1 on end			# CLKCONFIG
+					device pci 2.0 on			# PCIE P2P bridge 0x9603 (GPP1 Port0)
+						# Slot				# PCI E 1 / PCI E 2
+					end
+					device pci 3.0 off end			# PCIE P2P bridge 0x960b (GPP1 Port1)
+					device pci 4.0 on			# PCIE P2P bridge 0x9604 (GPP3a Port0)
+						# PIKE SAS
+					end
+					device pci 5.0 off end			# PCIE P2P bridge 0x9605 (GPP3a Port1)
+					device pci 6.0 off end			# PCIE P2P bridge 0x9606 (GPP3a Port2)
+					device pci 7.0 off end			# PCIE P2P bridge 0x9607 (GPP3a Port3)
+					device pci 8.0 off end			# NB/SB Link P2P bridge
+					device pci 9.0 on			# Bridge (GPP3a Port4)
+						# Onboard			# NIC A
+					end
+					device pci a.0 on			# Bridge (GPP3a Port5)
+						# Onboard			# NIC B
+					end
+					device pci b.0 on			# Bridge (GPP2 Port0)
+						# Slot				# PCI E 4
+					end
+					device pci c.0 on			# Bridge (GPP2 Port1)
+						# Slot				# PCI E 5
+					end
+					device pci d.0 on			# Bridge (GPP3b Port0)
+						# Slot				# PCI E 3
+					end
+					register "gpp1_configuration" = "0"	# Configuration 16:0 default
+					register "gpp2_configuration" = "1"	# Configuration 8:8
+					#register "gpp3a_configuration" = "2"	# Configuration 4:1:1:0:0:0
+					register "gpp3a_configuration" = "11"	# Configuration 1:1:1:1:1:1
+					register "port_enable" = "0x3ffc"	# Enable all ports except 0 and 1
+				end
+				chip southbridge/amd/sb700		# Secondary southbridge
+					device pci 11.0 on end			# SATA
+					device pci 12.0 on end			# USB
+					device pci 12.1 on end			# USB
+					device pci 12.2 on end			# USB
+					device pci 13.0 on end			# USB
+					device pci 13.1 on end			# USB
+					device pci 13.2 on end			# USB
+	 				device pci 14.0 on end			# SM
+					device pci 14.1 on end			# IDE 0x439c
+					device pci 14.2 off end			# HDA 0x4383 (KGPE-D16 omits audio option)
+					device pci 14.3 on			# LPC 0x439d (SMBUS primary controller)
+						chip superio/nuvoton/nct5572d	# Super I/O
+							device pnp 2e.0 off end	# FDC; Not available on the KGPE-D16
+							device pnp 2e.1 off end	# LPT1; Not available on the KGPE-D16
+							device pnp 2e.2 on #  Com1
+								io 0x60 = 0x3f8
+								irq 0x70 = 4
+							end
+							device pnp 2e.3 off	# IR: Not available on the KGPE-D16
+								io 0x60 = 0x2f8
+								irq 0x70 = 3
+							end
+							device pnp 2e.5 on	# PS/2 keyboard & mouse
+								io 0x60 = 0x60
+								io 0x62 = 0x64
+								irq 0x70 = 1
+								irq 0x72 = 12
+							end
+							device pnp 2e.6 off	# CIR: Not available on the KGPE-D16
+								io 0x60 = 0x100
+								irq 0x70 = 0
+							end
+							device pnp 2e.7 off end	# GIPO689
+							device pnp 2e.8 off end	# WDT
+							device pnp 2e.9 off end	# GPIO235
+							device pnp 2e.a on end	# ACPI
+							device pnp 2e.b on	# HW Monitor
+								io 0x60 = 0x290
+								io 0x62 = 0x0000 #  SB-TSI currently not implemented
+								irq 0x70 = 5
+							end
+							device pnp 2e.c off end	# PECI
+							device pnp 2e.d off end	# SUSLED
+							device pnp 2e.e off	# CIRWKUP
+								io 0x60 = 0x0000
+								irq 0x70 = 0
+							end
+							device pnp 2e.f off end	# GPIO_PP_OD
+						end
+						chip drivers/generic/generic	# DIMM n-0-0-0
+							device i2c 50 on end
+						end
+						chip drivers/generic/generic	# DIMM n-0-0-1
+							device i2c 51 on end
+						end
+						chip drivers/generic/generic	# DIMM n-0-1-0
+							device i2c 52 on end
+						end
+						chip drivers/generic/generic	# DIMM n-0-1-1
+							device i2c 53 on end
+						end
+						chip drivers/generic/generic	# DIMM n-1-0-0
+							device i2c 54 on end
+						end
+						chip drivers/generic/generic	# DIMM n-1-0-1
+							device i2c 55 on end
+						end
+						chip drivers/generic/generic	# DIMM n-1-1-0
+							device i2c 56 on end
+						end
+						chip drivers/generic/generic	# DIMM n-1-1-1
+							device i2c 57 on end
+						end
+						chip drivers/i2c/w83795
+							register "fanin_ctl1" = "0xff"			# Enable monitoring of FANIN1 - FANIN8
+							register "fanin_ctl2" = "0x00"			# Connect FANIN11 - FANIN14 to alternate functions
+							register "temp_ctl1" = "0x2a"			# Enable monitoring of DTS, VSEN12, and VSEN13
+							register "temp_ctl2" = "0x01"			# Enable monitoring of TD1/TR1
+							register "temp_dtse" = "0x03"			# Enable DTS1 and DTS2
+							register "volt_ctl1" = "0xff"			# Enable monitoring of VSEN1 - VSEN8
+							register "volt_ctl2" = "0xf7"			# Enable monitoring of VSEN9 - VSEN11, 3VDD, 3VSB, and VBAT
+							register "temp1_fan_select" = "0x00"		# All fans to manual mode (no dependence on Temp1)
+							register "temp2_fan_select" = "0x00"		# All fans to manual mode (no dependence on Temp2)
+							register "temp3_fan_select" = "0x00"		# All fans to manual mode (no dependence on Temp3)
+							register "temp4_fan_select" = "0x00"		# All fans to manual mode (no dependence on Temp4)
+							register "temp5_fan_select" = "0x00"		# All fans to manual mode (no dependence on Temp5)
+							register "temp6_fan_select" = "0x00"		# All fans to manual mode (no dependence on Temp6)
+							register "temp1_source_select" = "0x00"		# Use TD1/TR1 as data source for Temp1
+							register "temp2_source_select" = "0x00"		# Use TD2/TR2 as data source for Temp2
+							register "temp3_source_select" = "0x00"		# Use TD3/TR3 as data source for Temp3
+							register "temp4_source_select" = "0x00"		# Use TD4/TR4 as data source for Temp4
+							register "temp5_source_select" = "0x00"		# Use TR5 as data source for Temp5
+							register "temp6_source_select" = "0x00"		# Use TR6 as data source for Temp6
+							register "tr1_critical_temperature" = "85"	# Set TD1/TR1 critical temperature to 85°C
+							register "tr1_critical_hysteresis" = "80"	# Set TD1/TR1 critical hysteresis temperature to 80°C
+							register "tr1_warning_temperature" = "70"	# Set TD1/TR1 warning temperature to 70°C
+							register "tr1_warning_hysteresis" = "65"	# Set TD1/TR1 warning hysteresis temperature to 65°C
+							register "dts_critical_temperature" = "85"	# Set DTS (CPU) critical temperature to 85°C
+							register "dts_critical_hysteresis" = "80"	# Set DTS (CPU) critical hysteresis temperature to 80°C
+							register "dts_warning_temperature" = "70"	# Set DTS (CPU) warning temperature to 70°C
+							register "dts_warning_hysteresis" = "65"	# Set DTS (CPU) warning hysteresis temperature to 65°C
+							register "temp1_critical_temperature" = "80"	# Set Temp1 critical temperature to 80°C
+							register "temp2_critical_temperature" = "80"	# Set Temp1 critical temperature to 80°C
+							register "temp3_critical_temperature" = "80"	# Set Temp1 critical temperature to 80°C
+							register "temp4_critical_temperature" = "80"	# Set Temp1 critical temperature to 80°C
+							register "temp5_critical_temperature" = "80"	# Set Temp1 critical temperature to 80°C
+							register "temp6_critical_temperature" = "80"	# Set Temp1 critical temperature to 80°C
+							register "temp1_target_temperature" = "80"	# Set Temp1 target temperature to 80°C
+							register "temp2_target_temperature" = "80"	# Set Temp1 target temperature to 80°C
+							register "temp3_target_temperature" = "80"	# Set Temp1 target temperature to 80°C
+							register "temp4_target_temperature" = "80"	# Set Temp1 target temperature to 80°C
+							register "temp5_target_temperature" = "80"	# Set Temp1 target temperature to 80°C
+							register "temp6_target_temperature" = "80"	# Set Temp1 target temperature to 80°C
+							register "fan1_nonstop" = "7"			# Set Fan 1 minimum speed
+							register "fan2_nonstop" = "7"			# Set Fan 2 minimum speed
+							register "fan3_nonstop" = "7"			# Set Fan 3 minimum speed
+							register "fan4_nonstop" = "7"			# Set Fan 4 minimum speed
+							register "fan5_nonstop" = "7"			# Set Fan 5 minimum speed
+							register "fan6_nonstop" = "7"			# Set Fan 6 minimum speed
+							register "fan7_nonstop" = "7"			# Set Fan 7 minimum speed
+							register "fan8_nonstop" = "7"			# Set Fan 8 minimum speed
+							register "default_speed" = "100"		# All fans to full speed on power up
+							register "fan1_duty" = "100"			# Fan 1 to full speed
+							register "fan2_duty" = "100"			# Fan 2 to full speed
+							register "fan3_duty" = "100"			# Fan 3 to full speed
+							register "fan4_duty" = "100"			# Fan 4 to full speed
+							register "fan5_duty" = "100"			# Fan 5 to full speed
+							register "fan6_duty" = "100"			# Fan 6 to full speed
+							register "fan7_duty" = "100"			# Fan 7 to full speed
+							register "fan8_duty" = "100"			# Fan 8 to full speed
+							register "vcore1_high_limit_mv" = "1500"	# VCORE1 (Node 0) high limit to 1.5V
+							register "vcore1_low_limit_mv" = "900"		# VCORE1 (Node 0) low limit to 0.9V
+							register "vcore2_high_limit_mv" = "1500"	# VCORE2 (Node 1) high limit to 1.5V
+							register "vcore2_low_limit_mv" = "900"		# VCORE2 (Node 1) low limit to 0.9V
+							register "vsen3_high_limit_mv" = "1600"		# VSEN1 (Node 0 RAM voltage) high limit to 1.6V
+							register "vsen3_low_limit_mv" = "1100"		# VSEN1 (Node 0 RAM voltage) low limit to 1.1V
+							register "vsen4_high_limit_mv" = "1600"		# VSEN2 (Node 1 RAM voltage) high limit to 1.6V
+							register "vsen4_low_limit_mv" = "1100"		# VSEN2 (Node 1 RAM voltage) low limit to 1.1V
+							register "vsen5_high_limit_mv" = "1250"		# VSEN5 (Node 0 HT link voltage) high limit to 1.25V
+							register "vsen5_low_limit_mv" = "1150"		# VSEN5 (Node 0 HT link voltage) low limit to 1.15V
+							register "vsen6_high_limit_mv" = "1250"		# VSEN6 (Node 1 HT link voltage) high limit to 1.25V
+							register "vsen6_low_limit_mv" = "1150"		# VSEN6 (Node 1 HT link voltage) low limit to 1.15V
+							register "vsen7_high_limit_mv" = "1150"		# VSEN7 (Northbridge core voltage) high limit to 1.15V
+							register "vsen7_low_limit_mv" = "1050"		# VSEN7 (Northbridge core voltage) low limit to 1.05V
+							register "vsen8_high_limit_mv" = "1900"		# VSEN8 (+1.8V) high limit to 1.9V
+							register "vsen8_low_limit_mv" = "1700"		# VSEN8 (+1.8V) low limit to 1.7V
+							register "vsen9_high_limit_mv" = "1250"		# VSEN9 (+1.2V) high limit to 1.25V
+							register "vsen9_low_limit_mv" = "1150"		# VSEN9 (+1.2V) low limit to 1.15V
+							register "vsen10_high_limit_mv" = "1150"	# VSEN10 (+1.1V) high limit to 1.15V
+							register "vsen10_low_limit_mv" = "1050"		# VSEN10 (+1.1V) low limit to 1.05V
+							register "vsen11_high_limit_mv" = "1625"	# VSEN11 (5VSB, scaling factor ~3.2) high limit to 5.2V
+							register "vsen11_low_limit_mv" = "1500"		# VSEN11 (5VSB, scaling factor ~3.2) low limit to 4.8V
+							register "vsen12_high_limit_mv" = "1083"	# VSEN12 (+12V, scaling factor ~12) high limit to 13V
+							register "vsen12_low_limit_mv" = "917"		# VSEN12 (+12V, scaling factor ~12) low limit to 11V
+							register "vsen13_high_limit_mv" = "1625"	# VSEN13 (+5V, scaling factor ~3.2) high limit to 5.2V
+							register "vsen13_low_limit_mv" = "1500"		# VSEN13 (+5V, scaling factor ~3.2) low limit to 4.8V
+							register "vdd_high_limit_mv" = "3500"		# 3VDD high limit to 3.5V
+							register "vdd_low_limit_mv" = "3100"		# 3VDD low limit to 3.1V
+							register "vsb_high_limit_mv" = "3500"		# 3VSB high limit to 3.5V
+							register "vsb_low_limit_mv" = "3100"		# 3VSB low limit to 3.1V
+							register "vbat_high_limit_mv" = "3500"		# VBAT (+3V) high limit to 3.5V
+							register "vbat_low_limit_mv" = "2500"		# VBAT (+3V) low limit to 2.5V
+							register "smbus_aux" = "1"			# Device located on auxiliary SMBUS controller
+							device i2c 0x2f on end
+						end
+					end
+					device pci 14.4 on			# Bridge
+						device pci 1.0 on end		# VGA
+						device pci 2.0 on end		# FireWire
+						device pci 3.0 on		# Slot
+							# Slot			# PCI 0
+						end
+					end
+					device pci 14.5 on end			# USB OHCI2 0x4399
+				end
+			end
+			device pci 18.1 on end
+			device pci 18.2 on end
+			device pci 18.3 on end
+			device pci 18.4 on end
+			device pci 19.0 on end		# Socket 0 node 1
+			device pci 19.1 on end
+			device pci 19.2 on end
+			device pci 19.3 on end
+			device pci 19.4 on end
+			device pci 1a.0 on end		# Socket 1 node 0
+			device pci 1a.1 on end
+			device pci 1a.2 on end
+			device pci 1a.3 on end
+			device pci 1a.4 on end
+			device pci 1b.0 on end		# Socket 1 node 1
+			device pci 1b.1 on end
+			device pci 1b.2 on end
+			device pci 1b.3 on end
+			device pci 1b.4 on end
+		end
+	end
+end
diff --git a/src/mainboard/asus/kgpe-d16/dsdt.asl b/src/mainboard/asus/kgpe-d16/dsdt.asl
new file mode 100644
index 0000000..bdd1d2d
--- /dev/null
+++ b/src/mainboard/asus/kgpe-d16/dsdt.asl
@@ -0,0 +1,730 @@
+/*
+ * This file is part of the coreboot project.
+ *
+ * Copyright (C) 2015 Timothy Pearson <tpearson@raptorengineeringinc.com>, Raptor Engineering
+ * Copyright (C) 2005 - 2012 Advanced Micro Devices, Inc.
+ * Copyright (C) 2007-2009 coresystems GmbH
+ * Copyright (C) 2004 Nick Barker <Nick.Barker9@btinternet.com>
+ * Copyright (C) 2007, 2008 Rudolf Marek <r.marek@assembler.cz>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/*
+ * WARNING: Sleep/Wake is a work in progress and is still somewhat flaky!
+ * Everything else does to the best of my knowledge... (T.P. 01/26/2015)
+ */
+
+/*
+ * ISA portions taken from QEMU acpi-dsdt.dsl.
+ */
+
+/*
+ * PCI link routing templates taken from ck804.asl and modified for this board
+ */
+
+DefinitionBlock (
+        "DSDT.AML",	/* Output filename */
+        "DSDT",		/* Signature */
+        0x02,		/* DSDT Revision, needs to be 2 for 64bit */
+        "ASUS  ",	/* OEMID */
+        "COREBOOT",	/* TABLE ID */
+        0x00000001	/* OEM Revision */
+        )
+{
+	#include "northbridge/amd/amdfam10/amdfam10_util.asl"
+	#include "southbridge/amd/sr5650/acpi/sr5650.asl"
+
+	/* Some global data */
+	Name(OSVR, 3)	/* Assume nothing. WinXp = 1, Vista = 2, Linux = 3, WinCE = 4 */
+	Name(OSV, Ones)	/* Assume nothing */
+	Name(PICM, One)	/* Assume APIC */
+
+	/* HPET control */
+	Name (SHPB, 0xFED00000)
+	Name (SHPL, 0x1000)
+
+	/* Define power states */
+	Name (\_S0, Package () { 0x00, 0x00, 0x00, 0x00 })	/* Normal operation */
+	Name (\_S1, Package () { 0x01, 0x01, 0x00, 0x00 })	/* Standby */
+	Name (\_S2, Package () { 0x02, 0x02, 0x00, 0x00 })	/* Standby w/ CPU shutdown */
+	Name (\_S3, Package () { 0x03, 0x00, 0x00, 0x00 })	/* Suspend */
+	/* Name (\_S4, Package () { 0x04, 0x04, 0x00, 0x00 }) */
+	Name (\_S5, Package () { 0x05, 0x05, 0x00, 0x00 })	/* Hard power off */
+
+	/* The _PIC method is called by the OS to choose between interrupt
+		* routing via the i8259 interrupt controller or the APIC.
+		*
+		* _PIC is called with a parameter of 0 for i8259 configuration and
+		* with a parameter of 1 for Local Apic/IOAPIC configuration.
+		*/
+	Method (_PIC, 1, Serialized) {
+		If (Arg0)
+		{
+			\_SB.CIRQ()
+		}
+		Store (Arg0, PICM)
+	}
+
+	/* _PR CPU0 is dynamically supplied by SSDT */
+	/* CPU objects and _PSS entries are dynamically supplied by SSDT */
+
+	Scope(\_GPE) {	/* Start Scope GPE */
+		/*  General event 3  */
+		Method(_L03) {
+			/* Level-Triggered GPE */
+			Notify(\_SB.PWRB, 0x02)			/* NOTIFY_DEVICE_WAKE */
+		}
+
+		/*  General event 4  */
+		Method(_L04) {
+			/* Level-Triggered GPE */
+			Notify (\_SB.PCI0.PBR0, 0x02)		/* NOTIFY_DEVICE_WAKE */
+			Notify (\_SB.PWRB, 0x02)		/* NOTIFY_DEVICE_WAKE */
+		}
+
+		/*  Keyboard controller PME#  */
+		Method(_L08) {
+			/* Level-Triggered GPE */
+			Notify(\_SB.PCI0.LPC.KBD, 0x02)		/* NOTIFY_DEVICE_WAKE */
+			Notify(\_SB.PCI0.LPC.MOU, 0x02)		/* NOTIFY_DEVICE_WAKE */
+			Notify(\_SB.PWRB, 0x02)			/* NOTIFY_DEVICE_WAKE */
+		}
+
+		/*  USB controller PME#  */
+		Method(_L0B) {
+			/* Level-Triggered GPE */
+			Notify (\_SB.PCI0.USB0, 0x02)		/* NOTIFY_DEVICE_WAKE */
+			Notify (\_SB.PCI0.USB1, 0x02)		/* NOTIFY_DEVICE_WAKE */
+			Notify (\_SB.PCI0.USB2, 0x02)		/* NOTIFY_DEVICE_WAKE */
+			Notify (\_SB.PCI0.USB3, 0x02)		/* NOTIFY_DEVICE_WAKE */
+			Notify (\_SB.PCI0.USB4, 0x02)		/* NOTIFY_DEVICE_WAKE */
+			Notify (\_SB.PCI0.USB5, 0x02)		/* NOTIFY_DEVICE_WAKE */
+			Notify (\_SB.PCI0.USB6, 0x02)		/* NOTIFY_DEVICE_WAKE */
+			Notify (\_SB.PWRB, 0x02)		/* NOTIFY_DEVICE_WAKE */
+		}
+
+		/*  GPIO0 or GEvent8 event  */
+		Method(_L18) {
+			/* Level-Triggered GPE */
+			Notify (\_SB.PCI0.PCE1, 0x02)		/* NOTIFY_DEVICE_WAKE */
+			Notify (\_SB.PCI0.NICA, 0x02)		/* NOTIFY_DEVICE_WAKE */
+			Notify (\_SB.PCI0.NICB, 0x02)		/* NOTIFY_DEVICE_WAKE */
+			Notify (\_SB.PCI0.PCE4, 0x02)		/* NOTIFY_DEVICE_WAKE */
+			Notify (\_SB.PCI0.PCE5, 0x02)		/* NOTIFY_DEVICE_WAKE */
+			Notify (\_SB.PCI0.PCE3, 0x02)		/* NOTIFY_DEVICE_WAKE */
+		}
+
+	} 	/* End Scope GPE */
+
+	/* Root of the bus hierarchy */
+	Scope (\_SB)
+	{
+		/* Top southbridge PCI device (SR5690) */
+		Device (PCI0)
+		{
+			/* BUS0 root bus */
+
+			Name (_HID, EisaId ("PNP0A03"))
+			Name (_ADR, 0x00180001)
+			Name (_UID, 0x00)
+
+			Name (HCIN, 0x00)  // HC1
+
+			Method (_BBN, 0, NotSerialized)
+			{
+				Return (GBUS (GHCN(HCIN), GHCL(HCIN)))
+			}
+
+			/* Operating System Capabilities Method */
+			Method(_OSC,4)
+			{
+				/* Let OS control everything */
+				Return (Arg3)
+			}
+
+			External (BUSN)
+			External (MMIO)
+			External (PCIO)
+			External (SBLK)
+			External (TOM1)
+			External (HCLK)
+			External (SBDN)
+			External (HCDN)
+			External (CBST)
+
+			/* PCI Routing Tables */
+			Name (PR00, Package () {
+				/* PIC */
+				/* Top southbridge device (SR5690) */
+				/* HT Link */
+				Package (0x04) { 0x0000FFFF, 0x00, LNKA, 0x00 },
+
+				/* PCI-E Slot 1 (Bridge) */
+				Package (0x04) { 0x0002FFFF, 0x00, LNKE, 0x00 },
+
+				/* NIC A (Bridge) */
+				Package (0x04) { 0x0009FFFF, 0x00, LNKF, 0x00 },
+
+				/* NIC B (Bridge) */
+				Package (0x04) { 0x000AFFFF, 0x00, LNKG, 0x00 },
+
+				/* PCI-E Slot 4 (Bridge) */
+				Package (0x04) { 0x000BFFFF, 0x00, LNKG, 0x00 },
+
+				/* PCI-E Slot 5 (Bridge) */
+				Package (0x04) { 0x000CFFFF, 0x00, LNKG, 0x00 },
+
+				/* PCI-E Slot 3 (Bridge) */
+				Package (0x04) { 0x000DFFFF, 0x00, LNKG, 0x00 },
+
+				/* Bottom southbridge device (SP5100) */
+				/* SATA 0 */
+				Package (0x04) { 0x0011FFFF, 0x00, LNKG, 0x00 },
+
+				/* USB 0 */
+				Package (0x04) { 0x0012FFFF, 0x00, LNKA, 0x00 },
+				Package (0x04) { 0x0012FFFF, 0x01, LNKB, 0x00 },
+				Package (0x04) { 0x0012FFFF, 0x02, LNKC, 0x00 },
+				Package (0x04) { 0x0012FFFF, 0x03, LNKD, 0x00 },
+
+				/* USB 1 */
+				Package (0x04) { 0x0013FFFF, 0x00, LNKC, 0x00 },
+				Package (0x04) { 0x0013FFFF, 0x01, LNKD, 0x00 },
+				Package (0x04) { 0x0013FFFF, 0x02, LNKA, 0x00 },
+				Package (0x04) { 0x0013FFFF, 0x03, LNKB, 0x00 },
+
+				/* SMBUS / IDE / LPC / VGA / FireWire / PCI Slot 0 */
+				Package (0x04) { 0x0014FFFF, 0x00, LNKA, 0x00 },
+				Package (0x04) { 0x0014FFFF, 0x01, LNKB, 0x00 },
+				Package (0x04) { 0x0014FFFF, 0x02, LNKC, 0x00 },
+				Package (0x04) { 0x0014FFFF, 0x03, LNKD, 0x00 },
+			})
+
+			Name (AR00, Package () {
+				/* APIC */
+				/* Top southbridge device (SR5690) */
+				/* HT Link */
+				Package (0x04) { 0x0000FFFF, 0x00, 0x00, 55 },
+
+				/* PCI-E Slot 1 (Bridge) */
+				Package (0x04) { 0x0002FFFF, 0x00, 0x00, 52 },
+
+				/* NIC A (Bridge) */
+				Package (0x04) { 0x0009FFFF, 0x00, 0x00, 53 },
+
+				/* NIC B (Bridge) */
+				Package (0x04) { 0x000AFFFF, 0x00, 0x00, 54 },
+
+				/* PCI-E Slot 4 (Bridge) */
+				Package (0x04) { 0x000BFFFF, 0x00, 0x00, 54 },
+
+				/* PCI-E Slot 5 (Bridge) */
+				Package (0x04) { 0x000CFFFF, 0x00, 0x00, 54 },
+
+				/* PCI-E Slot 3 (Bridge) */
+				Package (0x04) { 0x000DFFFF, 0x00, 0x00, 54 },
+
+				/* Bottom southbridge device (SP5100) */
+				/* SATA 0 */
+				Package (0x04) { 0x0011FFFF, 0x00, 0x00, 22 },
+
+				/* USB 0 */
+				Package (0x04) { 0x0012FFFF, 0x00, 0x00, 16 },
+				Package (0x04) { 0x0012FFFF, 0x01, 0x00, 17 },
+				Package (0x04) { 0x0012FFFF, 0x02, 0x00, 18 },
+				Package (0x04) { 0x0012FFFF, 0x03, 0x00, 19 },
+
+				/* USB 1 */
+				Package (0x04) { 0x0013FFFF, 0x00, 0x00, 18 },
+				Package (0x04) { 0x0013FFFF, 0x01, 0x00, 19 },
+				Package (0x04) { 0x0013FFFF, 0x02, 0x00, 16 },
+				Package (0x04) { 0x0013FFFF, 0x03, 0x00, 17 },
+
+				/* SMBUS / IDE / LPC / VGA / FireWire / PCI Slot 0 */
+				Package (0x04) { 0x0014FFFF, 0x00, 0x00, 16 },
+				Package (0x04) { 0x0014FFFF, 0x01, 0x00, 17 },
+				Package (0x04) { 0x0014FFFF, 0x02, 0x00, 18 },
+				Package (0x04) { 0x0014FFFF, 0x03, 0x00, 19 },
+			})
+
+			Name (PR01, Package () {
+				/* PIC */
+				Package (0x04) { 0x1FFFF, 0x00, LNKF, 0x00 },
+				Package (0x04) { 0x2FFFF, 0x00, LNKE, 0x00 },
+				Package (0x04) { 0x3FFFF, 0x00, LNKG, 0x00 },
+				Package (0x04) { 0x3FFFF, 0x01, LNKH, 0x00 },
+				Package (0x04) { 0x3FFFF, 0x02, LNKE, 0x00 },
+				Package (0x04) { 0x3FFFF, 0x03, LNKF, 0x00 },
+			})
+
+			Name (AR01, Package () {
+				/* APIC */
+				Package (0x04) { 0x1FFFF, 0x00, 0x00, 21 },
+				Package (0x04) { 0x2FFFF, 0x00, 0x00, 20 },
+				Package (0x04) { 0x3FFFF, 0x00, 0x00, 22 },
+				Package (0x04) { 0x3FFFF, 0x01, 0x00, 23 },
+				Package (0x04) { 0x3FFFF, 0x02, 0x00, 20 },
+				Package (0x04) { 0x3FFFF, 0x03, 0x00, 21 },
+			})
+
+			Name (PR02, Package () {
+				/* PIC */
+				Package (0x04) { 0xFFFF, 0x00, LNKA, 0x00 },
+				Package (0x04) { 0xFFFF, 0x01, LNKB, 0x00 },
+				Package (0x04) { 0xFFFF, 0x02, LNKC, 0x00 },
+				Package (0x04) { 0xFFFF, 0x03, LNKD, 0x00 },
+			})
+
+			Name (AR02, Package () {
+				/* APIC */
+				Package (0x04) { 0xFFFF, 0x00, 0x00, 24 },
+				Package (0x04) { 0xFFFF, 0x01, 0x00, 25 },
+				Package (0x04) { 0xFFFF, 0x02, 0x00, 26 },
+				Package (0x04) { 0xFFFF, 0x03, 0x00, 27 },
+			})
+
+			Name (PR03, Package () {
+				/* PIC */
+				Package (0x04) { 0xFFFF, 0x00, LNKA, 0x00 },
+				Package (0x04) { 0xFFFF, 0x01, LNKB, 0x00 },
+				Package (0x04) { 0xFFFF, 0x02, LNKC, 0x00 },
+				Package (0x04) { 0xFFFF, 0x03, LNKD, 0x00 },
+			})
+
+			Name (AR03, Package () {
+				/* APIC */
+				Package (0x04) { 0xFFFF, 0x00, 0x00, 48 },
+				Package (0x04) { 0xFFFF, 0x01, 0x00, 49 },
+				Package (0x04) { 0xFFFF, 0x02, 0x00, 50 },
+				Package (0x04) { 0xFFFF, 0x03, 0x00, 51 },
+			})
+
+			Name (PR04, Package () {
+				/* PIC */
+				Package (0x04) { 0xFFFF, 0x00, LNKH, 0x00 },
+				Package (0x04) { 0xFFFF, 0x01, LNKE, 0x00 },
+				Package (0x04) { 0xFFFF, 0x02, LNKF, 0x00 },
+				Package (0x04) { 0xFFFF, 0x03, LNKG, 0x00 },
+			})
+
+			Name (AR04, Package () {
+				/* APIC */
+				Package (0x04) { 0xFFFF, 0x00, 0x00, 47 },
+				Package (0x04) { 0xFFFF, 0x01, 0x00, 44 },
+				Package (0x04) { 0xFFFF, 0x02, 0x00, 45 },
+				Package (0x04) { 0xFFFF, 0x03, 0x00, 46 },
+			})
+
+			Name (PR05, Package () {
+				/* PIC */
+				Package (0x04) { 0xFFFF, 0x00, LNKA, 0x00 },
+				Package (0x04) { 0xFFFF, 0x01, LNKB, 0x00 },
+				Package (0x04) { 0xFFFF, 0x02, LNKC, 0x00 },
+				Package (0x04) { 0xFFFF, 0x03, LNKD, 0x00 },
+			})
+
+			Name (AR05, Package () {
+				/* APIC */
+				Package (0x04) { 0xFFFF, 0x00, 0x00, 32 },
+				Package (0x04) { 0xFFFF, 0x01, 0x00, 33 },
+				Package (0x04) { 0xFFFF, 0x02, 0x00, 34 },
+				Package (0x04) { 0xFFFF, 0x03, 0x00, 35 },
+			})
+
+			Name (PR06, Package () {
+				/* PIC */
+				Package (0x04) { 0xFFFF, 0x00, LNKE, 0x00 },
+				Package (0x04) { 0xFFFF, 0x01, LNKF, 0x00 },
+				Package (0x04) { 0xFFFF, 0x02, LNKG, 0x00 },
+				Package (0x04) { 0xFFFF, 0x03, LNKH, 0x00 },
+			})
+
+			Name (AR06, Package () {
+				/* APIC */
+				Package (0x04) { 0xFFFF, 0x00, 0x00, 36 },
+				Package (0x04) { 0xFFFF, 0x01, 0x00, 37 },
+				Package (0x04) { 0xFFFF, 0x02, 0x00, 38 },
+				Package (0x04) { 0xFFFF, 0x03, 0x00, 39 },
+			})
+
+			Name (PR07, Package () {
+				/* PIC */
+				Package (0x04) { 0xFFFF, 0x00, LNKA, 0x00 },
+				Package (0x04) { 0xFFFF, 0x01, LNKB, 0x00 },
+				Package (0x04) { 0xFFFF, 0x02, LNKC, 0x00 },
+				Package (0x04) { 0xFFFF, 0x03, LNKD, 0x00 },
+			})
+
+			Name (AR07, Package () {
+				/* APIC */
+				Package (0x04) { 0xFFFF, 0x00, 0x00, 40 },
+				Package (0x04) { 0xFFFF, 0x01, 0x00, 41 },
+				Package (0x04) { 0xFFFF, 0x02, 0x00, 42 },
+				Package (0x04) { 0xFFFF, 0x03, 0x00, 43 },
+			})
+
+			/* PCI Resource Tables */
+
+			/* PCI Resource Settings Access */
+			Method (_CRS, 0, Serialized)
+			{
+				Name (BUF0, ResourceTemplate ()
+				{
+					IO (Decode16,
+					0x0CF8,	// Address Range Minimum
+					0x0CF8,	// Address Range Maximum
+					0x01,	// Address Alignment
+					0x08,	// Address Length
+					)
+					WordIO (ResourceProducer, MinFixed, MaxFixed, PosDecode, EntireRange,
+					0x0000,	// Address Space Granularity
+					0x0000,	// Address Range Minimum
+					0x0CF7,	// Address Range Maximum
+					0x0000,	// Address Translation Offset
+					0x0CF8,	// Address Length
+					,, , TypeStatic)
+				})
+				/* Methods below use SSDT to get actual MMIO regs
+				   The IO ports are from 0xd00, optionally an VGA,
+				   otherwise the info from MMIO is used.
+				   \_SB.GXXX(node, link)
+				 */
+				Concatenate (\_SB.GMEM (0x00, \_SB.PCI0.SBLK), BUF0, Local1)
+				Concatenate (\_SB.GIOR (0x00, \_SB.PCI0.SBLK), Local1, Local2)
+				Concatenate (\_SB.GWBN (0x00, \_SB.PCI0.SBLK), Local2, Local3)
+				Return (Local3)
+			}
+
+			/* PCI Routing Table Access */
+			Method (_PRT, 0, NotSerialized) {
+				If (PICM) {
+					Return (AR00)
+				} Else {
+					Return (PR00)
+				}
+			}
+
+			/* 0:11.0 SP5100 SATA 0 */
+			Device(SAT0)
+			{
+				Name (_ADR, 0x00110000)  // _ADR: Address
+				Name(_PRW, Package () {0x05, 0x04})	// Wake from S1-S4
+				#include "southbridge/amd/sb700/acpi/sata.asl"
+			}
+
+			/* 0:12.0 SP5100 USB 0 */
+			Device (USB0)
+			{
+				Name (_ADR, 0x00120000)  // _ADR: Address
+				Name(_PRW, Package () {0x05, 0x04})	// Wake from S1-S4
+			}
+
+			/* 0:12.1 SP5100 USB 1 */
+			Device (USB1)
+			{
+				Name (_ADR, 0x00120001)  // _ADR: Address
+				Name(_PRW, Package () {0x05, 0x04})	// Wake from S1-S4
+			}
+
+			/* 0:12.2 SP5100 USB 2 */
+			Device (USB2)
+			{
+				Name (_ADR, 0x00120002)  // _ADR: Address
+				Name(_PRW, Package () {0x05, 0x04})	// Wake from S1-S4
+			}
+
+			/* 0:13.0 SP5100 USB 3 */
+			Device (USB3)
+			{
+				Name (_ADR, 0x00130000)  // _ADR: Address
+				Name(_PRW, Package () {0x05, 0x04})	// Wake from S1-S4
+			}
+
+			/* 0:13.1 SP5100 USB 4 */
+			Device (USB4)
+			{
+				Name (_ADR, 0x00130001)  // _ADR: Address
+				Name(_PRW, Package () {0x05, 0x04})	// Wake from S1-S4
+			}
+
+			/* 0:13.2 SP5100 USB 5 */
+			Device (USB5)
+			{
+				Name (_ADR, 0x00130002)  // _ADR: Address
+				Name(_PRW, Package () {0x05, 0x04})	// Wake from S1-S4
+			}
+
+			/* 0:14.1 SP5100 IDE Controller */
+			Device (IDEC)
+			{
+				Name (_ADR, 0x00140001)  // _ADR: Address
+				Name(_PRW, Package () {0x05, 0x04})	// Wake from S1-S4
+				#include "southbridge/amd/sb700/acpi/ide.asl"
+			}
+
+			/* 0:14.3 SP5100 LPC */
+			Device (LPC) {
+				Name (_HID, EisaId ("PNP0A05"))
+				Name (_ADR, 0x00140003)
+
+				/* PS/2 keyboard (seems to be important for WinXP install) */
+				Device (KBD)
+				{
+					Name (_HID, EisaId ("PNP0303"))
+					Name (_CID, EisaId ("PNP030B"))
+					Method (_STA, 0, NotSerialized)
+					{
+						Return (0x0f)
+					}
+					Method (_CRS, 0, Serialized)
+					{
+						Name (TMP, ResourceTemplate () {
+							IO (Decode16, 0x0060, 0x0060, 0x01, 0x01)
+							IO (Decode16, 0x0064, 0x0064, 0x01, 0x01)
+							IRQNoFlags () {1}
+						})
+						Return (TMP)
+					}
+				}
+
+				/* PS/2 mouse */
+				Device (MOU)
+				{
+					Name (_HID, EisaId ("PNP0F03"))
+					Name (_CID, EisaId ("PNP0F13"))
+					Method (_STA, 0, NotSerialized)
+					{
+						Return (0x0f)
+					}
+					Method (_CRS, 0, Serialized)
+					{
+						Name (TMP, ResourceTemplate () {
+							IRQNoFlags () {12}
+						})
+						Return (TMP)
+					}
+				}
+
+
+				/* UART 1 */
+				Device (URT1)
+				{
+					Name (_HID, EisaId ("PNP0501"))		// "PNP0501" for UART
+					Name(_PRW, Package () {0x03, 0x04})	// Wake from S1-S4
+					Method (_STA, 0, NotSerialized)
+					{
+						Return (0x0f)			// Always enable
+					}
+					Name (_PRS, ResourceTemplate() {
+						StartDependentFn(0, 1) {
+							IO(Decode16, 0x3f8, 0x3f8, 0x8, 0x8)
+							IRQNoFlags() { 4 }
+						} EndDependentFn()
+					})
+					Method (_CRS, 0)
+					{
+						Return(ResourceTemplate() {
+							IO(Decode16, 0x3f8, 0x3f8, 0x8, 0x8)
+							IRQNoFlags() { 4 }
+						})
+					}
+				}
+
+				/* High Precision Event Timer */
+				Device (HPET)
+				{
+					Name (_HID, EisaId ("PNP0103"))
+					Name (CRS, ResourceTemplate ()
+					{
+						Memory32Fixed (ReadOnly,
+						0x00000000,
+						0x00001000,
+						_Y02)
+						IRQNoFlags () {0}
+						IRQNoFlags () {8}
+					})
+					Method (_STA, 0, NotSerialized)
+					{
+						Return (0x0F)
+					}
+					Method (_CRS, 0, NotSerialized)
+					{
+						CreateDWordField (CRS, \_SB.PCI0.LPC.HPET._Y02._BAS, HPT1)
+						CreateDWordField (CRS, \_SB.PCI0.LPC.HPET._Y02._LEN, HPT2)
+						Store (SHPB, HPT1)
+						Store (SHPL, HPT2)
+						Return (CRS)
+					}
+
+				}
+			}
+
+			/* 0:14.4 PCI Bridge */
+			Device (PBR0)
+			{
+				Name (_ADR, 0x00140004)			// _ADR: Address
+				Name(_PRW, Package () {0x11, 0x04})	// Wake from S1-S4
+				Method (_PRT, 0, NotSerialized)		// _PRT: PCI Routing Table
+				{
+					If (PICM) {
+						Return (AR01)
+					} Else {
+						Return (PR01)
+					}
+				}
+				Device (SLT1)
+				{
+					Name (_ADR, 0xFFFF)			// _ADR: Address
+					Name(_PRW, Package () {0x0B, 0x04})	// Wake from S1-S4
+				}
+			}
+
+			/* 0:14.5 SP5100 USB 6 */
+			Device (USB6)
+			{
+				Name (_ADR, 0x00140005)  // _ADR: Address
+				Name(_PRW, Package () {0x05, 0x04})	// Wake from S1-S4
+			}
+
+			/* 2:00.0 PCIe x16 */
+			Device (PCE1)
+			{
+				Name (_ADR, 0x00020000)			// _ADR: Address
+				Name(_PRW, Package () {0x11, 0x04})	// Wake from S1-S4
+				Method (_PRT, 0, NotSerialized)		// _PRT: PCI Routing Table
+				{
+					If (PICM) {
+						Return (AR02)
+					} Else {
+						Return (PR02)
+					}
+				}
+				Device (SLT1)
+				{
+					Name (_ADR, 0xFFFF)			// _ADR: Address
+					Name(_PRW, Package () {0x0B, 0x04})	// Wake from S1-S4
+				}
+			}
+
+			/* 3:00.0 PCIe NIC A */
+			Device (NICA)
+			{
+				Name (_ADR, 0x00090000)  // _ADR: Address
+				Name(_PRW, Package () {0x11, 0x04})	// Wake from S1-S4
+				Method (_PRT, 0, NotSerialized)  // _PRT: PCI Routing Table
+				{
+					If (PICM) {
+						Return (AR03)
+					} Else {
+						Return (PR03)
+					}
+				}
+				Device (BDC1)
+				{
+					Name (_ADR, Zero)  // _ADR: Address
+				}
+			}
+
+			/* 4:00.0 PCIe NIC B */
+			Device (NICB)
+			{
+				Name (_ADR, 0x000A0000)  // _ADR: Address
+				Name(_PRW, Package () {0x11, 0x04})	// Wake from S1-S4
+				Method (_PRT, 0, NotSerialized)  // _PRT: PCI Routing Table
+				{
+					If (PICM) {
+						Return (AR04)
+					} Else {
+						Return (PR04)
+					}
+				}
+				Device (BDC2)
+				{
+					Name (_ADR, Zero)  // _ADR: Address
+				}
+			}
+
+			/* 5:00.0 PCIe x16 */
+			Device (PCE4)
+			{
+				Name (_ADR, 0x000B0000)			// _ADR: Address
+				Name(_PRW, Package () {0x11, 0x04})	// Wake from S1-S4
+				Method (_PRT, 0, NotSerialized)		// _PRT: PCI Routing Table
+				{
+					If (PICM) {
+						Return (AR05)
+					} Else {
+						Return (PR05)
+					}
+				}
+				Device (SLT1)
+				{
+					Name (_ADR, 0xFFFF)			// _ADR: Address
+					Name(_PRW, Package () {0x0B, 0x04})	// Wake from S1-S4
+				}
+			}
+
+			/* 6:00.0 PCIe x16 */
+			Device (PCE5)
+			{
+				Name (_ADR, 0x000C0000)			// _ADR: Address
+				Name(_PRW, Package () {0x11, 0x04})	// Wake from S1-S4
+				Method (_PRT, 0, NotSerialized)		// _PRT: PCI Routing Table
+				{
+					If (PICM) {
+						Return (AR06)
+					} Else {
+						Return (PR06)
+					}
+				}
+				Device (SLT1)
+				{
+					Name (_ADR, 0xFFFF)			// _ADR: Address
+					Name(_PRW, Package () {0x0B, 0x04})	// Wake from S1-S4
+				}
+			}
+
+			/* 7:00.0 PCIe x16 */
+			Device (PCE3)
+			{
+				Name (_ADR, 0x000D0000)			// _ADR: Address
+				Name(_PRW, Package () {0x11, 0x04})	// Wake from S1-S4
+				Method (_PRT, 0, NotSerialized)		// _PRT: PCI Routing Table
+				{
+					If (PICM) {
+						Return (AR07)
+					} Else {
+						Return (PR07)
+					}
+				}
+				Device (SLT1)
+				{
+					Name (_ADR, 0xFFFF)			// _ADR: Address
+					Name(_PRW, Package () {0x0B, 0x04})	// Wake from S1-S4
+				}
+			}
+		}
+
+		Device (PWRB) {	/* Start Power button device */
+			Name(_HID, EISAID("PNP0C0C"))
+			Name(_UID, 0xAA)
+			Name(_PRW, Package () {3, 0x04})	/* wake from S1-S4 */
+			Name(_STA, 0x0B) /* sata is invisible */
+		}
+	}
+
+#include "acpi/pm_ctrl.asl"
+
+}
diff --git a/src/mainboard/asus/kgpe-d16/get_bus_conf.c b/src/mainboard/asus/kgpe-d16/get_bus_conf.c
new file mode 100644
index 0000000..09fa262
--- /dev/null
+++ b/src/mainboard/asus/kgpe-d16/get_bus_conf.c
@@ -0,0 +1,128 @@
+ /*
+ * This file is part of the coreboot project.
+ *
+ * Copyright (C) 2010 Advanced Micro Devices, Inc.
+ * Copyright (C) 2015 Timothy Pearson <tpearson@raptorengineeringinc.com>, Raptor Engineering
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <console/console.h>
+#include <device/pci.h>
+#include <device/pci_ids.h>
+#include <string.h>
+#include <stdint.h>
+#include <stdlib.h>
+#if CONFIG_LOGICAL_CPUS
+#include <cpu/amd/multicore.h>
+#endif
+
+#include <cpu/amd/amdfam10_sysconf.h>
+
+/* Global variables for MB layouts and these will be shared by irqtable mptable
+* and acpi_tables busnum is default.
+*/
+u8 bus_isa;
+u8 bus_sr5650[14];
+u8 bus_sp5100[2];
+u32 apicid_sp5100;
+
+/*
+* Here you only need to set value in pci1234 for HT-IO that could be installed or not
+* You may need to preset pci1234 for HTIO board,
+* please refer to src/northbridge/amd/amdk8/get_sblk_pci1234.c for detail
+*/
+u32 pci1234x[] = {
+	0x0000ff0,
+};
+
+/*
+* HT Chain device num, actually it is unit id base of every ht device in chain,
+* assume every chain only have 4 ht device at most
+*/
+u32 hcdnx[] = {
+	0x20202020,
+};
+
+
+u32 sbdn_sr5650;
+u32 sbdn_sp5100;
+
+extern void get_pci1234(void);
+
+static u32 get_bus_conf_done = 0;
+
+void get_bus_conf(void)
+{
+	u32 apicid_base;
+	device_t dev;
+	int i;
+
+	if (get_bus_conf_done == 1)
+		return;		/* do it only once */
+	get_bus_conf_done = 1;
+
+	sysconf.hc_possible_num = ARRAY_SIZE(pci1234x);
+	for (i = 0; i < sysconf.hc_possible_num; i++) {
+		sysconf.pci1234[i] = pci1234x[i];
+		sysconf.hcdn[i] = hcdnx[i];
+	}
+
+	get_pci1234();
+
+	sysconf.sbdn = (sysconf.hcdn[0] & 0xff);
+	sbdn_sr5650 = sysconf.sbdn;
+	sbdn_sp5100 = 0;
+
+	for (i = 0; i < 2; i++) {
+		bus_sp5100[i] = 0;
+	}
+	for (i = 0; i < ARRAY_SIZE(bus_sr5650); i++) {
+		bus_sr5650[i] = 0;
+	}
+
+
+	bus_sr5650[0] = (sysconf.pci1234[0] >> 16) & 0xff;
+	bus_sp5100[0] = bus_sr5650[0];
+
+
+	/* sp5100 */
+	dev = dev_find_slot(bus_sp5100[0], PCI_DEVFN(sbdn_sp5100 + 0x14, 4));
+	if (dev) {
+		bus_sp5100[1] = pci_read_config8(dev, PCI_SECONDARY_BUS);
+		bus_isa = pci_read_config8(dev, PCI_SUBORDINATE_BUS);
+		bus_isa++;
+	}
+
+	/* sr5650 */
+	for (i = 1; i < ARRAY_SIZE(bus_sr5650); i++) {
+		dev = dev_find_slot(bus_sr5650[0], PCI_DEVFN(sbdn_sr5650 + i, 0));
+		if (dev) {
+			bus_sr5650[i] = pci_read_config8(dev, PCI_SECONDARY_BUS);
+			if(255 != bus_sr5650[i]) {
+				bus_isa = pci_read_config8(dev, PCI_SUBORDINATE_BUS);
+				bus_isa++;
+			}
+		}
+	}
+
+	/* I/O APICs:   APIC ID Version State   Address */
+	bus_isa = 10;
+#if CONFIG_LOGICAL_CPUS
+	apicid_base = get_apicid_base(1);
+#else
+	apicid_base = CONFIG_MAX_PHYSICAL_CPUS;
+#endif
+	apicid_sp5100 = apicid_base + 0;
+}
diff --git a/src/mainboard/asus/kgpe-d16/irq_tables.c b/src/mainboard/asus/kgpe-d16/irq_tables.c
new file mode 100644
index 0000000..5eb4c24
--- /dev/null
+++ b/src/mainboard/asus/kgpe-d16/irq_tables.c
@@ -0,0 +1,112 @@
+/*
+ * This file is part of the coreboot project.
+ *
+ * Copyright (C) 2010 Advanced Micro Devices, Inc.
+ * Copyright (C) 2015 Timothy Pearson <tpearson@raptorengineeringinc.com>, Raptor Engineering
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <console/console.h>
+#include <device/pci.h>
+#include <string.h>
+#include <stdint.h>
+#include <arch/pirq_routing.h>
+
+#include <cpu/amd/amdfam10_sysconf.h>
+
+static void write_pirq_info(struct irq_info *pirq_info, u8 bus, u8 devfn,
+			    u8 link0, u16 bitmap0, u8 link1, u16 bitmap1,
+			    u8 link2, u16 bitmap2, u8 link3, u16 bitmap3,
+			    u8 slot, u8 rfu)
+{
+	pirq_info->bus = bus;
+	pirq_info->devfn = devfn;
+	pirq_info->irq[0].link = link0;
+	pirq_info->irq[0].bitmap = bitmap0;
+	pirq_info->irq[1].link = link1;
+	pirq_info->irq[1].bitmap = bitmap1;
+	pirq_info->irq[2].link = link2;
+	pirq_info->irq[2].bitmap = bitmap2;
+	pirq_info->irq[3].link = link3;
+	pirq_info->irq[3].bitmap = bitmap3;
+	pirq_info->slot = slot;
+	pirq_info->rfu = rfu;
+}
+extern u8 bus_isa;
+extern u8 bus_rs780[8];
+extern u8 bus_sp5100[2];
+extern unsigned long sbdn_sp5100;
+
+unsigned long write_pirq_routing_table(unsigned long addr)
+{
+	struct irq_routing_table *pirq;
+	struct irq_info *pirq_info;
+	u32 slot_num;
+	u8 *v;
+
+	u8 sum = 0;
+	int i;
+
+	get_bus_conf();		/* it will find out all bus num and apic that share with mptable.c and mptable.c and acpi_tables.c */
+
+	/* Align the table to be 16 byte aligned. */
+	addr += 15;
+	addr &= ~15;
+
+	/* This table must be between 0xf0000 & 0x100000 */
+	printk(BIOS_INFO, "Writing IRQ routing tables to 0x%lx...", addr);
+
+	pirq = (void *)(addr);
+	v = (u8 *) (addr);
+
+	pirq->signature = PIRQ_SIGNATURE;
+	pirq->version = PIRQ_VERSION;
+
+	pirq->rtr_bus = bus_sp5100[0];
+	pirq->rtr_devfn = PCI_DEVFN(0x14, 4);
+
+	pirq->exclusive_irqs = 0;
+
+	pirq->rtr_vendor = 0x1002;
+	pirq->rtr_device = 0x4384;
+
+	pirq->miniport_data = 0;
+
+	memset(pirq->rfu, 0, sizeof(pirq->rfu));
+
+	pirq_info = (void *)(&pirq->checksum + 1);
+	slot_num = 0;
+
+	/* pci bridge */
+	write_pirq_info(pirq_info, bus_sp5100[0], ((sbdn_sp5100 + 0x14) << 3) | 4,
+			0x1, 0xdef8, 0x2, 0xdef8, 0x3, 0xdef8, 0x4, 0xdef8, 0,
+			0);
+	pirq_info++;
+	slot_num++;
+
+	pirq->size = 32 + 16 * slot_num;
+
+	for (i = 0; i < pirq->size; i++)
+		sum += v[i];
+
+	sum = pirq->checksum - sum;
+	if (sum != pirq->checksum) {
+		pirq->checksum = sum;
+	}
+
+	printk(BIOS_INFO, "write_pirq_routing_table done.\n");
+
+	return (unsigned long)pirq_info;
+}
diff --git a/src/mainboard/asus/kgpe-d16/mainboard.c b/src/mainboard/asus/kgpe-d16/mainboard.c
new file mode 100644
index 0000000..47ede34
--- /dev/null
+++ b/src/mainboard/asus/kgpe-d16/mainboard.c
@@ -0,0 +1,81 @@
+/*
+ * This file is part of the coreboot project.
+ *
+ * Copyright (C) 2015 Timothy Pearson <tpearson@raptorengineeringinc.com>, Raptor Engineering
+ * Copyright (C) 2010 Advanced Micro Devices, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <console/console.h>
+#include <device/device.h>
+#include <device/pci.h>
+#include <arch/io.h>
+#include <cpu/x86/msr.h>
+#include <cpu/amd/mtrr.h>
+#include <device/pci_def.h>
+#include <southbridge/amd/sb700/sb700.h>
+#include <southbridge/amd/sr5650/cmn.h>
+
+
+void set_pcie_reset(void);
+void set_pcie_dereset(void);
+
+void set_pcie_reset(void)
+{
+	device_t pcie_core_dev;
+
+	pcie_core_dev = dev_find_slot(0, PCI_DEVFN(0, 0));
+	set_htiu_enable_bits(pcie_core_dev, 0xA8, 0xFFFFFFFF, 0x28282828);
+	set_htiu_enable_bits(pcie_core_dev, 0xA9, 0x000000FF, 0x00000028);
+}
+
+void set_pcie_dereset(void)
+{
+	device_t pcie_core_dev;
+
+	pcie_core_dev = dev_find_slot(0, PCI_DEVFN(0, 0));
+	set_htiu_enable_bits(pcie_core_dev, 0xA8, 0xFFFFFFFF, 0x6F6F6F6F);
+	set_htiu_enable_bits(pcie_core_dev, 0xA9, 0x000000FF, 0x0000006F);
+}
+
+/*************************************************
+* enable the dedicated function in kgpe-d16 board.
+* This function is called earlier than sr5650_enable.
+*************************************************/
+static void mainboard_enable(device_t dev)
+{
+	printk(BIOS_INFO, "Mainboard KGPE-D16 Enable. dev=0x%p\n", dev);
+
+	msr_t msr, msr2;
+
+	/* TOP_MEM: the top of DRAM below 4G */
+	msr = rdmsr(TOP_MEM);
+	printk
+	    (BIOS_INFO, "%s, TOP MEM: msr.lo = 0x%08x, msr.hi = 0x%08x\n",
+	     __func__, msr.lo, msr.hi);
+
+	/* TOP_MEM2: the top of DRAM above 4G */
+	msr2 = rdmsr(TOP_MEM2);
+	printk
+	    (BIOS_INFO, "%s, TOP MEM2: msr2.lo = 0x%08x, msr2.hi = 0x%08x\n",
+	     __func__, msr2.lo, msr2.hi);
+
+	set_pcie_dereset();
+	/* get_ide_dma66(); */
+}
+
+struct chip_operations mainboard_ops = {
+	.enable_dev = mainboard_enable,
+};
diff --git a/src/mainboard/asus/kgpe-d16/mb_sysconf.h b/src/mainboard/asus/kgpe-d16/mb_sysconf.h
new file mode 100644
index 0000000..3a407a6
--- /dev/null
+++ b/src/mainboard/asus/kgpe-d16/mb_sysconf.h
@@ -0,0 +1,44 @@
+/*
+ * This file is part of the coreboot project.
+ *
+ * Copyright (C) 2010 Advanced Micro Devices, Inc.
+ * Copyright (C) 2015 Timothy Pearson <tpearson@raptorengineeringinc.com>, Raptor Engineering
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef MB_SYSCONF_H
+
+#define MB_SYSCONF_H
+
+struct mb_sysconf_t {
+	u8 bus_isa;
+	u8 bus_8132_0;
+	u8 bus_8132_1;
+	u8 bus_8132_2;
+	u8 bus_8111_0;
+	u8 bus_8111_1;
+	u8 bus_8132a[31][3];
+	u8 bus_8151[31][2];
+
+	u32 apicid_8111;
+	u32 apicid_8132_1;
+	u32 apicid_8132_2;
+	u32 apicid_8132a[31][2];
+	u32 sbdn3;
+	u32 sbdn3a[31];
+	u32 sbdn5[31];
+};
+
+#endif
diff --git a/src/mainboard/asus/kgpe-d16/mptable.c b/src/mainboard/asus/kgpe-d16/mptable.c
new file mode 100644
index 0000000..0279f8b
--- /dev/null
+++ b/src/mainboard/asus/kgpe-d16/mptable.c
@@ -0,0 +1,231 @@
+/*
+ * This file is part of the coreboot project.
+ *
+ * Copyright (C) 2010 Advanced Micro Devices, Inc.
+ * Copyright (C) 2015 Timothy Pearson <tpearson@raptorengineeringinc.com>, Raptor Engineering
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <console/console.h>
+#include <arch/smp/mpspec.h>
+#include <device/pci.h>
+#include <arch/io.h>
+#include <string.h>
+#include <stdint.h>
+#include <cpu/amd/amdfam10_sysconf.h>
+
+extern u8 bus_sr5650[14];
+extern u8 bus_sp5100[2];
+
+extern u32 apicid_sp5100;
+
+extern u32 sbdn_sr5650;
+extern u32 sbdn_sp5100;
+
+
+static void *smp_write_config_table(void *v)
+{
+	struct mp_config_table *mc;
+	int bus_isa;
+	u32 apicid_sr5650;
+	device_t dev;
+	uint8_t sp5100_bus_number;
+
+	mc = (void *)(((char *)v) + SMP_FLOATING_TABLE_LEN);
+
+	mptable_init(mc, LOCAL_APIC_ADDR);
+
+	smp_write_processors(mc);
+
+	get_bus_conf();
+
+	apicid_sp5100 = 0x20;
+	apicid_sr5650 = apicid_sp5100 + 1;
+
+	mptable_write_buses(mc, NULL, &bus_isa);
+	/* I/O APICs:   APIC ID Version State   Address */
+	{
+		uint32_t *dword_ptr;
+		uint32_t dword;
+		uint16_t word;
+		uint8_t byte;
+
+		sp5100_bus_number = 0; //bus_sp5100[0]; TODO: why bus_sp5100[0] use same value of bus_sr5650[0] assigned by get_pci1234(), instead of 0.
+
+		dev = dev_find_slot(sp5100_bus_number, PCI_DEVFN(sbdn_sp5100 + 0x14, 0));
+		if (dev) {
+			dword_ptr = (u32 *)(pci_read_config32(dev, 0x74) & 0xfffffff0);
+			smp_write_ioapic(mc, apicid_sp5100, 0x11, dword_ptr);
+
+			/* Initialize interrupt mapping */
+			/* USB 1 & 2 */
+			word = pci_read_config16(dev, 0xbe);
+			word &= ~0x3f3f;
+			word |= 0x0;		/* 0: INTA, ...., 7: INTH */
+			word |= (0x1 << 3);	/* 0: INTA, ...., 7: INTH */
+			word |= (0x2 << 8);	/* 0: INTA, ...., 7: INTH */
+			word |= (0x3 << 11);	/* 0: INTA, ...., 7: INTH */
+			pci_write_config16(dev, 0xbe, word);
+
+			/* USB 3 */
+			byte = pci_read_config8(dev, 0x63);
+			byte &= 0xf8;
+			byte |= (0x2 << 4);	/* 0: INTA, ...., 7: INTH */
+			pci_write_config8(dev, 0x63, byte);
+
+			dword = pci_read_config32(dev, 0xac);
+
+			/* SATA */
+			dword &= ~(7 << 26);
+			dword |= (0x6 << 26);	/* 0: INTA, ...., 7: INTH */
+
+			/* Hide IDE */
+			dword &= ~(0x00080000);
+
+			/* dword_ptr |= 1<<22; PIC and APIC co exists */
+			pci_write_config32(dev, 0xac, dword);
+
+			/*
+			 * 00:12.0: PROG SATA : INT F
+			 * 00:13.0: INTA USB_0
+			 * 00:13.1: INTB USB_1
+			 * 00:13.2: INTC USB_2
+			 * 00:13.3: INTD USB_3
+			 * 00:13.4: INTC USB_4
+			 * 00:13.5: INTD USB2
+			 * 00:14.1: INTA IDE
+			 * 00:14.2: Prog HDA : INT E
+			 * 00:14.5: INTB ACI
+			 * 00:14.6: INTB MCI
+			 */
+		}
+		dev = dev_find_slot(0, PCI_DEVFN(0, 0));
+		if (dev) {
+			pci_write_config32(dev, 0xF8, 0x1);
+			dword_ptr = (u32 *)(pci_read_config32(dev, 0xFC) & 0xfffffff0);
+			smp_write_ioapic(mc, apicid_sr5650, 0x11, dword_ptr);
+		}
+	}
+
+	/* I/O Ints:    Type    Polarity    Trigger     Bus ID   IRQ    APIC ID PIN# */
+#define IO_LOCAL_INT(type, intr, apicid, pin) \
+	smp_write_lintsrc(mc, (type), MP_IRQ_TRIGGER_EDGE | MP_IRQ_POLARITY_HIGH, bus_isa, (intr), (apicid), (pin));
+
+	mptable_add_isa_interrupts(mc, bus_isa, apicid_sp5100, 0);
+
+	/* SR5650 devices */
+	smp_write_intsrc(mc, mp_INT, MP_IRQ_TRIGGER_LEVEL|MP_IRQ_POLARITY_LOW, 0, (((2)<<2)|(0)), apicid_sr5650, 28);	/* Device 2 (LNKE) */
+	smp_write_intsrc(mc, mp_INT, MP_IRQ_TRIGGER_LEVEL|MP_IRQ_POLARITY_LOW, 0, (((4)<<2)|(0)), apicid_sr5650, 28);	/* Device 4 (LNKF) */
+	smp_write_intsrc(mc, mp_INT, MP_IRQ_TRIGGER_LEVEL|MP_IRQ_POLARITY_LOW, 0, (((9)<<2)|(0)), apicid_sr5650, 29);	/* Device 9 (LNKG) */
+	smp_write_intsrc(mc, mp_INT, MP_IRQ_TRIGGER_LEVEL|MP_IRQ_POLARITY_LOW, 0, (((10)<<2)|(0)), apicid_sr5650, 30);	/* Device 10 (LNKG) */
+	smp_write_intsrc(mc, mp_INT, MP_IRQ_TRIGGER_LEVEL|MP_IRQ_POLARITY_LOW, 0, (((11)<<2)|(0)), apicid_sr5650, 30);	/* Device 11 (LNKG) */
+	smp_write_intsrc(mc, mp_INT, MP_IRQ_TRIGGER_LEVEL|MP_IRQ_POLARITY_LOW, 0, (((12)<<2)|(0)), apicid_sr5650, 30);	/* Device 12 (LNKG) */
+	smp_write_intsrc(mc, mp_INT, MP_IRQ_TRIGGER_LEVEL|MP_IRQ_POLARITY_LOW, 0, (((13)<<2)|(0)), apicid_sr5650, 30);	/* Device 13 (LNKG) */
+
+	dev = dev_find_slot(0, PCI_DEVFN(0x2, 0));
+	if (dev && dev->enabled) {
+		uint8_t bus_pci = dev->link_list->secondary;
+		smp_write_intsrc(mc, mp_INT, MP_IRQ_TRIGGER_LEVEL|MP_IRQ_POLARITY_LOW, bus_pci, (((0)<<0x2)|(0)), apicid_sr5650, 0);	/* card behind dev2 */
+	}
+	dev = dev_find_slot(0, PCI_DEVFN(0x4, 0));
+	if (dev && dev->enabled) {
+		uint8_t bus_pci = dev->link_list->secondary;
+		smp_write_intsrc(mc, mp_INT, MP_IRQ_TRIGGER_LEVEL|MP_IRQ_POLARITY_LOW, bus_pci, (((0)<<0x4)|(0)), apicid_sr5650, 0);	/* PIKE */
+	}
+	dev = dev_find_slot(0, PCI_DEVFN(0x9, 0));
+	if (dev && dev->enabled) {
+		uint8_t bus_pci = dev->link_list->secondary;
+		smp_write_intsrc(mc, mp_INT, MP_IRQ_TRIGGER_LEVEL|MP_IRQ_POLARITY_LOW, bus_pci, (((0)<<0x9)|(0)), apicid_sr5650, 23);	/* NIC A */
+	}
+	dev = dev_find_slot(0, PCI_DEVFN(0xa, 0));
+	if (dev && dev->enabled) {
+		uint8_t bus_pci = dev->link_list->secondary;
+		smp_write_intsrc(mc, mp_INT, MP_IRQ_TRIGGER_LEVEL|MP_IRQ_POLARITY_LOW, bus_pci, (((0)<<0xa)|(0)), apicid_sr5650, 24);	/* NIC B */
+	}
+	dev = dev_find_slot(0, PCI_DEVFN(0xb, 0));
+	if (dev && dev->enabled) {
+		uint8_t bus_pci = dev->link_list->secondary;
+		smp_write_intsrc(mc, mp_INT, MP_IRQ_TRIGGER_LEVEL|MP_IRQ_POLARITY_LOW, bus_pci, (((0)<<0xb)|(0)), apicid_sr5650, 0);	/* card behind dev11 */
+	}
+	dev = dev_find_slot(0, PCI_DEVFN(0xc, 0));
+	if (dev && dev->enabled) {
+		uint8_t bus_pci = dev->link_list->secondary;
+		smp_write_intsrc(mc, mp_INT, MP_IRQ_TRIGGER_LEVEL|MP_IRQ_POLARITY_LOW, bus_pci, (((0)<<0xc)|(0)), apicid_sr5650, 0);	/* card behind dev12 */
+	}
+	dev = dev_find_slot(0, PCI_DEVFN(0xd, 0));
+	if (dev && dev->enabled) {
+		uint8_t bus_pci = dev->link_list->secondary;
+		smp_write_intsrc(mc, mp_INT, MP_IRQ_TRIGGER_LEVEL|MP_IRQ_POLARITY_LOW, bus_pci, (((0)<<0xd)|(0)), apicid_sr5650, 0);	/* card behind dev13 */
+	}
+
+	/* PCI interrupts are level triggered, and are
+	 * associated with a specific bus/device/function tuple.
+	 */
+#define PCI_INT(bus, dev, interrupt_signal, pin) \
+	smp_write_intsrc(mc, mp_INT, MP_IRQ_TRIGGER_LEVEL|MP_IRQ_POLARITY_LOW, (bus), (((dev)<<2)|(interrupt_signal)), apicid_sp5100, (pin))
+
+	/* USB1 */
+	PCI_INT(sp5100_bus_number, 0x12, 0x0, 0x10); /* OHCI0 Port 0~2 */
+	PCI_INT(sp5100_bus_number, 0x12, 0x1, 0x11); /* OHCI1 Port 3~5 */
+
+	/* USB2 */
+	PCI_INT(sp5100_bus_number, 0x13, 0x0, 0x12); /* OHCI0 Port 6~8 */
+	PCI_INT(sp5100_bus_number, 0x13, 0x1, 0x13); /* EHCI Port 6~11 */
+
+	/* USB3 */
+	PCI_INT(sp5100_bus_number, 0x14, 0x3, 0x12); /* OHCI0 Port 12~13 */
+
+	/* SATA */
+	PCI_INT(sp5100_bus_number, 0x11, 0x0, 0x16); /* 6, INTG */
+
+	/* PCI slots */
+	dev = dev_find_slot(0, PCI_DEVFN(0x14, 4));
+	if (dev && dev->enabled) {
+		u8 bus_pci = dev->link_list->secondary;
+
+		/* PCI_SLOT 0. */
+		PCI_INT(bus_pci, 0x1, 0x0, 0x15);
+		PCI_INT(bus_pci, 0x1, 0x1, 0x16);
+		PCI_INT(bus_pci, 0x1, 0x2, 0x17);
+		PCI_INT(bus_pci, 0x1, 0x3, 0x14);
+
+		/* PCI_SLOT 1. */
+		PCI_INT(bus_pci, 0x2, 0x0, 0x14);
+		PCI_INT(bus_pci, 0x2, 0x1, 0x15);
+		PCI_INT(bus_pci, 0x2, 0x2, 0x16);
+		PCI_INT(bus_pci, 0x2, 0x3, 0x17);
+
+		/* PCI_SLOT 2. */
+		PCI_INT(bus_pci, 0x3, 0x0, 0x16);
+		PCI_INT(bus_pci, 0x3, 0x1, 0x17);
+		PCI_INT(bus_pci, 0x3, 0x2, 0x14);
+		PCI_INT(bus_pci, 0x3, 0x3, 0x15);
+	}
+
+	/*Local Ints:   Type    Polarity    Trigger     Bus ID   IRQ    APIC ID PIN# */
+	IO_LOCAL_INT(mp_ExtINT, 0x0, MP_APIC_ALL, 0x0);
+	IO_LOCAL_INT(mp_NMI, 0x0, MP_APIC_ALL, 0x1);
+	/* There is no extension information... */
+
+	/* Compute the checksums */
+	return mptable_finalize(mc);
+}
+
+unsigned long write_smp_table(unsigned long addr)
+{
+	void *v;
+	v = smp_write_floating_table(addr, 0);
+	return (unsigned long)smp_write_config_table(v);
+}
diff --git a/src/mainboard/asus/kgpe-d16/resourcemap.c b/src/mainboard/asus/kgpe-d16/resourcemap.c
new file mode 100644
index 0000000..3e240dc
--- /dev/null
+++ b/src/mainboard/asus/kgpe-d16/resourcemap.c
@@ -0,0 +1,284 @@
+/*
+ * This file is part of the coreboot project.
+ *
+ * Copyright (C) 2015 Timothy Pearson <tpearson@raptorengineeringinc.com>, Raptor Engineering
+ *
+ * Copyright (C) 2007 AMD
+ * Written by Yinghai Lu <yinghailu@amd.com> for AMD.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+static void setup_mb_resource_map(void)
+{
+	static const unsigned int register_values[] = {
+		/* Careful set limit registers before base registers which contain the enables */
+		/* DRAM Limit i Registers
+		 * F1:0x44 i = 0
+		 * F1:0x4C i = 1
+		 * F1:0x54 i = 2
+		 * F1:0x5C i = 3
+		 * F1:0x64 i = 4
+		 * F1:0x6C i = 5
+		 * F1:0x74 i = 6
+		 * F1:0x7C i = 7
+		 * [ 2: 0] Destination Node ID
+		 *	   000 = Node 0
+		 *	   001 = Node 1
+		 *	   010 = Node 2
+		 *	   011 = Node 3
+		 *	   100 = Node 4
+		 *	   101 = Node 5
+		 *	   110 = Node 6
+		 *	   111 = Node 7
+		 * [ 7: 3] Reserved
+		 * [10: 8] Interleave select
+		 *	   specifies the values of A[14:12] to use with interleave enable.
+		 * [15:11] Reserved
+		 * [31:16] DRAM Limit Address i Bits 39-24
+		 *	   This field defines the upper address bits of a 40 bit  address
+		 *	   that define the end of the DRAM region.
+		 */
+		// PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x44), 0x0000f8f8, 0x00000000,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x4C), 0x0000f8f8, 0x00000001,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x54), 0x0000f8f8, 0x00000002,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x5C), 0x0000f8f8, 0x00000003,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x64), 0x0000f8f8, 0x00000004,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x6C), 0x0000f8f8, 0x00000005,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x74), 0x0000f8f8, 0x00000006,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x7C), 0x0000f8f8, 0x00000007,
+
+		/* DRAM Base i Registers
+		 * F1:0x40 i = 0
+		 * F1:0x48 i = 1
+		 * F1:0x50 i = 2
+		 * F1:0x58 i = 3
+		 * F1:0x60 i = 4
+		 * F1:0x68 i = 5
+		 * F1:0x70 i = 6
+		 * F1:0x78 i = 7
+		 * [ 0: 0] Read Enable
+		 *	   0 = Reads Disabled
+		 *	   1 = Reads Enabled
+		 * [ 1: 1] Write Enable
+		 *	   0 = Writes Disabled
+		 *	   1 = Writes Enabled
+		 * [ 7: 2] Reserved
+		 * [10: 8] Interleave Enable
+		 *	   000 = No interleave
+		 *	   001 = Interleave on A[12] (2 nodes)
+		 *	   010 = reserved
+		 *	   011 = Interleave on A[12] and A[14] (4 nodes)
+		 *	   100 = reserved
+		 *	   101 = reserved
+		 *	   110 = reserved
+		 *	   111 = Interleve on A[12] and A[13] and A[14] (8 nodes)
+		 * [15:11] Reserved
+		 * [31:16] DRAM Base Address i Bits 39-24
+		 *	   This field defines the upper address bits of a 40-bit address
+		 *	   that define the start of the DRAM region.
+		 */
+		// PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x40), 0x0000f8fc, 0x00000000,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x48), 0x0000f8fc, 0x00000000,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x50), 0x0000f8fc, 0x00000000,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x58), 0x0000f8fc, 0x00000000,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x60), 0x0000f8fc, 0x00000000,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x68), 0x0000f8fc, 0x00000000,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x70), 0x0000f8fc, 0x00000000,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x78), 0x0000f8fc, 0x00000000,
+
+		/* Memory-Mapped I/O Limit i Registers
+		 * F1:0x84 i = 0
+		 * F1:0x8C i = 1
+		 * F1:0x94 i = 2
+		 * F1:0x9C i = 3
+		 * F1:0xA4 i = 4
+		 * F1:0xAC i = 5
+		 * F1:0xB4 i = 6
+		 * F1:0xBC i = 7
+		 * [ 2: 0] Destination Node ID
+		 *	   000 = Node 0
+		 *	   001 = Node 1
+		 *	   010 = Node 2
+		 *	   011 = Node 3
+		 *	   100 = Node 4
+		 *	   101 = Node 5
+		 *	   110 = Node 6
+		 *	   111 = Node 7
+		 * [ 3: 3] Reserved
+		 * [ 5: 4] Destination Link ID
+		 *	   00 = Link 0
+		 *	   01 = Link 1
+		 *	   10 = Link 2
+		 *	   11 = Link 3
+		 * [ 6: 6] Reserved
+		 * [ 7: 7] Non-Posted
+		 *	   0 = CPU writes may be posted
+		 *	   1 = CPU writes must be non-posted
+		 * [31: 8] Memory-Mapped I/O Limit Address i (39-16)
+		 *	   This field defines the upp adddress bits of a 40-bit address that
+		 *	   defines the end of a memory-mapped I/O region n
+		 */
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x84), 0x00000048, 0x00000000,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x8C), 0x00000048, 0x00000000,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x94), 0x00000048, 0x00000000,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x9C), 0x00000048, 0x00000000,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xA4), 0x00000048, 0x00000000,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xAC), 0x00000048, 0x00000000,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xB4), 0x00000048, 0x00000000,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xBC), 0x00000048, 0x00000000,
+
+		/* Memory-Mapped I/O Base i Registers
+		 * F1:0x80 i = 0
+		 * F1:0x88 i = 1
+		 * F1:0x90 i = 2
+		 * F1:0x98 i = 3
+		 * F1:0xA0 i = 4
+		 * F1:0xA8 i = 5
+		 * F1:0xB0 i = 6
+		 * F1:0xB8 i = 7
+		 * [ 0: 0] Read Enable
+		 *	   0 = Reads disabled
+		 *	   1 = Reads Enabled
+		 * [ 1: 1] Write Enable
+		 *	   0 = Writes disabled
+		 *	   1 = Writes Enabled
+		 * [ 2: 2] Cpu Disable
+		 *	   0 = Cpu can use this I/O range
+		 *	   1 = Cpu requests do not use this I/O range
+		 * [ 3: 3] Lock
+		 *	   0 = base/limit registers i are read/write
+		 *	   1 = base/limit registers i are read-only
+		 * [ 7: 4] Reserved
+		 * [31: 8] Memory-Mapped I/O Base Address i (39-16)
+		 *	   This field defines the upper address bits of a 40bit address
+		 *	   that defines the start of memory-mapped I/O region i
+		 */
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x80), 0x000000f0, 0x00000000,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x88), 0x000000f0, 0x00000000,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x90), 0x000000f0, 0x00000000,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x98), 0x000000f0, 0x00000000,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xA0), 0x000000f0, 0x00000000,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xA8), 0x000000f0, 0x00000000,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xB0), 0x000000f0, 0x00000000,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xB8), 0x000000f0, 0x00000000,
+
+		/* PCI I/O Limit i Registers
+		 * F1:0xC4 i = 0
+		 * F1:0xCC i = 1
+		 * F1:0xD4 i = 2
+		 * F1:0xDC i = 3
+		 * [ 2: 0] Destination Node ID
+		 *	   000 = Node 0
+		 *	   001 = Node 1
+		 *	   010 = Node 2
+		 *	   011 = Node 3
+		 *	   100 = Node 4
+		 *	   101 = Node 5
+		 *	   110 = Node 6
+		 *	   111 = Node 7
+		 * [ 3: 3] Reserved
+		 * [ 5: 4] Destination Link ID
+		 *	   00 = Link 0
+		 *	   01 = Link 1
+		 *	   10 = Link 2
+		 *	   11 = Link 3
+		 * [11: 6] Reserved
+		 * [24:12] PCI I/O Limit Address i
+		 *	   This field defines the end of PCI I/O region n
+		 * [31:25] Reserved
+		 */
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xC4), 0xFE000FC8, 0x00fff110, /* link 3 of cpu 0 --> AMD SR5690 */
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xCC), 0xFE000FC8, 0x00000000,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xD4), 0xFE000FC8, 0x00000000,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xDC), 0xFE000FC8, 0x00000000,
+
+		/* PCI I/O Base i Registers
+		 * F1:0xC0 i = 0
+		 * F1:0xC8 i = 1
+		 * F1:0xD0 i = 2
+		 * F1:0xD8 i = 3
+		 * [ 0: 0] Read Enable
+		 *	   0 = Reads Disabled
+		 *	   1 = Reads Enabled
+		 * [ 1: 1] Write Enable
+		 *	   0 = Writes Disabled
+		 *	   1 = Writes Enabled
+		 * [ 3: 2] Reserved
+		 * [ 4: 4] VGA Enable
+		 *	   0 = VGA matches Disabled
+		 *	   1 = matches all address < 64K and where A[9:0] is in the
+		 *	       range 3B0-3BB or 3C0-3DF independent of the base & limit registers
+		 * [ 5: 5] ISA Enable
+		 *	   0 = ISA matches Disabled
+		 *	   1 = Blocks address < 64K and in the last 768 bytes of eack 1K block
+		 *	       from matching agains this base/limit pair
+		 * [11: 6] Reserved
+		 * [24:12] PCI I/O Base i
+		 *	   This field defines the start of PCI I/O region n
+		 * [31:25] Reserved
+		 */
+// 		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xC0), 0xFE000FCC, 0x00001013,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xC8), 0xFE000FCC, 0x00000000,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xD0), 0xFE000FCC, 0x00000000,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xD8), 0xFE000FCC, 0x00000000,
+
+		/* Config Base and Limit i Registers
+		 * F1:0xE0 i = 0
+		 * F1:0xE4 i = 1
+		 * F1:0xE8 i = 2
+		 * F1:0xEC i = 3
+		 * [ 0: 0] Read Enable
+		 *	   0 = Reads Disabled
+		 *	   1 = Reads Enabled
+		 * [ 1: 1] Write Enable
+		 *	   0 = Writes Disabled
+		 *	   1 = Writes Enabled
+		 * [ 2: 2] Device Number Compare Enable
+		 *	   0 = The ranges are based on bus number
+		 *	   1 = The ranges are ranges of devices on bus 0
+		 * [ 3: 3] Reserved
+		 * [ 6: 4] Destination Node
+		 *	   000 = Node 0
+		 *	   001 = Node 1
+		 *	   010 = Node 2
+		 *	   011 = Node 3
+		 *	   100 = Node 4
+		 *	   101 = Node 5
+		 *	   110 = Node 6
+		 *	   111 = Node 7
+		 * [ 7: 7] Reserved
+		 * [ 9: 8] Destination Link
+		 *	   00 = Link 0
+		 *	   01 = Link 1
+		 *	   10 = Link 2
+		 *	   11 - Link 3
+		 * [15:10] Reserved
+		 * [23:16] Bus Number Base i
+		 *	   This field defines the lowest bus number in configuration region i
+		 * [31:24] Bus Number Limit i
+		 *	   This field defines the highest bus number in configuration region i
+		 */
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xE0), 0x0000FC88, 0x05000303, /* link 3 of cpu 0 --> AMD SR5690 */
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xE4), 0x0000FC88, 0x00000000,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xE8), 0x0000FC88, 0x00000000,
+		PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xEC), 0x0000FC88, 0x00000000,
+
+	};
+
+	int max;
+	max = ARRAY_SIZE(register_values);
+	setup_resource_map(register_values, max);
+}
diff --git a/src/mainboard/asus/kgpe-d16/romstage.c b/src/mainboard/asus/kgpe-d16/romstage.c
new file mode 100644
index 0000000..9964cfe
--- /dev/null
+++ b/src/mainboard/asus/kgpe-d16/romstage.c
@@ -0,0 +1,422 @@
+/*
+ * This file is part of the coreboot project.
+ *
+ * Copyright (C) 2015 Timothy Pearson <tpearson@raptorengineeringinc.com>, Raptor Engineering
+ *
+ * Copyright (C) 2007 AMD
+ * Written by Yinghai Lu <yinghailu@amd.com> for AMD.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <stdint.h>
+#include <string.h>
+#include <reset.h>
+#include <device/pci_def.h>
+#include <device/pci_ids.h>
+#include <arch/io.h>
+#include <device/pnp_def.h>
+#include <cpu/x86/lapic.h>
+#include <console/console.h>
+#include <timestamp.h>
+#include <lib.h>
+#include <spd.h>
+#include <cpu/amd/model_10xxx_rev.h>
+#include <northbridge/amd/amdfam10/raminit.h>
+#include <northbridge/amd/amdfam10/amdfam10.h>
+#include "lib/delay.c"
+#include <cpu/x86/lapic.h>
+#include "northbridge/amd/amdfam10/reset_test.c"
+#include <superio/nuvoton/common/nuvoton.h>
+#include <superio/nuvoton/nct5572d/nct5572d.h>
+#include <cpu/x86/bist.h>
+// #include "northbridge/amd/amdk8/incoherent_ht.c"
+#include <southbridge/amd/sb700/sb700.h>
+#include <southbridge/amd/sb700/smbus.h>
+#include <southbridge/amd/sr5650/sr5650.h>
+#include "northbridge/amd/amdfam10/debug.c"
+#include "northbridge/amd/amdfam10/setup_resource_map.c"
+
+#define SERIAL_DEV PNP_DEV(0x2e, NCT5572D_SP1)
+
+static void activate_spd_rom(const struct mem_controller *ctrl);
+
+static inline int spd_read_byte(unsigned device, unsigned address)
+{
+	return do_smbus_read_byte(SMBUS_AUX_IO_BASE, device, address);
+}
+
+#include <northbridge/amd/amdfam10/amdfam10.h>
+#include "northbridge/amd/amdfam10/raminit_sysinfo_in_ram.c"
+#include "northbridge/amd/amdfam10/pci.c"
+#include "resourcemap.c"
+#include "cpu/amd/quadcore/quadcore.c"
+
+#include <cpu/amd/microcode.h>
+
+#include "cpu/amd/model_10xxx/init_cpus.c"
+#include "northbridge/amd/amdfam10/early_ht.c"
+
+/*
+ * ASUS KGPE-D16 specific SPD enable/disable magic.
+ *
+ * Setting SP5100 GPIOs 59 and 60 controls an SPI mux with four settings:
+ * 0: Disabled
+ * 1: Normal SPI access
+ * 2: CPU0 SPD
+ * 3: CPU1 SPD
+ *
+ * Disable SPD access after RAM init to allow access to standard SMBus/I2C offsets
+ * which is required e.g. by lm-sensors.
+ */
+
+/* Relevant GPIO register information is available in the
+ * AMD SP5100 Register Reference Guide rev. 3.03, page 130
+ */
+static void switch_spd_mux(uint8_t channel)
+{
+	uint8_t byte;
+
+	byte = pci_read_config8(PCI_DEV(0, 0x14, 0), 0x54);
+	byte &= ~0xc;			/* Clear SPD mux GPIOs */
+	byte &= ~0xc0;			/* Enable SPD mux GPIO output drivers */
+	byte |= (channel << 2) & 0xc;	/* Set SPD mux GPIOs */
+	pci_write_config8(PCI_DEV(0, 0x14, 0), 0x54, byte);
+}
+
+static const uint8_t spd_addr[] = {
+	// Socket 0 Node 0 ("Node 0")
+	RC00, DIMM0, DIMM1, 0, 0, DIMM2, DIMM3, 0, 0,
+	// Socket 0 Node 1 ("Node 1")
+	RC00, DIMM4, DIMM5, 0, 0, DIMM6, DIMM7, 0, 0,
+	// Socket 1 Node 1 ("Node 2")
+	RC01, DIMM4, DIMM5, 0, 0, DIMM6, DIMM7, 0, 0,
+	// Socket 1 Node 0 ("Node 3")
+	RC01, DIMM0, DIMM1, 0, 0, DIMM2, DIMM3, 0, 0,
+};
+
+static void activate_spd_rom(const struct mem_controller *ctrl) {
+	struct sys_info *sysinfo = &sysinfo_car;
+
+	printk(BIOS_DEBUG, "activate_spd_rom() for node %02x\n", ctrl->node_id);
+	if (ctrl->node_id == 0) {
+		printk(BIOS_DEBUG, "enable_spd_node0()\n");
+		switch_spd_mux(0x2);
+	} else if (ctrl->node_id == 1) {
+		printk(BIOS_DEBUG, "enable_spd_node1()\n");
+		switch_spd_mux((sysinfo->nodes <= 2)?0x2:0x3);
+	} else if (ctrl->node_id == 2) {
+		printk(BIOS_DEBUG, "enable_spd_node2()\n");
+		switch_spd_mux((sysinfo->nodes <= 2)?0x3:0x2);
+	} else if (ctrl->node_id == 3) {
+		printk(BIOS_DEBUG, "enable_spd_node3()\n");
+		switch_spd_mux(0x3);
+	}
+}
+
+/* Voltages are specified by index
+ * Valid indicies for this platform are:
+ * 0: 1.5V
+ * 1: 1.35V
+ * 2: 1.25V
+ * 3: 1.15V
+ */
+static void set_ddr3_voltage(uint8_t node, uint8_t index) {
+	uint8_t byte;
+	uint8_t value;
+
+	if (index == 0)
+		value = 0x0;
+	else if (index == 1)
+		value = 0x1;
+	else if (index == 2)
+		value = 0x4;
+	else if (index == 3)
+		value = 0x5;
+	if (node == 1)
+		value <<= 1;
+
+	/* Set GPIOs */
+	byte = pci_read_config8(PCI_DEV(0, 0x14, 3), 0xd1);
+	if (node == 0)
+		byte &= ~0x5;
+	if (node == 1)
+		byte &= ~0xa;
+	byte |= value;
+	pci_write_config8(PCI_DEV(0, 0x14, 3), 0xd1, byte);
+
+	/* Enable GPIO output drivers */
+	byte = pci_read_config8(PCI_DEV(0, 0x14, 3), 0xd0);
+	byte &= 0x0f;
+	pci_write_config8(PCI_DEV(0, 0x14, 3), 0xd0, byte);
+}
+
+static void set_peripheral_control_lines(void) {
+	uint8_t byte;
+
+	/* Enable PCICLK5 (onboard FireWire device) */
+	outb(0x41, 0xcd6);
+	outb(0x02, 0xcd7);
+
+	/* Enable the RTC AltCentury register */
+	outb(0x41, 0xcd6);
+	byte = inb(0xcd7);
+	byte |= 0x10;
+	outb(byte, 0xcd7);
+}
+
+#ifdef TEST_MEMORY
+static void execute_memory_test(void)
+{
+	/* Test DRAM functionality */
+	uint32_t i;
+	uint32_t* dataptr;
+	printk(BIOS_DEBUG, "Writing test patterns to memory...\n");
+	for (i=0; i < 0x1000000; i = i + 8) {
+		dataptr = (void *)(0x300000 + i);
+		*dataptr = 0x55555555;
+		dataptr = (void *)(0x300000 + i + 4);
+		*dataptr = 0xaaaaaaaa;
+	}
+	printk(BIOS_DEBUG, "Done!\n");
+	printk(BIOS_DEBUG, "Testing memory...\n");
+	uint32_t readback;
+	for (i=0; i < 0x1000000; i = i + 8) {
+		dataptr = (void *)(0x300000 + i);
+		readback = *dataptr;
+		if (readback != 0x55555555)
+			printk(BIOS_DEBUG, "%p: INCORRECT VALUE %08x (should have been %08x)\n", dataptr, readback, 0x55555555);
+		dataptr = (void *)(0x300000 + i + 4);
+		readback = *dataptr;
+		if (readback != 0xaaaaaaaa)
+			printk(BIOS_DEBUG, "%p: INCORRECT VALUE %08x (should have been %08x)\n", dataptr, readback, 0xaaaaaaaa);
+	}
+	printk(BIOS_DEBUG, "Done!\n");
+}
+#endif
+
+void cache_as_ram_main(unsigned long bist, unsigned long cpu_init_detectedx)
+{
+	struct sys_info *sysinfo = &sysinfo_car;
+
+	u32 bsp_apicid = 0, val;
+	msr_t msr;
+
+	timestamp_init(timestamp_get());
+	timestamp_add_now(TS_START_ROMSTAGE);
+
+	if (!cpu_init_detectedx && boot_cpu()) {
+		/* Nothing special needs to be done to find bus 0 */
+		/* Allow the HT devices to be found */
+		set_bsp_node_CHtExtNodeCfgEn();
+		enumerate_ht_chain();
+
+		/* SR56x0 pcie bridges block pci_locate_device() before pcie training.
+		 * disable all pcie bridges on SR56x0 to work around it
+		 */
+		sr5650_disable_pcie_bridge();
+
+		/* Initialize southbridge */
+		sb7xx_51xx_pci_port80();
+
+		/* Initialize early serial */
+		nuvoton_enable_serial(SERIAL_DEV, CONFIG_TTYS0_BASE);
+		console_init();
+	}
+
+	post_code(0x30);
+
+	if (bist == 0)
+		bsp_apicid = init_cpus(cpu_init_detectedx, sysinfo);
+
+	post_code(0x32);
+
+	enable_sr5650_dev8();
+	sb7xx_51xx_lpc_init();
+
+	if (CONFIG_MAX_PHYSICAL_CPUS != 4)
+		printk(BIOS_WARNING, "CONFIG_MAX_PHYSICAL_CPUS is %d, but this is a dual socket AMD G34 board!\n", CONFIG_MAX_PHYSICAL_CPUS);
+
+	/* Halt if there was a built in self test failure */
+	report_bist_failure(bist);
+
+	val = cpuid_eax(1);
+	printk(BIOS_DEBUG, "BSP Family_Model: %08x\n", val);
+	printk(BIOS_DEBUG, "*sysinfo range: [%p,%p]\n",sysinfo,sysinfo+1);
+	printk(BIOS_DEBUG, "bsp_apicid = %02x\n", bsp_apicid);
+	printk(BIOS_DEBUG, "cpu_init_detectedx = %08lx\n", cpu_init_detectedx);
+
+	/* Setup sysinfo defaults */
+	set_sysinfo_in_ram(0);
+
+	update_microcode(val);
+
+	post_code(0x33);
+
+	cpuSetAMDMSR();
+	post_code(0x34);
+
+	amd_ht_init(sysinfo);
+	amd_ht_fixup(sysinfo);
+	post_code(0x35);
+
+	/* Set DDR memory voltage
+	 * FIXME
+	 * This should be set based on the output of the DIMM SPDs
+	 * For now it is locked to 1.5V
+	 */
+	set_ddr3_voltage(0, 0);	/* Node 0 */
+	set_ddr3_voltage(1, 0);	/* Node 1 */
+
+	/* Setup nodes PCI space and start core 0 AP init. */
+	finalize_node_setup(sysinfo);
+
+	/* Setup any mainboard PCI settings etc. */
+	setup_mb_resource_map();
+	post_code(0x36);
+
+	/* wait for all the APs core0 started by finalize_node_setup. */
+	/* FIXME: A bunch of cores are going to start output to serial at once.
+	 * It would be nice to fix up prink spinlocks for ROM XIP mode.
+	 * I think it could be done by putting the spinlock flag in the cache
+	 * of the BSP located right after sysinfo.
+	 */
+	wait_all_core0_started();
+
+	/* run _early_setup before soft-reset. */
+	sr5650_early_setup();
+	sb7xx_51xx_early_setup();
+
+	if (IS_ENABLED(CONFIG_SET_FIDVID)) {
+		msr = rdmsr(0xc0010071);
+		printk(BIOS_DEBUG, "\nBegin FIDVID MSR 0xc0010071 0x%08x 0x%08x\n", msr.hi, msr.lo);
+
+		/* FIXME: The sb fid change may survive the warm reset and only need to be done once */
+		enable_fid_change_on_sb(sysinfo->sbbusn, sysinfo->sbdn);
+
+		post_code(0x39);
+
+		if (!warm_reset_detect(0)) {			// BSP is node 0
+			init_fidvid_bsp(bsp_apicid, sysinfo->nodes);
+		} else {
+			init_fidvid_stage2(bsp_apicid, 0);	// BSP is node 0
+		}
+
+		post_code(0x3A);
+
+		/* show final fid and vid */
+		msr=rdmsr(0xc0010071);
+		printk(BIOS_DEBUG, "End FIDVIDMSR 0xc0010071 0x%08x 0x%08x\n", msr.hi, msr.lo);
+	}
+
+	if (IS_ENABLED(CONFIG_LOGICAL_CPUS)) {
+		/* Core0 on each node is configured. Now setup any additional cores. */
+		printk(BIOS_DEBUG, "start_other_cores()\n");
+		start_other_cores();
+		post_code(0x37);
+		wait_all_other_cores_started(bsp_apicid);
+	}
+
+	post_code(0x38);
+
+	init_timer(); // Need to use TMICT to synconize FID/VID
+
+	sr5650_htinit();
+
+	/* Reset for HT, FIDVID, PLL and errata changes to take affect. */
+	if (!warm_reset_detect(0)) {
+		printk(BIOS_INFO, "...WARM RESET...\n\n\n");
+		soft_reset();
+		die("After soft_reset_x - shouldn't see this message!!!\n");
+	}
+
+	/* Set up peripheral control lines */
+	set_peripheral_control_lines();
+
+	post_code(0x3B);
+
+	/* It's the time to set ctrl in sysinfo now; */
+	printk(BIOS_DEBUG, "fill_mem_ctrl() detected %d nodes\n", sysinfo->nodes);
+	fill_mem_ctrl(sysinfo->nodes, sysinfo->ctrl, spd_addr);
+	post_code(0x3D);
+
+#if 0
+	/* FIXME
+	 * After the AMD K10 code has been converted to use
+	 * IS_ENABLED(CONFIG_DEBUG_SMBUS) uncomment this block
+	 */
+	if (IS_ENABLED(CONFIG_DEBUG_SMBUS)) {
+	        dump_spd_registers(&cpu[0]);
+        	dump_smbus_registers();
+	}
+#endif
+
+	post_code(0x40);
+
+	timestamp_add_now(TS_BEFORE_INITRAM);
+	printk(BIOS_DEBUG, "raminit_amdmct()\n");
+	raminit_amdmct(sysinfo);
+	timestamp_add_now(TS_AFTER_INITRAM);
+
+#if !IS_ENABLED(CONFIG_LATE_CBMEM_INIT)
+	cbmem_initialize_empty();
+	post_code(0x41);
+
+	amdmct_cbmem_store_info(sysinfo);
+#endif
+
+	printk(BIOS_DEBUG, "disable_spd()\n");
+	switch_spd_mux(0x1);
+
+	sr5650_before_pci_init();
+	sb7xx_51xx_before_pci_init();
+
+	/* Configure SP5100 GPIOs to match vendor settings */
+	pci_write_config16(PCI_DEV(0, 0x14, 0), 0x50, 0x0170);
+	pci_write_config16(PCI_DEV(0, 0x14, 0), 0x54, 0x0707);
+	pci_write_config16(PCI_DEV(0, 0x14, 0), 0x56, 0x0bb0);
+	pci_write_config16(PCI_DEV(0, 0x14, 0), 0x5a, 0x0ff0);
+
+	timestamp_add_now(TS_END_ROMSTAGE);
+
+#ifdef TEST_MEMORY
+	execute_memory_test();
+#endif
+
+	post_cache_as_ram();	// BSP switch stack to ram, copy then execute LB.
+	post_code(0x43);	// Should never see this post code.
+}
+
+/**
+ * BOOL AMD_CB_ManualBUIDSwapList(u8 Node, u8 Link, u8 **List)
+ * Description:
+ *	This routine is called every time a non-coherent chain is processed.
+ *	BUID assignment may be controlled explicitly on a non-coherent chain. Provide a
+ *	swap list. The first part of the list controls the BUID assignment and the
+ *	second part of the list provides the device to device linking.  Device orientation
+ *	can be detected automatically, or explicitly.  See documentation for more details.
+ *
+ *	Automatic non-coherent init assigns BUIDs starting at 1 and incrementing sequentially
+ *	based on each device's unit count.
+ *
+ * Parameters:
+ *	@param[in]  node   = The node on which this chain is located
+ *	@param[in]  link   = The link on the host for this chain
+ *	@param[out] List   = supply a pointer to a list
+ */
+BOOL AMD_CB_ManualBUIDSwapList (u8 node, u8 link, const u8 **List)
+{
+	return 0;
+}
\ No newline at end of file
diff --git a/src/mainboard/asus/kgpe-d16/spd_notes.txt b/src/mainboard/asus/kgpe-d16/spd_notes.txt
new file mode 100644
index 0000000..623a88f
--- /dev/null
+++ b/src/mainboard/asus/kgpe-d16/spd_notes.txt
@@ -0,0 +1,30 @@
+====================================================================================================
+SPD mux
+====================================================================================================
+                      SP5100
+                  GPIO 60 GPIO 59
+Disabled             0       0
+Normal operation     0       1
+CPU 0 SPD            1       0
+CPU 1 SPD            1       1
+
+====================================================================================================
+W83795
+====================================================================================================
+
+Sensor mappings:
+CPU_FAN1:  FAN1
+CPU_FAN2:  FAN2
+FRNT_FAN1: FAN3
+FRNT_FAN2: FAN4
+FRNT_FAN3: FAN5
+FRNT_FAN4: FAN6
+FRNT_FAN5: FAN7
+REAR_FAN1: FAN8
+
+====================================================================================================
+Other hardware
+====================================================================================================
+
+RECOVERY1 middle pin is connected to southbridge (AMD SP5100) GPIO 61
+Normal is HIGH, recovery is LOW.
-- 
1.9.1

