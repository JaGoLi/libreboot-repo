From 65404b72da34b2f786af5fa1901531e50f59d0d7 Mon Sep 17 00:00:00 2001
From: Timothy Pearson <tpearson@raptorengineeringinc.com>
Date: Sun, 2 Aug 2015 21:23:02 -0500
Subject: [PATCH 090/139] northbridge/amd/amdmct/mct_ddr3: Move K10D
 configuration into separate file

Change-Id: Id45888f266fac7810a63fef43b8d7a0ee40cbf70
Signed-off-by: Timothy Pearson <tpearson@raptorengineeringinc.com>
---
 src/northbridge/amd/amdfam10/raminit_amdmct.c  |   1 +
 src/northbridge/amd/amdmct/amddefs.h           |   5 +-
 src/northbridge/amd/amdmct/mct_ddr3/mct_d.c    | 133 ++++++++++++-------------
 src/northbridge/amd/amdmct/mct_ddr3/mctcsi_d.c |   4 +-
 src/northbridge/amd/amdmct/mct_ddr3/mctprod.c  |  65 ++++++++++++
 5 files changed, 132 insertions(+), 76 deletions(-)
 create mode 100644 src/northbridge/amd/amdmct/mct_ddr3/mctprod.c

diff --git a/src/northbridge/amd/amdfam10/raminit_amdmct.c b/src/northbridge/amd/amdfam10/raminit_amdmct.c
index cae228f..2cbe6b1 100644
--- a/src/northbridge/amd/amdfam10/raminit_amdmct.c
+++ b/src/northbridge/amd/amdfam10/raminit_amdmct.c
@@ -379,6 +379,7 @@ static uint16_t mct_MaxLoadFreq(uint8_t count, uint8_t highest_rank_count, uint8
 #include "../amdmct/mct_ddr3/mctdqs_d.c"
 #include "../amdmct/mct_ddr3/mctsrc.c"
 #include "../amdmct/mct_ddr3/mctsdi.c"
+#include "../amdmct/mct_ddr3/mctprod.c"
 #include "../amdmct/mct_ddr3/mctproc.c"
 #include "../amdmct/mct_ddr3/mctprob.c"
 #include "../amdmct/mct_ddr3/mcthwl.c"
diff --git a/src/northbridge/amd/amdmct/amddefs.h b/src/northbridge/amd/amdmct/amddefs.h
index 7aa4698..60d3c16 100644
--- a/src/northbridge/amd/amdmct/amddefs.h
+++ b/src/northbridge/amd/amdmct/amddefs.h
@@ -2,6 +2,7 @@
  * This file is part of the coreboot project.
  *
  * Copyright (C) 2007-2008 Advanced Micro Devices, Inc.
+ * Copyright (C) 2015 Timothy Pearson <tpearson@raptorengineeringinc.com>, Raptor Engineering
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -115,7 +116,7 @@
 /*
  * CPU HT PHY REGISTERS, FIELDS, AND MASKS
  */
-#define HTPHY_OFFSET_MASK		0xE00001FF
+#define HTPHY_OFFSET_MASK		0xE000FFFF
 #define HTPHY_WRITE_CMD			0x40000000
 #define HTPHY_IS_COMPLETE_MASK		0x80000000
 #define HTPHY_DIRECT_MAP		0x20000000
@@ -164,4 +165,4 @@
 #define AMD_PKGTYPE_S1gX 2
 #define AMD_PKGTYPE_G34 3
 #define AMD_PKGTYPE_ASB2 4
-#define AMD_PKGTYPE_C32 5
\ No newline at end of file
+#define AMD_PKGTYPE_C32 5
diff --git a/src/northbridge/amd/amdmct/mct_ddr3/mct_d.c b/src/northbridge/amd/amdmct/mct_ddr3/mct_d.c
index 0b61106..1167976 100644
--- a/src/northbridge/amd/amdmct/mct_ddr3/mct_d.c
+++ b/src/northbridge/amd/amdmct/mct_ddr3/mct_d.c
@@ -182,6 +182,7 @@ static void SyncSetting(struct DCTStatStruc *pDCTstat);
 static uint8_t crcCheck(struct DCTStatStruc *pDCTstat, uint8_t dimm);
 static void mct_ExtMCTConfig_Bx(struct DCTStatStruc *pDCTstat);
 static void mct_ExtMCTConfig_Cx(struct DCTStatStruc *pDCTstat);
+static void mct_ExtMCTConfig_Dx(struct DCTStatStruc *pDCTstat);
 
 static void read_dqs_receiver_enable_control_registers(uint16_t* current_total_delay,
 			uint32_t dev, uint8_t dct, uint8_t dimm, uint32_t index_reg);
@@ -2677,13 +2678,13 @@ static void MCTMemClr_D(struct MCTStatStruc *pMCTstat,
 	}
 
 	for (Node = 0; Node < MAX_NODES_SUPPORTED; Node++) {
-		/* Configure and enable prefetchers */
-		if (is_fam15h())
-			dword = 0x0ce00f41;	/* BKDG recommended */
-		else
-			dword = 0x0fe40fc0;	/* BKDG recommended */
-		dword |= MCCH_FlushWrOnStpGnt;	/* Set for S3 */
-		Set_NB32(pDCTstat->dev_dct, 0x11c, dword);
+		pDCTstat = pDCTstatA + Node;
+
+		/* Enable prefetchers */
+		dword = Get_NB32(pDCTstat->dev_dct, 0x11c);	/* Memory Controller Configuration High */
+		dword &= ~(0x1 << 13);				/* PrefIoDis = 0 */
+		dword &= ~(0x1 << 12);				/* PrefCpuDis = 0 */
+		Set_NB32(pDCTstat->dev_dct, 0x11c, dword);	/* Memory Controller Configuration High */
 	}
 }
 
@@ -4925,31 +4926,33 @@ static void Set_OtherTiming(struct MCTStatStruc *pMCTstat,
 	Get_TrwtTO(pMCTstat, pDCTstat, dct);
 	Get_TrwtWB(pMCTstat, pDCTstat);
 
-	reg = 0x8C;		/* Dram Timing Hi */
-	val = Get_NB32_DCT(dev, dct, reg);
-	val &= 0xffff0300;
-	dword = pDCTstat->TrwtTO;
-	val |= dword << 4;
-	dword = pDCTstat->Twrrd & 3;
-	val |= dword << 10;
-	dword = pDCTstat->Twrwr & 3;
-	val |= dword << 12;
-	dword = pDCTstat->Trdrd & 3;
-	val |= dword << 14;
-	dword = pDCTstat->TrwtWB;
-	val |= dword;
-	Set_NB32_DCT(dev, dct, reg, val);
-
-	reg = 0x78;
-	val = Get_NB32_DCT(dev, dct, reg);
-	val &= 0xFFFFC0FF;
-	dword = pDCTstat->Twrrd >> 2;
-	val |= dword << 8;
-	dword = pDCTstat->Twrwr >> 2;
-	val |= dword << 10;
-	dword = pDCTstat->Trdrd >> 2;
-	val |= dword << 12;
-	Set_NB32_DCT(dev, dct, reg, val);
+	if (!is_fam15h()) {
+		reg = 0x8c;		/* Dram Timing Hi */
+		val = Get_NB32_DCT(dev, dct, reg);
+		val &= 0xffff0300;
+		dword = pDCTstat->TrwtTO;
+		val |= dword << 4;
+		dword = pDCTstat->Twrrd & 3;
+		val |= dword << 10;
+		dword = pDCTstat->Twrwr & 3;
+		val |= dword << 12;
+		dword = (pDCTstat->Trdrd - 0x3) & 3;
+		val |= dword << 14;
+		dword = pDCTstat->TrwtWB;
+		val |= dword;
+		Set_NB32_DCT(dev, dct, reg, val);
+
+		reg = 0x78;
+		val = Get_NB32_DCT(dev, dct, reg);
+		val &= 0xffffc0ff;
+		dword = pDCTstat->Twrrd >> 2;
+		val |= dword << 8;
+		dword = pDCTstat->Twrwr >> 2;
+		val |= dword << 10;
+		dword = (pDCTstat->Trdrd - 0x3) >> 2;
+		val |= dword << 12;
+		Set_NB32_DCT(dev, dct, reg, val);
+	}
 }
 
 static void Get_Trdrd(struct MCTStatStruc *pMCTstat,
@@ -4960,6 +4963,8 @@ static void Get_Trdrd(struct MCTStatStruc *pMCTstat,
 	Trdrd = ((int8_t)(pDCTstat->DqsRcvEnGrossMax - pDCTstat->DqsRcvEnGrossMin) >> 1) + 1;
 	if (Trdrd > 8)
 		Trdrd = 8;
+	if (Trdrd < 3)
+		Trdrd = 3;
 	pDCTstat->Trdrd = Trdrd;
 }
 
@@ -5270,47 +5275,31 @@ static void mct_FinalMCT_D(struct MCTStatStruc *pMCTstat,
 		if (pDCTstat->NodePresent) {
 			mct_PhyController_Config(pMCTstat, pDCTstat, 0);
 			mct_PhyController_Config(pMCTstat, pDCTstat, 1);
-		}
-		if (!(pDCTstat->LogicalCPUID & AMD_DR_Dx)) { /* mct_checkForDxSupport */
-			mct_ExtMCTConfig_Cx(pDCTstat);
-			mct_ExtMCTConfig_Bx(pDCTstat);
-		} else {	/* For Dx CPU */
-			val = 0x0CE00F00 | 1 << 29/* FlushWrOnStpGnt */;
-			if (!(pDCTstat->GangedMode))
-				val |= 0x20; /* MctWrLimit =  8 for Unganged mode */
-			else
-				val |= 0x40; /* MctWrLimit =  16 for ganged mode */
-			Set_NB32(pDCTstat->dev_dct, 0x11C, val);
-
-			val = Get_NB32(pDCTstat->dev_dct, 0x1B0);
-			val &= 0xFFFFF8C0;
-			val |= 0x101;	/* BKDG recommended settings */
-			val |= 0x0FC00000; /* Agesa V5 */
-			if (!(pDCTstat->GangedMode))
-				val |= 1 << 12;
-			else
-				val &= ~(1 << 12);
 
-			val &= 0x0FFFFFFF;
 			if (!is_fam15h()) {
-				switch (pDCTstat->Speed) {
-				case 4:
-					val |= 0x50000000; /* 5 for DDR800 */
-					break;
-				case 5:
-					val |= 0x60000000; /* 6 for DDR1066 */
-					break;
-				case 6:
-					val |= 0x80000000; /* 8 for DDR800 */
-					break;
-				default:
-					val |= 0x90000000; /* 9 for DDR1600 */
-					break;
-				}
-			}
-			Set_NB32(pDCTstat->dev_dct, 0x1B0, val);
+				/* Family 10h CPUs */
+				mct_ExtMCTConfig_Cx(pDCTstat);
+				mct_ExtMCTConfig_Bx(pDCTstat);
+				mct_ExtMCTConfig_Dx(pDCTstat);
+			} else {
+				/* Family 15h CPUs */
+				val = 0x0ce00f00 | 0x1 << 29;	/* FlushWrOnStpGnt */
+				val |= 0x10 << 2;		/* MctWrLimit = 16 */
+				Set_NB32(pDCTstat->dev_dct, 0x11c, val);
+
+				val = Get_NB32(pDCTstat->dev_dct, 0x1b0);
+				val &= ~0x3;			/* AdapPrefMissRatio = 0x1 */
+				val |= 0x1;
+				val &= ~(0x3 << 2);		/* AdapPrefPositiveStep = 0x0 */
+				val &= ~(0x3 << 4);		/* AdapPrefNegativeStep = 0x0 */
+				val &= ~(0x7 << 8);		/* CohPrefPrbLmt = 0x1 */
+				val |= (0x1 << 8);
+				val |= (0x1 << 12);		/* EnSplitDctLimits = 0x1 */
+				val |= (0x7 << 22);		/* PrefFourConf = 0x7 */
+				val |= (0x7 << 25);		/* PrefFiveConf = 0x7 */
+				val &= ~(0xf << 28);		/* DcqBwThrotWm = 0x0 */
+				Set_NB32(pDCTstat->dev_dct, 0x1b0, val);
 
-			if (is_fam15h()) {
 				uint8_t wm1;
 				uint8_t wm2;
 
@@ -5341,11 +5330,11 @@ static void mct_FinalMCT_D(struct MCTStatStruc *pMCTstat,
 					break;
 				}
 
-				val = Get_NB32(pDCTstat->dev_dct, 0x1B4);
+				val = Get_NB32(pDCTstat->dev_dct, 0x1b4);
 				val &= ~(0x3ff);
 				val |= ((wm2 & 0x1f) << 5);
 				val |= (wm1 & 0x1f);
-				Set_NB32(pDCTstat->dev_dct, 0x1B4, val);
+				Set_NB32(pDCTstat->dev_dct, 0x1b4, val);
 			}
 		}
 	}
diff --git a/src/northbridge/amd/amdmct/mct_ddr3/mctcsi_d.c b/src/northbridge/amd/amdmct/mct_ddr3/mctcsi_d.c
index a1cdfa6..41f0946 100644
--- a/src/northbridge/amd/amdmct/mct_ddr3/mctcsi_d.c
+++ b/src/northbridge/amd/amdmct/mct_ddr3/mctcsi_d.c
@@ -102,7 +102,7 @@ void InterleaveBanks_D(struct MCTStatStruc *pMCTstat,
 		BitDelta = bsf(AddrHiMask) - bsf(AddrLoMask);
 
 		for (ChipSel = 0; ChipSel < MAX_CS_SUPPORTED; ChipSel++) {
-			reg = 0x40+(ChipSel<<2);	/*Dram CS Base 0 */
+			reg = 0x40 + (ChipSel<<2);	/* Dram CS Base 0 */
 			val = Get_NB32_DCT(dev, dct, reg);
 			if (val & 3) {
 				val_lo = val & AddrLoMask;
@@ -118,7 +118,7 @@ void InterleaveBanks_D(struct MCTStatStruc *pMCTstat,
 				if(ChipSel & 1)
 					continue;
 
-				reg = 0x60 + ((ChipSel>>1)<<2); /*Dram CS Mask 0 */
+				reg = 0x60 + ((ChipSel>>1)<<2); /* Dram CS Mask 0 */
 				val = Get_NB32_DCT(dev, dct, reg);
 				val_lo = val & AddrLoMask;
 				val_hi = val & AddrHiMask;
diff --git a/src/northbridge/amd/amdmct/mct_ddr3/mctprod.c b/src/northbridge/amd/amdmct/mct_ddr3/mctprod.c
new file mode 100644
index 0000000..2b62d4c
--- /dev/null
+++ b/src/northbridge/amd/amdmct/mct_ddr3/mctprod.c
@@ -0,0 +1,65 @@
+/*
+ * This file is part of the coreboot project.
+ *
+ * Copyright (C) 2015 Timothy Pearson <tpearson@raptorengineeringinc.com>, Raptor Engineering
+ * Copyright (C) 2010 Advanced Micro Devices, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.
+ */
+
+void mct_ExtMCTConfig_Dx(struct DCTStatStruc *pDCTstat)
+{
+	uint32_t dword;
+
+	if (pDCTstat->LogicalCPUID & AMD_DR_Dx) {
+		dword = 0x0ce00f00 | 0x1 << 29;	/* FlushWrOnStpGnt */
+		if (!(pDCTstat->GangedMode))
+			dword |= 0x18 << 2;	/* MctWrLimit = 0x18 for unganged mode */
+		else
+			dword |= 0x10 << 2;	/* MctWrLimit = 0x10 for ganged mode */
+		Set_NB32(pDCTstat->dev_dct, 0x11c, dword);
+
+		dword = Get_NB32(pDCTstat->dev_dct, 0x1b0);
+		dword &= ~0x3;			/* AdapPrefMissRatio = 0x1 */
+		dword |= 0x1;
+		dword &= ~(0x3 << 2);		/* AdapPrefPositiveStep = 0x0 */
+		dword &= ~(0x3 << 4);		/* AdapPrefNegativeStep = 0x0 */
+		dword &= ~(0x7 << 8);		/* CohPrefPrbLmt = 0x1 */
+		dword |= (0x1 << 8);
+		dword |= (0x7 << 22);		/* PrefFourConf = 0x7 */
+		dword |= (0x7 << 25);		/* PrefFiveConf = 0x7 */
+
+		if (!(pDCTstat->GangedMode))
+			dword |= (0x1 << 12);	/* EnSplitDctLimits = 0x1 */
+		else
+			dword &= ~(0x1 << 12);	/* EnSplitDctLimits = 0x0 */
+
+		dword &= ~(0xf << 28);		/* DcqBwThrotWm = ... */
+		switch (pDCTstat->Speed) {
+		case 4:
+			dword |= (0x5 << 28);	/* ...5 for DDR800 */
+			break;
+		case 5:
+			dword |= (0x6 << 28);	/* ...6 for DDR1066 */
+			break;
+		case 6:
+			dword |= (0x8 << 28);	/* ...8 for DDR800 */
+			break;
+		default:
+			dword |= (0x9 << 28);	/* ...9 for DDR1600 */
+			break;
+		}
+		Set_NB32(pDCTstat->dev_dct, 0x1b0, dword);
+	}
+}
-- 
1.9.1

